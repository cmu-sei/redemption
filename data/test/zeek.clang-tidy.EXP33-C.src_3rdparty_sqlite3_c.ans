--- /host/data/test/out/src/3rdparty/sqlite3.c	2024-05-23 18:58:33.411022548 +0000
+++ /oss/zeek/src/3rdparty/sqlite3.c	2024-05-23 11:26:50.212647874 +0000
@@ -1,5 +1,3 @@
-#include "acr.h"
-
 /******************************************************************************
 ** This file is an amalgamation of many separate C source files from SQLite
 ** version 3.38.4.  By combining all the individual C code files into this
@@ -22780,7 +22778,7 @@
 ** The caller must hold the appropriate mutex.
 */
 SQLITE_PRIVATE void sqlite3StatusHighwater(int op, int X){
-  sqlite3StatValueType newValue = 0;
+  sqlite3StatValueType newValue;
   wsdStatInit;
   assert( X>=0 );
   newValue = (sqlite3StatValueType)X;
@@ -22805,7 +22803,7 @@
   sqlite3_int64 *pHighwater,
   int resetFlag
 ){
-  sqlite3_mutex *pMutex = NULL;
+  sqlite3_mutex *pMutex;
   wsdStatInit;
   if( op<0 || op>=ArraySize(wsdStat.nowValue) ){
     return SQLITE_MISUSE_BKPT;
@@ -22826,7 +22824,7 @@
 }
 SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){
   sqlite3_int64 iCur = 0, iHwtr = 0;
-  int rc = 0;
+  int rc;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;
 #endif
@@ -22929,7 +22927,7 @@
     case SQLITE_DBSTATUS_CACHE_USED_SHARED:
     case SQLITE_DBSTATUS_CACHE_USED: {
       int totalUsed = 0;
-      int i = 0;
+      int i;
       sqlite3BtreeEnterAll(db);
       for(i=0; i<db->nDb; i++){
         Btree *pBt = db->aDb[i].pBt;
@@ -22954,7 +22952,7 @@
     ** databases.  *pHighwater is set to zero.
     */
     case SQLITE_DBSTATUS_SCHEMA_USED: {
-      int i = 0;                      /* Used to iterate through schemas */
+      int i;                      /* Used to iterate through schemas */
       int nByte = 0;              /* Used to accumulate return value */
 
       sqlite3BtreeEnterAll(db);
@@ -22962,7 +22960,7 @@
       for(i=0; i<db->nDb; i++){
         Schema *pSchema = db->aDb[i].pSchema;
         if( ALWAYS(pSchema!=0) ){
-          HashElem *p = NULL;
+          HashElem *p;
 
           nByte += sqlite3GlobalConfig.m.xRoundup(sizeof(HashElem)) * (
               pSchema->tblHash.count
@@ -22997,7 +22995,7 @@
     ** *pHighwater is set to zero.
     */
     case SQLITE_DBSTATUS_STMT_USED: {
-      struct Vdbe *pVdbe = NULL;         /* Used to iterate through VMs */
+      struct Vdbe *pVdbe;         /* Used to iterate through VMs */
       int nByte = 0;              /* Used to accumulate return value */
 
       db->pnBytesFreed = &nByte;
@@ -23024,7 +23022,7 @@
     case SQLITE_DBSTATUS_CACHE_HIT:
     case SQLITE_DBSTATUS_CACHE_MISS:
     case SQLITE_DBSTATUS_CACHE_WRITE:{
-      int i = 0;
+      int i;
       int nRet = 0;
       assert( SQLITE_DBSTATUS_CACHE_MISS==SQLITE_DBSTATUS_CACHE_HIT+1 );
       assert( SQLITE_DBSTATUS_CACHE_WRITE==SQLITE_DBSTATUS_CACHE_HIT+2 );
@@ -23177,13 +23175,13 @@
   static const u16 aMx[] = { 12, 14, 24, 31, 59, 9999 };
   va_list ap;
   int cnt = 0;
-  char nextC = 0;
+  char nextC;
   va_start(ap, zFormat);
   do{
     char N = zFormat[0] - '0';
     char min = zFormat[1] - '0';
     int val = 0;
-    u16 max = 0;
+    u16 max;
 
     assert( zFormat[2]>='a' && zFormat[2]<='f' );
     max = aMx[zFormat[2] - 'a'];
@@ -23227,8 +23225,8 @@
 */
 static int parseTimezone(const char *zDate, DateTime *p){
   int sgn = 0;
-  int nHr = 0, nMn = 0;
-  int c = 0;
+  int nHr, nMn;
+  int c;
   while( sqlite3Isspace(*zDate) ){ zDate++; }
   p->tz = 0;
   c = *zDate;
@@ -23262,7 +23260,7 @@
 ** Return 1 if there is a parsing error and 0 on success.
 */
 static int parseHhMmSs(const char *zDate, DateTime *p){
-  int h = 0, m = 0, s = 0;
+  int h, m, s;
   double ms = 0.0;
   if( getDigits(zDate, "20c:20e", &h, &m)!=2 ){
     return 1;
@@ -23313,7 +23311,7 @@
 ** Reference:  Meeus page 61
 */
 static void computeJD(DateTime *p){
-  int Y = 0, M = 0, D = 0, A = 0, B = 0, X1 = 0, X2 = 0;
+  int Y, M, D, A, B, X1, X2;
 
   if( p->validJD ) return;
   if( p->validYMD ){
@@ -23363,7 +23361,7 @@
 ** date.
 */
 static int parseYyyyMmDd(const char *zDate, DateTime *p){
-  int Y = 0, M = 0, D = 0, neg = 0;
+  int Y, M, D, neg;
 
   if( zDate[0]=='-' ){
     zDate++;
@@ -23445,7 +23443,7 @@
   const char *zDate,
   DateTime *p
 ){
-  double r = 0;
+  double r;
   if( parseYyyyMmDd(zDate,p)==0 ){
     return 0;
   }else if( parseHhMmSs(zDate, p)==0 ){
@@ -23481,7 +23479,7 @@
 ** Compute the Year, Month, and Day from the julian day number.
 */
 static void computeYMD(DateTime *p){
-  int Z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, X1 = 0;
+  int Z, A, B, C, D, E, X1;
   if( p->validYMD ) return;
   if( !p->validJD ){
     p->Y = 2000;
@@ -23510,7 +23508,7 @@
 ** Compute the Hour, Minute, and Seconds from the julian day number.
 */
 static void computeHMS(DateTime *p){
-  int s = 0;
+  int s;
   if( p->validHMS ) return;
   computeJD(p);
   s = (int)((p->iJD + 43200000) % 86400000);
@@ -23577,9 +23575,9 @@
 ** local time.
 */
 static int osLocaltime(time_t *t, struct tm *pTm){
-  int rc = 0;
+  int rc;
 #if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S
-  struct tm *pX = NULL;
+  struct tm *pX;
 #if SQLITE_THREADSAFE>0
   sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
 #endif
@@ -23630,9 +23628,9 @@
   DateTime *p,                   /* Date at which to calculate offset */
   sqlite3_context *pCtx          /* Write error here if one occurs */
 ){
-  time_t t = 0;
+  time_t t;
   struct tm sLocal;
-  int iYearDiff = 0;
+  int iYearDiff;
 
   /* Initialize the contents of sLocal to avoid a compiler warning. */
   memset(&sLocal, 0, sizeof(sLocal));
@@ -23731,7 +23729,7 @@
   int idx                     /* Parameter index of the modifier */
 ){
   int rc = 1;
-  double r = 0;
+  double r;
   switch(sqlite3UpperToLower[(u8)z[0]] ){
     case 'a': {
       /*
@@ -23810,10 +23808,10 @@
 #ifndef SQLITE_OMIT_LOCALTIME
       else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){
         if( p->tzSet==0 ){
-          i64 iOrigJD = 0;              /* Original localtime */
-          i64 iGuess = 0;               /* Guess at the corresponding utc time */
+          i64 iOrigJD;              /* Original localtime */
+          i64 iGuess;               /* Guess at the corresponding utc time */
           int cnt = 0;              /* Safety to prevent infinite loop */
-          int iErr = 0;                 /* Guess is off by this much */
+          int iErr;                 /* Guess is off by this much */
 
           computeJD(p);
           iGuess = iOrigJD = p->iJD;
@@ -23850,7 +23848,7 @@
       if( sqlite3_strnicmp(z, "weekday ", 8)==0
                && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)>0
                && (n=(int)r)==r && n>=0 && r<7 ){
-        sqlite3_int64 Z = 0;
+        sqlite3_int64 Z;
         computeYMD_HMS(p);
         p->validTZ = 0;
         p->validJD = 0;
@@ -23904,8 +23902,8 @@
     case '7':
     case '8':
     case '9': {
-      double rRounder = 0;
-      int i = 0;
+      double rRounder;
+      int i;
       for(n=1; z[n] && z[n]!=':' && !sqlite3Isspace(z[n]); n++){}
       if( sqlite3AtoF(z, &r, n, SQLITE_UTF8)<=0 ){
         rc = 1;
@@ -23919,7 +23917,7 @@
         */
         const char *z2 = z;
         DateTime tx;
-        sqlite3_int64 day = 0;
+        sqlite3_int64 day;
         if( !sqlite3Isdigit(*z2) ) z2++;
         memset(&tx, 0, sizeof(tx));
         if( parseHhMmSs(z2, &tx) ) break;
@@ -23952,7 +23950,7 @@
         ){
           switch( i ){
             case 4: { /* Special processing to add months */
-              int x = 0;
+              int x;
               assert( strcmp(aXformType[i].zName,"month")==0 );
               computeYMD_HMS(p);
               p->M += (int)r;
@@ -24004,9 +24002,9 @@
   sqlite3_value **argv,
   DateTime *p
 ){
-  int i = 0, n = 0;
-  const unsigned char *z = NULL;
-  int eType = 0;
+  int i, n;
+  const unsigned char *z;
+  int eType;
   memset(p, 0, sizeof(*p));
   if( argc==0 ){
     if( !sqlite3NotPureFunc(context) ) return 1;
@@ -24084,7 +24082,7 @@
 ){
   DateTime x;
   if( isDate(context, argc, argv, &x)==0 ){
-    int Y = 0, s = 0;
+    int Y, s;
     char zBuf[24];
     computeYMD_HMS(&x);
     Y = x.Y;
@@ -24131,7 +24129,7 @@
 ){
   DateTime x;
   if( isDate(context, argc, argv, &x)==0 ){
-    int s = 0;
+    int s;
     char zBuf[16];
     computeHMS(&x);
     zBuf[0] = '0' + (x.h/10)%10;
@@ -24160,7 +24158,7 @@
 ){
   DateTime x;
   if( isDate(context, argc, argv, &x)==0 ){
-    int Y = 0;
+    int Y;
     char zBuf[16];
     computeYMD(&x);
     Y = x.Y;
@@ -24210,9 +24208,9 @@
   sqlite3_value **argv
 ){
   DateTime x;
-  size_t i = 0,j = 0;
-  sqlite3 *db = NULL;
-  const char *zFmt = NULL;
+  size_t i,j;
+  sqlite3 *db;
+  const char *zFmt;
   sqlite3_str sRes;
 
 
@@ -24246,7 +24244,7 @@
       }
       case 'W': /* Fall thru */
       case 'j': {
-        int nDay = 0;             /* Number of days since 1st day of year */
+        int nDay;             /* Number of days since 1st day of year */
         DateTime y = x;
         y.validJD = 0;
         y.M = 1;
@@ -24254,7 +24252,7 @@
         computeJD(&y);
         nDay = (int)((x.iJD-y.iJD+43200000)/86400000);
         if( zFmt[i]=='W' ){
-          int wd = 0;   /* 0=Monday, 1=Tuesday, ... 6=Sunday */
+          int wd;   /* 0=Monday, 1=Tuesday, ... 6=Sunday */
           wd = (int)(((x.iJD+43200000)/86400000)%7);
           sqlite3_str_appendf(&sRes,"%02d",(nDay+7-wd)/7);
         }else{
@@ -24641,7 +24639,7 @@
   int flags,
   int *pFlagsOut
 ){
-  int rc = 0;
+  int rc;
   DO_OS_MALLOC_TEST(0);
   /* 0x87f7f is a mask of SQLITE_OPEN_ flags that are valid to be passed
   ** down into the VFS layer.  Some SQLITE_OPEN_ flags (for example,
@@ -24709,7 +24707,7 @@
   return pVfs->xGetLastError ? pVfs->xGetLastError(pVfs, 0, 0) : 0;
 }
 SQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){
-  int rc = 0;
+  int rc;
   /* IMPLEMENTATION-OF: R-49045-42493 SQLite will use the xCurrentTimeInt64()
   ** method to get the current date and time if that method is available
   ** (if iVersion is 2 or greater and the function pointer is not NULL) and
@@ -24719,7 +24717,7 @@
   if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){
     rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);
   }else{
-    double r = 0;
+    double r;
     rc = pVfs->xCurrentTime(pVfs, &r);
     *pTimeOut = (sqlite3_int64)(r*86400000.0);
   }
@@ -24733,8 +24731,8 @@
   int flags,
   int *pOutFlags
 ){
-  int rc = 0;
-  sqlite3_file *pFile = NULL;
+  int rc;
+  sqlite3_file *pFile;
   pFile = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile);
   if( pFile ){
     rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);
@@ -24783,7 +24781,7 @@
 SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){
   sqlite3_vfs *pVfs = 0;
 #if SQLITE_THREADSAFE
-  sqlite3_mutex *mutex = NULL;
+  sqlite3_mutex *mutex;
 #endif
 #ifndef SQLITE_OMIT_AUTOINIT
   int rc = sqlite3_initialize();
@@ -25159,7 +25157,7 @@
   }
   return p;
 #else
-  sqlite3_int64 *p = NULL;
+  sqlite3_int64 *p;
   assert( nByte>0 );
   testcase( ROUND8(nByte)!=nByte );
   p = SQLITE_MALLOC( nByte+8 );
@@ -25202,7 +25200,7 @@
   assert( pPrior!=0 );
   return (int)SQLITE_MALLOCSIZE(pPrior);
 #else
-  sqlite3_int64 *p = NULL;
+  sqlite3_int64 *p;
   assert( pPrior!=0 );
   p = (sqlite3_int64*)pPrior;
   p--;
@@ -27341,7 +27339,7 @@
     ** sqlite3_initialize() being called. This block copies pointers to
     ** the default implementation into the sqlite3GlobalConfig structure.
     */
-    sqlite3_mutex_methods const *pFrom = NULL;
+    sqlite3_mutex_methods const *pFrom;
     sqlite3_mutex_methods *pTo = &sqlite3GlobalConfig.mutex;
 
     if( sqlite3GlobalConfig.bCoreMutex ){
@@ -27864,7 +27862,7 @@
     SQLITE3_MUTEX_INITIALIZER(12),
     SQLITE3_MUTEX_INITIALIZER(13)
   };
-  sqlite3_mutex *p = NULL;
+  sqlite3_mutex *p;
   switch( iType ){
     case SQLITE_MUTEX_RECURSIVE: {
       p = sqlite3MallocZero( sizeof(*p) );
@@ -27990,7 +27988,7 @@
 #endif
 }
 static int pthreadMutexTry(sqlite3_mutex *p){
-  int rc = 0;
+  int rc;
   assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );
 
 #ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
@@ -28683,9 +28681,9 @@
 ** be disabled nor raised above the hard heap limit.
 */
 SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
-  sqlite3_int64 priorLimit = 0;
-  sqlite3_int64 excess = 0;
-  sqlite3_int64 nUsed = 0;
+  sqlite3_int64 priorLimit;
+  sqlite3_int64 excess;
+  sqlite3_int64 nUsed;
 #ifndef SQLITE_OMIT_AUTOINIT
   int rc = sqlite3_initialize();
   if( rc ) return -1;
@@ -28725,7 +28723,7 @@
 ** limit.
 */
 SQLITE_API sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 n){
-  sqlite3_int64 priorLimit = 0;
+  sqlite3_int64 priorLimit;
 #ifndef SQLITE_OMIT_AUTOINIT
   int rc = sqlite3_initialize();
   if( rc ) return -1;
@@ -28747,7 +28745,7 @@
 ** Initialize the memory allocation subsystem.
 */
 SQLITE_PRIVATE int sqlite3MallocInit(void){
-  int rc = 0;
+  int rc;
   if( sqlite3GlobalConfig.m.xMalloc==0 ){
     sqlite3MemSetDefault();
   }
@@ -28785,7 +28783,7 @@
 ** Return the amount of memory currently checked out.
 */
 SQLITE_API sqlite3_int64 sqlite3_memory_used(void){
-  sqlite3_int64 res = 0, mx = 0;
+  sqlite3_int64 res, mx;
   sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, 0);
   return res;
 }
@@ -28796,7 +28794,7 @@
 ** or since the most recent reset.
 */
 SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){
-  sqlite3_int64 res = 0, mx = 0;
+  sqlite3_int64 res, mx;
   sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, resetFlag);
   return mx;
 }
@@ -28816,8 +28814,8 @@
 ** lock is already held.
 */
 static void mallocWithAlarm(int n, void **pp){
-  void *p = NULL;
-  int nFull = 0;
+  void *p;
+  int nFull;
   assert( sqlite3_mutex_held(mem0.mutex) );
   assert( n>0 );
 
@@ -28865,7 +28863,7 @@
 ** assumes the memory subsystem has already been initialized.
 */
 SQLITE_PRIVATE void *sqlite3Malloc(u64 n){
-  void *p = NULL;
+  void *p;
   if( n==0 || n>=0x7fffff00 ){
     /* A memory allocation of a number of bytes which is near the maximum
     ** signed integer value might cause an integer overflow inside of the
@@ -29040,8 +29038,8 @@
 ** Change the size of an existing memory allocation
 */
 SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){
-  int nOld = 0, nNew = 0, nDiff = 0;
-  void *pNew = NULL;
+  int nOld, nNew, nDiff;
+  void *pNew;
   assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );
   assert( sqlite3MemdebugNoType(pOld, (u8)~MEMTYPE_HEAP) );
   if( pOld==0 ){
@@ -29063,7 +29061,7 @@
   if( nOld==nNew ){
     pNew = pOld;
   }else if( sqlite3GlobalConfig.bMemstat ){
-    sqlite3_int64 nUsed = 0;
+    sqlite3_int64 nUsed;
     sqlite3_mutex_enter(mem0.mutex);
     sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, (int)nBytes);
     nDiff = nNew - nOld;
@@ -29129,7 +29127,7 @@
 ** the mallocFailed flag in the connection pointer.
 */
 SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, u64 n){
-  void *p = NULL;
+  void *p;
   testcase( db==0 );
   p = sqlite3DbMallocRaw(db, n);
   if( p ) memset(p, 0, (size_t)n);
@@ -29141,7 +29139,7 @@
 ** slower case when the allocation cannot be fulfilled using lookaside.
 */
 static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){
-  void *p = NULL;
+  void *p;
   assert( db!=0 );
   p = sqlite3Malloc(n);
   if( !p ) sqlite3OomFault(db);
@@ -29173,7 +29171,7 @@
 ** not a NULL pointer.
 */
 SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){
-  void *p = NULL;
+  void *p;
   if( db ) return sqlite3DbMallocRawNN(db, n);
   p = sqlite3Malloc(n);
   sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
@@ -29181,7 +29179,7 @@
 }
 SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){
 #ifndef SQLITE_OMIT_LOOKASIDE
-  LookasideSlot *pBuf = NULL;
+  LookasideSlot *pBuf;
   assert( db!=0 );
   assert( sqlite3_mutex_held(db->mutex) );
   assert( db->pnBytesFreed==0 );
@@ -29282,7 +29280,7 @@
 ** and set the mallocFailed flag in the database connection.
 */
 SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){
-  void *pNew = NULL;
+  void *pNew;
   pNew = sqlite3DbRealloc(db, p, n);
   if( !pNew ){
     sqlite3DbFree(db, p);
@@ -29298,8 +29296,8 @@
 ** ThreadData structure.
 */
 SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z){
-  char *zNew = NULL;
-  size_t n = 0;
+  char *zNew;
+  size_t n;
   if( z==0 ){
     return 0;
   }
@@ -29311,7 +29309,7 @@
   return zNew;
 }
 SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){
-  char *zNew = NULL;
+  char *zNew;
   assert( db!=0 );
   assert( z!=0 || n==0 );
   assert( (n&0x7fffffff)==n );
@@ -29329,7 +29327,7 @@
 ** sqlite3DbMalloc().  Omit leading and trailing whitespace.
 */
 SQLITE_PRIVATE char *sqlite3DbSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){
-  int n = 0;
+  int n;
   while( sqlite3Isspace(zStart[0]) ) zStart++;
   n = (int)(zEnd - zStart);
   while( ALWAYS(n>0) && sqlite3Isspace(zStart[n-1]) ) n--;
@@ -29560,7 +29558,7 @@
 ** always returned.
 */
 static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){
-  int digit = 0;
+  int digit;
   LONGDOUBLE_TYPE d;
   if( (*cnt)<=0 ) return '0';
   (*cnt)--;
@@ -29608,7 +29606,7 @@
 ** field of the printf() function.
 */
 static char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){
-  char *z = NULL;
+  char *z;
   if( pAccum->accError ) return 0;
   if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){
     sqlite3StrAccumSetError(pAccum, SQLITE_TOOBIG);
@@ -29645,35 +29643,35 @@
   const char *fmt,           /* Format string */
   va_list ap                 /* arguments */
 ){
-  int c = 0;                     /* Next character in the format string */
-  char *bufpt = NULL;               /* Pointer to the conversion buffer */
-  int precision = 0;             /* Precision of the current field */
-  int length = 0;                /* Length of the field */
-  int idx = 0;                   /* A general purpose loop counter */
-  int width = 0;                 /* Width of the current field */
-  etByte flag_leftjustify = 0;   /* True if "-" flag is present */
-  etByte flag_prefix = 0;        /* '+' or ' ' or 0 for prefix */
-  etByte flag_alternateform = 0; /* True if "#" flag is present */
-  etByte flag_altform2 = 0;      /* True if "!" flag is present */
-  etByte flag_zeropad = 0;       /* True if field width constant starts with zero */
-  etByte flag_long = 0;          /* 1 for the "l" flag, 2 for "ll", 0 by default */
-  etByte done = 0;               /* Loop termination flag */
-  etByte cThousand = 0;          /* Thousands separator for %d and %u */
+  int c;                     /* Next character in the format string */
+  char *bufpt;               /* Pointer to the conversion buffer */
+  int precision;             /* Precision of the current field */
+  int length;                /* Length of the field */
+  int idx;                   /* A general purpose loop counter */
+  int width;                 /* Width of the current field */
+  etByte flag_leftjustify;   /* True if "-" flag is present */
+  etByte flag_prefix;        /* '+' or ' ' or 0 for prefix */
+  etByte flag_alternateform; /* True if "#" flag is present */
+  etByte flag_altform2;      /* True if "!" flag is present */
+  etByte flag_zeropad;       /* True if field width constant starts with zero */
+  etByte flag_long;          /* 1 for the "l" flag, 2 for "ll", 0 by default */
+  etByte done;               /* Loop termination flag */
+  etByte cThousand;          /* Thousands separator for %d and %u */
   etByte xtype = etINVALID;  /* Conversion paradigm */
-  u8 bArgList = 0;               /* True for SQLITE_PRINTF_SQLFUNC */
-  char prefix = 0;               /* Prefix character.  "+" or "-" or " " or '\0'. */
-  sqlite_uint64 longvalue = 0;   /* Value for integer types */
+  u8 bArgList;               /* True for SQLITE_PRINTF_SQLFUNC */
+  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */
+  sqlite_uint64 longvalue;   /* Value for integer types */
   LONGDOUBLE_TYPE realvalue; /* Value for real types */
-  const et_info *infop = NULL;      /* Pointer to the appropriate info structure */
-  char *zOut = NULL;                /* Rendering buffer */
-  int nOut = 0;                  /* Size of the rendering buffer */
+  const et_info *infop;      /* Pointer to the appropriate info structure */
+  char *zOut;                /* Rendering buffer */
+  int nOut;                  /* Size of the rendering buffer */
   char *zExtra = 0;          /* Malloced memory used by some conversion */
 #ifndef SQLITE_OMIT_FLOATING_POINT
-  int  exp = 0, e2 = 0;              /* exponent of real numbers */
-  int nsd = 0;                   /* Number of significant digits returned */
-  double rounder = 0;            /* Used for rounding floating point values */
-  etByte flag_dp = 0;            /* True if decimal point should be shown */
-  etByte flag_rtz = 0;           /* True if trailing zeros should be removed */
+  int  exp, e2;              /* exponent of real numbers */
+  int nsd;                   /* Number of significant digits returned */
+  double rounder;            /* Used for rounding floating point values */
+  etByte flag_dp;            /* True if decimal point should be shown */
+  etByte flag_rtz;           /* True if trailing zeros should be removed */
 #endif
   PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */
   char buf[etBUFSIZE];       /* Conversion buffer */
@@ -29850,7 +29848,7 @@
         /* no break */ deliberate_fall_through
       case etDECIMAL:
         if( infop->flags & FLAG_SIGNED ){
-          i64 v = 0;
+          i64 v;
           if( bArgList ){
             v = getIntArg(pArgList);
           }else if( flag_long ){
@@ -29894,7 +29892,7 @@
           nOut = etBUFSIZE;
           zOut = buf;
         }else{
-          u64 n = 0;
+          u64 n;
           n = (u64)precision + 10;
           if( cThousand ) n += precision/3;
           zOut = zExtra = printfTempBuf(pAccum, n);
@@ -29940,8 +29938,8 @@
         }
         if( prefix ) *(--bufpt) = prefix;               /* Add sign */
         if( flag_alternateform && infop->prefix ){      /* Add "0" or "0x" */
-          const char *pre = NULL;
-          char x = 0;
+          const char *pre;
+          char x;
           pre = &aPrefix[infop->prefix];
           for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;
         }
@@ -29977,8 +29975,8 @@
         while( idx>=10 ){ rounder *= 1.0e-10; idx -= 10; }
         if( xtype==etFLOAT ){
           double rx = (double)realvalue;
-          sqlite3_uint64 u = 0;
-          int ex = 0;
+          sqlite3_uint64 u;
+          int ex;
           memcpy(&u, &rx, sizeof(u));
           ex = -1023 + (int)((u>>52)&0x7ff);
           if( precision+(ex/3) < 15 ) rounder += realvalue*3e-16;
@@ -30033,7 +30031,7 @@
           e2 = exp;
         }
         {
-          i64 szBufNeeded = 0;           /* Size of a temporary buffer needed */
+          i64 szBufNeeded;           /* Size of a temporary buffer needed */
           szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;
           if( szBufNeeded > etBUFSIZE ){
             bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);
@@ -30107,7 +30105,7 @@
         /* Special case:  Add leading zeros if the flag_zeropad flag is
         ** set and we are not left justified */
         if( flag_zeropad && !flag_leftjustify && length < width){
-          int i = 0;
+          int i;
           int nPad = width - length;
           for(i=width; i>=nPad; i--){
             bufpt[i] = bufpt[i-nPad];
@@ -30233,11 +30231,11 @@
       case etSQLESCAPE:           /* %q: Escape ' characters */
       case etSQLESCAPE2:          /* %Q: Escape ' and enclose in '...' */
       case etSQLESCAPE3: {        /* %w: Escape " characters */
-        int i = 0, j = 0, k = 0, n = 0, isnull = 0;
-        int needQuote = 0;
-        char ch = 0;
+        int i, j, k, n, isnull;
+        int needQuote;
+        char ch;
         char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */
-        char *escarg = NULL;
+        char *escarg;
 
         if( bArgList ){
           escarg = getTextArg(pArgList);
@@ -30300,7 +30298,7 @@
         break;
       }
       case etSRCITEM: {
-        SrcItem *pItem = NULL;
+        SrcItem *pItem;
         if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;
         pItem = va_arg(ap, SrcItem*);
         assert( bArgList==0 );
@@ -30357,9 +30355,9 @@
 ** z and set the error byte offset in db.
 */
 SQLITE_PRIVATE void sqlite3RecordErrorByteOffset(sqlite3 *db, const char *z){
-  const Parse *pParse = NULL;
-  const char *zText = NULL;
-  const char *zEnd = NULL;
+  const Parse *pParse;
+  const char *zText;
+  const char *zEnd;
   assert( z!=0 );
   if( NEVER(db==0) ) return;
   if( db->errByteOffset!=(-2) ) return;
@@ -30393,7 +30391,7 @@
 ** after the attempted enlargement.  The value returned might be zero.
 */
 SQLITE_PRIVATE int sqlite3StrAccumEnlarge(StrAccum *p, int N){
-  char *zNew = NULL;
+  char *zNew;
   assert( p->nChar+(i64)N >= p->nAlloc ); /* Only called if really needed */
   if( p->accError ){
     testcase(p->accError==SQLITE_TOOBIG);
@@ -30498,7 +30496,7 @@
 ** pointer if any kind of error was encountered.
 */
 static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){
-  char *zText = NULL;
+  char *zText;
   assert( p->mxAlloc>0 && !isMalloced(p) );
   zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );
   if( zText ){
@@ -30549,7 +30547,7 @@
 /* Finalize a string created using sqlite3_str_new().
 */
 SQLITE_API char *sqlite3_str_finish(sqlite3_str *p){
-  char *z = NULL;
+  char *z;
   if( p!=0 && p!=&sqlite3OomStr ){
     z = sqlite3StrAccumFinish(p);
     sqlite3_free(p);
@@ -30630,7 +30628,7 @@
 ** %-conversion extensions.
 */
 SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){
-  char *z = NULL;
+  char *z;
   char zBase[SQLITE_PRINT_BUF_SIZE];
   StrAccum acc;
   assert( db!=0 );
@@ -30651,7 +30649,7 @@
 */
 SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){
   va_list ap;
-  char *z = NULL;
+  char *z;
   va_start(ap, zFormat);
   z = sqlite3VMPrintf(db, zFormat, ap);
   va_end(ap);
@@ -30663,7 +30661,7 @@
 ** %-conversion extensions.
 */
 SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){
-  char *z = NULL;
+  char *z;
   char zBase[SQLITE_PRINT_BUF_SIZE];
   StrAccum acc;
 
@@ -30688,7 +30686,7 @@
 */
 SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){
   va_list ap;
-  char *z = NULL;
+  char *z;
 #ifndef SQLITE_OMIT_AUTOINIT
   if( sqlite3_initialize() ) return 0;
 #endif
@@ -30727,7 +30725,7 @@
   return zBuf;
 }
 SQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
-  char *z = NULL;
+  char *z;
   va_list ap;
   va_start(ap,zFormat);
   z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);
@@ -31665,7 +31663,7 @@
 ** Return N random bytes.
 */
 SQLITE_API void sqlite3_randomness(int N, void *pBuf){
-  unsigned char t = 0;
+  unsigned char t;
   unsigned char *zBuf = pBuf;
 
   /* The "wsdPrng" macro will resolve to the pseudo-random number generator
@@ -31682,7 +31680,7 @@
 #endif
 
 #if SQLITE_THREADSAFE
-  sqlite3_mutex *mutex = NULL;
+  sqlite3_mutex *mutex;
 #endif
 
 #ifndef SQLITE_OMIT_AUTOINIT
@@ -31711,7 +31709,7 @@
   */
   if( !wsdPrng.isInit ){
     sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
-    int i = 0;
+    int i;
     char k[256];
     wsdPrng.j = 0;
     wsdPrng.i = 0;
@@ -31829,8 +31827,8 @@
   void *(*xTask)(void*),    /* Routine to run in a separate thread */
   void *pIn                 /* Argument passed into xTask() */
 ){
-  SQLiteThread *p = NULL;
-  int rc = 0;
+  SQLiteThread *p;
+  int rc;
 
   assert( ppThread!=0 );
   assert( xTask!=0 );
@@ -31862,7 +31860,7 @@
 
 /* Get the results of the thread */
 SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){
-  int rc = 0;
+  int rc;
 
   assert( ppOut!=0 );
   if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;
@@ -32199,7 +32197,7 @@
 SQLITE_PRIVATE u32 sqlite3Utf8Read(
   const unsigned char **pz    /* Pointer to string from which to read char */
 ){
-  unsigned int c = 0;
+  unsigned int c;
 
   /* Same as READ_UTF8() above but without the zTerm parameter.
   ** For this routine, we assume the UTF8 string is always zero-terminated.
@@ -32233,12 +32231,12 @@
 ** encoding, or if *pMem does not contain a string value.
 */
 SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){
-  sqlite3_int64 len = 0;          /* Maximum length of output string in bytes */
-  unsigned char *zOut = NULL;        /* Output buffer */
-  unsigned char *zIn = NULL;         /* Input iterator */
-  unsigned char *zTerm = NULL;       /* End of input */
-  unsigned char *z = NULL;           /* Output iterator */
-  unsigned int c = 0;
+  sqlite3_int64 len;          /* Maximum length of output string in bytes */
+  unsigned char *zOut;        /* Output buffer */
+  unsigned char *zIn;         /* Input iterator */
+  unsigned char *zTerm;       /* End of input */
+  unsigned char *z;           /* Output iterator */
+  unsigned int c;
 
   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
   assert( pMem->flags&MEM_Str );
@@ -32261,8 +32259,8 @@
   ** differently from the others.
   */
   if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){
-    u8 temp = 0;
-    int rc = 0;
+    u8 temp;
+    int rc;
     rc = sqlite3VdbeMemMakeWriteable(pMem);
     if( rc!=SQLITE_OK ){
       assert( rc==SQLITE_NOMEM );
@@ -32468,7 +32466,7 @@
 SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte){
   int r = 0;
   const u8 *z = (const u8*)zIn;
-  const u8 *zTerm = NULL;
+  const u8 *zTerm;
   if( nByte>=0 ){
     zTerm = &z[nByte];
   }else{
@@ -32541,7 +32539,7 @@
 ** in pZ.  nChar must be non-negative.
 */
 SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){
-  int c = 0;
+  int c;
   unsigned char const *z = zIn;
   int n = 0;
 
@@ -32646,9 +32644,9 @@
 ** Otherwise, we have our own implementation that works on most systems.
 */
 SQLITE_PRIVATE int sqlite3IsNaN(double x){
-  int rc = 0;   /* The value return */
+  int rc;   /* The value return */
 #if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN
-  u64 y = 0;
+  u64 y;
   memcpy(&y,&x,sizeof(y));
   rc = IsNaN(y);
 #else
@@ -32757,7 +32755,7 @@
   if( zFormat==0 ){
     sqlite3Error(db, err_code);
   }else if( db->pErr || (db->pErr = sqlite3ValueNew(db))!=0 ){
-    char *z = NULL;
+    char *z;
     va_list ap;
     va_start(ap, zFormat);
     z = sqlite3VMPrintf(db, zFormat, ap);
@@ -32777,7 +32775,7 @@
 ** during statement execution (sqlite3_step() etc.).
 */
 SQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){
-  char *zMsg = NULL;
+  char *zMsg;
   va_list ap;
   sqlite3 *db = pParse->db;
   assert( db!=0 );
@@ -32808,7 +32806,7 @@
 ** encountered some other kind of error.
 */
 SQLITE_PRIVATE int sqlite3ErrorToParser(sqlite3 *db, int errCode){
-  Parse *pParse = NULL;
+  Parse *pParse;
   if( db==0 || (pParse = db->pParse)==0 ) return errCode;
   pParse->rc = errCode;
   pParse->nErr++;
@@ -32833,8 +32831,8 @@
 ** "a-b-c".
 */
 SQLITE_PRIVATE void sqlite3Dequote(char *z){
-  char quote = 0;
-  int i = 0, j = 0;
+  char quote;
+  int i, j;
   if( z==0 ) return;
   quote = z[0];
   if( !sqlite3Isquote(quote) ) return;
@@ -32873,7 +32871,7 @@
 ** is always a no-op.
 */
 SQLITE_PRIVATE void sqlite3DequoteToken(Token *p){
-  unsigned int i = 0;
+  unsigned int i;
   if( p->n<2 ) return;
   if( !sqlite3Isquote(p->z[0]) ) return;
   for(i=1; i<p->n-1; i++){
@@ -32913,8 +32911,8 @@
   return sqlite3StrICmp(zLeft, zRight);
 }
 SQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){
-  unsigned char *a = NULL, *b = NULL;
-  int c = 0, x = 0;
+  unsigned char *a, *b;
+  int c, x;
   a = (unsigned char *)zLeft;
   b = (unsigned char *)zRight;
   for(;;){
@@ -32932,7 +32930,7 @@
   return c;
 }
 SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
-  register unsigned char *a = NULL, *b = NULL;
+  register unsigned char *a, *b;
   if( zLeft==0 ){
     return zRight ? -1 : 0;
   }else if( zRight==0 ){
@@ -33030,8 +33028,8 @@
 #endif
 SQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){
 #ifndef SQLITE_OMIT_FLOATING_POINT
-  int incr = 0;
-  const char *zEnd = NULL;
+  int incr;
+  const char *zEnd;
   /* sign * significand * (10 ^ (esign * exponent)) */
   int sign = 1;    /* sign of significand */
   i64 s = 0;       /* significand */
@@ -33039,7 +33037,7 @@
   int esign = 1;   /* sign of exponent */
   int e = 0;       /* exponent */
   int eValid = 1;  /* True exponent is either not used or is well-formed */
-  double result = 0;
+  double result;
   int nDigit = 0;  /* Number of digits processed */
   int eType = 1;   /* 1: pure integer,  2+: fractional  -1 or less: bad UTF16 */
 
@@ -33051,7 +33049,7 @@
     incr = 1;
     zEnd = z + length;
   }else{
-    int i = 0;
+    int i;
     incr = 2;
     length &= ~1;
     assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );
@@ -33228,8 +33226,8 @@
 ** The caller must ensure that zOut[] is at least 21 bytes in size.
 */
 SQLITE_PRIVATE void sqlite3Int64ToText(i64 v, char *zOut){
-  int i = 0;
-  u64 x = 0;
+  int i;
+  u64 x;
   char zTemp[22];
   if( v<0 ){
     x = (v==SMALLEST_INT64) ? ((u64)1)<<63 : (u64)-v;
@@ -33262,7 +33260,7 @@
 */
 static int compare2pow63(const char *zNum, int incr){
   int c = 0;
-  int i = 0;
+  int i;
                     /* 012345678901234567 */
   const char *pow63 = "922337203685477580";
   for(i=0; c==0 && i<18; i++){
@@ -33294,14 +33292,14 @@
 ** given by enc.
 */
 SQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){
-  int incr = 0;
+  int incr;
   u64 u = 0;
   int neg = 0; /* assume positive */
-  int i = 0;
+  int i;
   int c = 0;
   int nonNum = 0;  /* True if input contains UTF16 with high byte non-zero */
-  int rc = 0;          /* Baseline return code */
-  const char *zStart = NULL;
+  int rc;          /* Baseline return code */
+  const char *zStart;
   const char *zEnd = zNum + length;
   assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );
   if( enc==SQLITE_UTF8 ){
@@ -33402,7 +33400,7 @@
    && (z[1]=='x' || z[1]=='X')
   ){
     u64 u = 0;
-    int i = 0, k = 0;
+    int i, k;
     for(i=2; z[i]=='0'; i++){}
     for(k=i; sqlite3Isxdigit(z[k]); k++){
       u = u*16 + sqlite3HexToInt(z[k]);
@@ -33428,7 +33426,7 @@
 */
 SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){
   sqlite_int64 v = 0;
-  int i = 0, c = 0;
+  int i, c;
   int neg = 0;
   if( zNum[0]=='-' ){
     neg = 1;
@@ -33499,7 +33497,7 @@
 */
 SQLITE_PRIVATE int sqlite3GetUInt32(const char *z, u32 *pI){
   u64 v = 0;
-  int i = 0;
+  int i;
   for(i=0; sqlite3Isdigit(z[i]); i++){
     v = v*10 + z[i] - '0';
     if( v>4294967296LL ){ *pI = 0; return 0; }
@@ -33539,7 +33537,7 @@
 ** 8 bits and is the last byte.
 */
 static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){
-  int i = 0, j = 0, n = 0;
+  int i, j, n;
   u8 buf[10];
   if( v & (((u64)0xff000000)<<32) ){
     p[8] = (u8)v;
@@ -33593,7 +33591,7 @@
 ** Return the number of bytes read.  The value is stored in *v.
 */
 SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
-  u32 a = 0,b = 0,s = 0;
+  u32 a,b,s;
 
   if( ((signed char*)p)[0]>=0 ){
     *v = *p;
@@ -33754,7 +33752,7 @@
 ** this function assumes the single-byte case has already been handled.
 */
 SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
-  u32 a = 0,b = 0;
+  u32 a,b;
 
   /* The 1-byte case.  Overwhelmingly the most common.  Handled inline
   ** by the getVarin32() macro */
@@ -33808,8 +33806,8 @@
   */
 #if 1
   {
-    u64 v64 = 0;
-    u8 n = 0;
+    u64 v64;
+    u8 n;
 
     n = sqlite3GetVarint(p-2, &v64);
     assert( n>3 && n<=9 );
@@ -33876,7 +33874,7 @@
 ** 64-bit integer.
 */
 SQLITE_PRIVATE int sqlite3VarintLen(u64 v){
-  int i = 0;
+  int i;
   for(i=1; (v >>= 7)!=0; i++){ assert( i<10 ); }
   return i;
 }
@@ -33946,8 +33944,8 @@
 ** the calling routine.
 */
 SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){
-  char *zBlob = NULL;
-  int i = 0;
+  char *zBlob;
+  int i;
 
   zBlob = (char *)sqlite3DbMallocRawNN(db, n/2 + 1);
   n--;
@@ -33988,7 +33986,7 @@
 ** used as an argument to sqlite3_errmsg() or sqlite3_close().
 */
 SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3 *db){
-  u8 eOpenState = 0;
+  u8 eOpenState;
   if( db==0 ){
     logBadConnection("NULL");
     return 0;
@@ -34005,7 +34003,7 @@
   }
 }
 SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3 *db){
-  u8 eOpenState = 0;
+  u8 eOpenState;
   eOpenState = db->eOpenState;
   if( eOpenState!=SQLITE_STATE_SICK &&
       eOpenState!=SQLITE_STATE_OPEN &&
@@ -34179,8 +34177,8 @@
 ** In other words, compute an approximation for 10*log2(x).
 */
 SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double x){
-  u64 a = 0;
-  LogEst e = 0;
+  u64 a;
+  LogEst e;
   assert( sizeof(x)==8 && sizeof(a)==8 );
   if( x<=1 ) return 0;
   if( x<=2000000000 ) return sqlite3LogEst((u64)x);
@@ -34193,7 +34191,7 @@
 ** Convert a LogEst into an integer.
 */
 SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst x){
-  u64 n = 0;
+  u64 n;
   n = x%10;
   x /= 10;
   if( n>=5 ) n -= 2;
@@ -34245,9 +34243,9 @@
   int nName,             /* Bytes of text in zName */
   int iVal               /* Value to associate with zName */
 ){
-  int nInt = 0;              /* number of sizeof(int) objects needed for zName */
-  char *z = NULL;               /* Pointer to where zName will be stored */
-  int i = 0;                 /* Index in pIn[] where zName is stored */
+  int nInt;              /* number of sizeof(int) objects needed for zName */
+  char *z;               /* Pointer to where zName will be stored */
+  int i;                 /* Index in pIn[] where zName is stored */
 
   nInt = nName/4 + 3;
   assert( pIn==0 || pIn[0]>=3 );  /* Verify ok to add new elements */
@@ -34277,7 +34275,7 @@
 ** the list
 */
 SQLITE_PRIVATE const char *sqlite3VListNumToName(VList *pIn, int iVal){
-  int i = 0, mx = 0;
+  int i, mx;
   if( pIn==0 ) return 0;
   mx = pIn[1];
   i = 2;
@@ -34293,7 +34291,7 @@
 ** or return 0 if there is no such variable.
 */
 SQLITE_PRIVATE int sqlite3VListNameToNum(VList *pIn, const char *zName, int nName){
-  int i = 0, mx = 0;
+  int i, mx;
   if( pIn==0 ) return 0;
   mx = pIn[1];
   i = 2;
@@ -34342,7 +34340,7 @@
 ** to the empty state.
 */
 SQLITE_PRIVATE void sqlite3HashClear(Hash *pH){
-  HashElem *elem = NULL;         /* For looping over all elements of the table */
+  HashElem *elem;         /* For looping over all elements of the table */
 
   assert( pH!=0 );
   elem = pH->first;
@@ -34363,7 +34361,7 @@
 */
 static unsigned int strHash(const char *z){
   unsigned int h = 0;
-  unsigned char c = 0;
+  unsigned char c;
   while( (c = (unsigned char)*z++)!=0 ){     /*OPTIMIZATION-IF-TRUE*/
     /* Knuth multiplicative hashing.  (Sorting & Searching, p. 510).
     ** 0x9e3779b1 is 2654435761 which is the closest prime number to
@@ -34383,7 +34381,7 @@
   struct _ht *pEntry,    /* The entry into which pNew is inserted */
   HashElem *pNew         /* The element to be inserted */
 ){
-  HashElem *pHead = NULL;       /* First element already in pEntry */
+  HashElem *pHead;       /* First element already in pEntry */
   if( pEntry ){
     pHead = pEntry->count ? pEntry->chain : 0;
     pEntry->count++;
@@ -34413,8 +34411,8 @@
 ** Return TRUE if the resize occurs and false if not.
 */
 static int rehash(Hash *pH, unsigned int new_size){
-  struct _ht *new_ht = NULL;            /* The new hash table */
-  HashElem *elem = NULL, *next_elem = NULL;    /* For looping over existing elements */
+  struct _ht *new_ht;            /* The new hash table */
+  HashElem *elem, *next_elem;    /* For looping over existing elements */
 
 #if SQLITE_MALLOC_SOFT_LIMIT>0
   if( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){
@@ -34458,13 +34456,13 @@
   const char *pKey,   /* The key we are searching for */
   unsigned int *pHash /* Write the hash value here */
 ){
-  HashElem *elem = NULL;                /* Used to loop thru the element list */
-  unsigned int count = 0;            /* Number of elements left to test */
-  unsigned int h = 0;                /* The computed hash */
+  HashElem *elem;                /* Used to loop thru the element list */
+  unsigned int count;            /* Number of elements left to test */
+  unsigned int h;                /* The computed hash */
   static HashElem nullElement = { 0, 0, 0, 0 };
 
   if( pH->ht ){   /*OPTIMIZATION-IF-TRUE*/
-    struct _ht *pEntry = NULL;
+    struct _ht *pEntry;
     h = strHash(pKey) % pH->htsize;
     pEntry = &pH->ht[h];
     elem = pEntry->chain;
@@ -34493,7 +34491,7 @@
   HashElem* elem,   /* The element to be removed from the pH */
   unsigned int h    /* Hash value for the element */
 ){
-  struct _ht *pEntry = NULL;
+  struct _ht *pEntry;
   if( elem->prev ){
     elem->prev->next = elem->next;
   }else{
@@ -34544,9 +34542,9 @@
 ** element corresponding to "key" is removed from the hash table.
 */
 SQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){
-  unsigned int h = 0;       /* the hash of the key modulo hash table size */
-  HashElem *elem = NULL;       /* Used to loop thru the element list */
-  HashElem *new_elem = NULL;   /* New element added to the pH */
+  unsigned int h;       /* the hash of the key modulo hash table size */
+  HashElem *elem;       /* Used to loop thru the element list */
+  HashElem *new_elem;   /* New element added to the pH */
 
   assert( pH!=0 );
   assert( pKey!=0 );
@@ -35359,7 +35357,7 @@
   const char *zName,            /* Name of system call to override */
   sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */
 ){
-  unsigned int i = 0;
+  unsigned int i;
   int rc = SQLITE_NOTFOUND;
 
   UNUSED_PARAMETER(pNotUsed);
@@ -35401,7 +35399,7 @@
   sqlite3_vfs *pNotUsed,
   const char *zName
 ){
-  unsigned int i = 0;
+  unsigned int i;
 
   UNUSED_PARAMETER(pNotUsed);
   for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
@@ -35458,7 +35456,7 @@
 ** recover the hot journals.
 */
 static int robust_open(const char *z, int f, mode_t m){
-  int fd = 0;
+  int fd;
   mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS;
   while(1){
 #if defined(O_CLOEXEC)
@@ -35621,7 +35619,7 @@
 ** could lead to a corrupt database.
 */
 static int robust_ftruncate(int h, sqlite3_int64 sz){
-  int rc = 0;
+  int rc;
 #ifdef __ANDROID__
   /* On Android, ftruncate() always uses 32-bit offsets, even if
   ** _FILE_OFFSET_BITS=64 is defined. This means it is unsafe to attempt to
@@ -36010,7 +36008,7 @@
   const char *zPath,              /* File path associated with error */
   int iLine                       /* Source line number where error occurred */
 ){
-  char *zErr = NULL;                     /* Message from strerror() or equivalent */
+  char *zErr;                     /* Message from strerror() or equivalent */
   int iErrno = errno;             /* Saved syscall error number */
 
   /* If this is not a threadsafe build (SQLITE_THREADSAFE==0), then use
@@ -36089,8 +36087,8 @@
 */
 static void closePendingFds(unixFile *pFile){
   unixInodeInfo *pInode = pFile->pInode;
-  UnixUnusedFd *p = NULL;
-  UnixUnusedFd *pNext = NULL;
+  UnixUnusedFd *p;
+  UnixUnusedFd *pNext;
   assert( unixFileMutexHeld(pFile) );
   for(p=pInode->pUnused; p; p=pNext){
     pNext = p->pNext;
@@ -36147,8 +36145,8 @@
   unixFile *pFile,               /* Unix file with file desc used in the key */
   unixInodeInfo **ppInode        /* Return the unixInodeInfo object here */
 ){
-  int rc = 0;                        /* System call return code */
-  int fd = 0;                        /* The file descriptor for pFile */
+  int rc;                        /* System call return code */
+  int fd;                        /* The file descriptor for pFile */
   struct unixFileId fileId;      /* Lookup key for the unixInodeInfo */
   struct stat statbuf;           /* Low-level file information */
   unixInodeInfo *pInode = 0;     /* Candidate unixInodeInfo object */
@@ -36258,7 +36256,7 @@
 */
 static void verifyDbFile(unixFile *pFile){
   struct stat buf;
-  int rc = 0;
+  int rc;
 
   /* These verifications occurs for the main database only */
   if( pFile->ctrlFlags & UNIXFILE_NOLOCK ) return;
@@ -36391,7 +36389,7 @@
 ** to fcntl() fails. In this case, errno is set appropriately (by fcntl()).
 */
 static int unixFileLock(unixFile *pFile, struct flock *pLock){
-  int rc = 0;
+  int rc;
   unixInodeInfo *pInode = pFile->pInode;
   assert( pInode!=0 );
   assert( sqlite3_mutex_held(pInode->pLockMutex) );
@@ -36482,7 +36480,7 @@
   */
   int rc = SQLITE_OK;
   unixFile *pFile = (unixFile*)id;
-  unixInodeInfo *pInode = NULL;
+  unixInodeInfo *pInode;
   struct flock lock;
   int tErrno = 0;
 
@@ -36692,7 +36690,7 @@
 */
 static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
   unixFile *pFile = (unixFile*)id;
-  unixInodeInfo *pInode = NULL;
+  unixInodeInfo *pInode;
   struct flock lock;
   int rc = SQLITE_OK;
 
@@ -37115,7 +37113,7 @@
 static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
   unixFile *pFile = (unixFile*)id;
   char *zLockFile = (char *)pFile->lockingContext;
-  int rc = 0;
+  int rc;
 
   assert( pFile );
   OSTRACE(("UNLOCK  %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,
@@ -38070,10 +38068,10 @@
 ** is set before returning.
 */
 static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
-  int got = 0;
+  int got;
   int prior = 0;
 #if (!defined(USE_PREAD) && !defined(USE_PREAD64))
-  i64 newOffset = 0;
+  i64 newOffset;
 #endif
   TIMER_START;
   assert( cnt==(cnt&0x1ffff) );
@@ -38125,7 +38123,7 @@
   sqlite3_int64 offset
 ){
   unixFile *pFile = (unixFile *)id;
-  int got = 0;
+  int got;
   assert( id );
   assert( offset>=0 );
   assert( amt>0 );
@@ -38385,7 +38383,7 @@
 ** the value of the dataOnly flag.
 */
 static int full_fsync(int fd, int fullSync, int dataOnly){
-  int rc = 0;
+  int rc;
 
   /* The following "ifdef/elif/else/" block has the same structure as
   ** the one below. It is replicated here solely to avoid cluttering
@@ -38481,7 +38479,7 @@
 ** the file descriptor *pFd using close().
 */
 static int openDirectory(const char *zFilename, int *pFd){
-  int ii = 0;
+  int ii;
   int fd = -1;
   char zDirname[MAX_PATHNAME+1];
 
@@ -38518,7 +38516,7 @@
 ** will not roll back - possibly leading to database corruption.
 */
 static int unixSync(sqlite3_file *id, int flags){
-  int rc = 0;
+  int rc;
   unixFile *pFile = (unixFile*)id;
 
   int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);
@@ -38548,7 +38546,7 @@
   ** are unable to fsync a directory, so ignore errors on the fsync.
   */
   if( pFile->ctrlFlags & UNIXFILE_DIRSYNC ){
-    int dirfd = 0;
+    int dirfd;
     OSTRACE(("DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n", pFile->zPath,
             HAVE_FULLFSYNC, isFullsync));
     rc = osOpenDirectory(pFile->zPath, &dirfd);
@@ -38569,7 +38567,7 @@
 */
 static int unixTruncate(sqlite3_file *id, i64 nByte){
   unixFile *pFile = (unixFile *)id;
-  int rc = 0;
+  int rc;
   assert( pFile );
   SimulateIOError( return SQLITE_IOERR_TRUNCATE );
 
@@ -38618,7 +38616,7 @@
 ** Determine the current size of a file in bytes
 */
 static int unixFileSize(sqlite3_file *id, i64 *pSize){
-  int rc = 0;
+  int rc;
   struct stat buf;
   assert( id );
   rc = osFstat(((unixFile*)id)->h, &buf);
@@ -38657,7 +38655,7 @@
 */
 static int fcntlSizeHint(unixFile *pFile, i64 nByte){
   if( pFile->szChunk>0 ){
-    i64 nSize = 0;                    /* Required file size */
+    i64 nSize;                    /* Required file size */
     struct stat buf;              /* Used to hold return values of fstat() */
 
     if( osFstat(pFile->h, &buf) ){
@@ -38686,7 +38684,7 @@
       */
       int nBlk = buf.st_blksize;  /* File-system block size */
       int nWrite = 0;             /* Number of bytes written by seekAndWrite */
-      i64 iWrite = 0;                 /* Next offset to write to */
+      i64 iWrite;                 /* Next offset to write to */
 
       iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;
       assert( iWrite>=buf.st_size );
@@ -38702,7 +38700,7 @@
 
 #if SQLITE_MAX_MMAP_SIZE>0
   if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){
-    int rc = 0;
+    int rc;
     if( pFile->szChunk<=0 ){
       if( robust_ftruncate(pFile->h, nByte) ){
         storeLastErrno(pFile, errno);
@@ -38774,7 +38772,7 @@
       return SQLITE_OK;
     }
     case SQLITE_FCNTL_SIZE_HINT: {
-      int rc = 0;
+      int rc;
       SimulateIOErrorBenign(1);
       rc = fcntlSizeHint(pFile, *(i64 *)pArg);
       SimulateIOErrorBenign(0);
@@ -39155,7 +39153,7 @@
   int ofst,              /* First byte of the locking range */
   int n                  /* Number of bytes to lock */
 ){
-  unixShmNode *pShmNode = NULL; /* Apply locks to this open shared-memory segment */
+  unixShmNode *pShmNode; /* Apply locks to this open shared-memory segment */
   struct flock f;        /* The posix advisory locking structure */
   int rc = SQLITE_OK;    /* Result code form fcntl() */
 
@@ -39171,7 +39169,7 @@
   assert( n>=1 && n<=SQLITE_SHM_NLOCK );
 
   if( pShmNode->hShm>=0 ){
-    int res = 0;
+    int res;
     /* Initialize the locking parameters */
     f.l_type = lockType;
     f.l_whence = SEEK_SET;
@@ -39253,7 +39251,7 @@
   assert( unixMutexHeld() );
   if( p && ALWAYS(p->nRef==0) ){
     int nShmPerMap = unixShmRegionPerMap();
-    int i = 0;
+    int i;
     assert( p->pInode==pFd->pInode );
     sqlite3_mutex_free(p->pShmMutex);
     for(i=0; i<p->nRegion; i+=nShmPerMap){
@@ -39373,11 +39371,11 @@
 */
 static int unixOpenSharedMemory(unixFile *pDbFd){
   struct unixShm *p = 0;          /* The connection to be opened */
-  struct unixShmNode *pShmNode = NULL;   /* The underlying mmapped file */
+  struct unixShmNode *pShmNode;   /* The underlying mmapped file */
   int rc = SQLITE_OK;             /* Result code */
-  unixInodeInfo *pInode = NULL;          /* The inode of fd */
-  char *zShm = NULL;             /* Name of the file used for SHM */
-  int nShmFilename = 0;               /* Size of the SHM filename in bytes */
+  unixInodeInfo *pInode;          /* The inode of fd */
+  char *zShm;             /* Name of the file used for SHM */
+  int nShmFilename;               /* Size of the SHM filename in bytes */
 
   /* Allocate space for the new unixShm object. */
   p = sqlite3_malloc64( sizeof(*p) );
@@ -39521,11 +39519,11 @@
   void volatile **pp              /* OUT: Mapped memory */
 ){
   unixFile *pDbFd = (unixFile*)fd;
-  unixShm *p = NULL;
-  unixShmNode *pShmNode = NULL;
+  unixShm *p;
+  unixShmNode *pShmNode;
   int rc = SQLITE_OK;
   int nShmPerMap = unixShmRegionPerMap();
-  int nReqRegion = 0;
+  int nReqRegion;
 
   /* If the shared-memory file has not yet been opened, open it now. */
   if( pDbFd->pShm==0 ){
@@ -39550,7 +39548,7 @@
   nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap;
 
   if( pShmNode->nRegion<nReqRegion ){
-    char **apNew = NULL;                      /* New apRegion[] array */
+    char **apNew;                      /* New apRegion[] array */
     int nByte = nReqRegion*szRegion;   /* Minimum required file size */
     struct stat sStat;                 /* Used by fstat() */
 
@@ -39583,7 +39581,7 @@
         */
         else{
           static const int pgsz = 4096;
-          int iPg = 0;
+          int iPg;
 
           /* Write to the last byte of each newly allocated or extended page */
           assert( (nByte % pgsz)==0 );
@@ -39610,8 +39608,8 @@
     pShmNode->apRegion = apNew;
     while( pShmNode->nRegion<nReqRegion ){
       int nMap = szRegion*nShmPerMap;
-      int i = 0;
-      void *pMem = NULL;
+      int i;
+      void *pMem;
       if( pShmNode->hShm>=0 ){
         pMem = osMmap(0, nMap,
             pShmNode->isReadonly ? PROT_READ : PROT_READ|PROT_WRITE,
@@ -39695,11 +39693,11 @@
   int flags                  /* What to do with the lock */
 ){
   unixFile *pDbFd = (unixFile*)fd;      /* Connection holding shared memory */
-  unixShm *p = NULL;                           /* The shared memory being locked */
-  unixShmNode *pShmNode = NULL;                /* The underlying file iNode */
+  unixShm *p;                           /* The shared memory being locked */
+  unixShmNode *pShmNode;                /* The underlying file iNode */
   int rc = SQLITE_OK;                   /* Result code */
-  u16 mask = 0;                             /* Mask of locks to take or release */
-  int *aLock = NULL;
+  u16 mask;                             /* Mask of locks to take or release */
+  int *aLock;
 
   p = pDbFd->pShm;
   if( p==0 ) return SQLITE_IOERR_SHMLOCK;
@@ -39747,7 +39745,7 @@
   assert( assertLockingArrayOk(pShmNode) );
   if( flags & SQLITE_SHM_UNLOCK ){
     if( (p->exclMask|p->sharedMask) & mask ){
-      int ii = 0;
+      int ii;
       int bUnlock = 1;
 
       for(ii=ofst; ii<ofst+n; ii++){
@@ -39791,7 +39789,7 @@
   }else{
     /* Make sure no sibling connections hold locks that will block this
     ** lock.  If any do, return SQLITE_BUSY right away.  */
-    int ii = 0;
+    int ii;
     for(ii=ofst; ii<ofst+n; ii++){
       assert( (p->sharedMask & mask)==0 );
       if( ALWAYS((p->exclMask & (1<<ii))==0) && aLock[ii] ){
@@ -39849,10 +39847,10 @@
   sqlite3_file *fd,               /* The underlying database file */
   int deleteFlag                  /* Delete shared-memory if true */
 ){
-  unixShm *p = NULL;                     /* The connection to be closed */
-  unixShmNode *pShmNode = NULL;          /* The underlying shared-memory file */
-  unixShm **pp = NULL;                   /* For looping over sibling connections */
-  unixFile *pDbFd = NULL;                /* The underlying database file */
+  unixShm *p;                     /* The connection to be closed */
+  unixShmNode *pShmNode;          /* The underlying shared-memory file */
+  unixShm **pp;                   /* For looping over sibling connections */
+  unixFile *pDbFd;                /* The underlying database file */
 
   pDbFd = (unixFile*)fd;
   p = pDbFd->pShm;
@@ -40424,7 +40422,7 @@
   const char *zFilename,  /* Name of the file being opened */
   int ctrlFlags           /* Zero or more UNIXFILE_* values */
 ){
-  const sqlite3_io_methods *pLockingStyle = NULL;
+  const sqlite3_io_methods *pLockingStyle;
   unixFile *pNew = (unixFile *)pId;
   int rc = SQLITE_OK;
 
@@ -40533,8 +40531,8 @@
     /* Dotfile locking uses the file path so it needs to be included in
     ** the dotlockLockingContext
     */
-    char *zLockFile = NULL;
-    int nFilename = 0;
+    char *zLockFile;
+    int nFilename;
     assert( zFilename!=0 );
     nFilename = (int)strlen(zFilename) + 6;
     zLockFile = (char *)sqlite3_malloc64(nFilename);
@@ -40638,7 +40636,7 @@
 ** pVfs->mxPathname bytes.
 */
 static int unixGetTempname(int nBuf, char *zBuf){
-  const char *zDir = NULL;
+  const char *zDir;
   int iLimit = 0;
 
   /* It's odd to simulate an io-error here, but really this is just
@@ -40651,7 +40649,7 @@
   zDir = unixTempFileDir();
   if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;
   do{
-    u64 r = 0;
+    u64 r;
     sqlite3_randomness(sizeof(r), &r);
     assert( nBuf>2 );
     zBuf[nBuf-2] = 0;
@@ -40709,7 +40707,7 @@
   ** Even if a subsequent open() call does succeed, the consequences of
   ** not searching for a reusable file descriptor are not dire.  */
   if( inodeList!=0 && 0==osStat(zPath, &sStat) ){
-    unixInodeInfo *pInode = NULL;
+    unixInodeInfo *pInode;
 
     pInode = inodeList;
     while( pInode && (pInode->fileId.dev!=sStat.st_dev
@@ -40717,7 +40715,7 @@
        pInode = pInode->pNext;
     }
     if( pInode ){
-      UnixUnusedFd **pp = NULL;
+      UnixUnusedFd **pp;
       assert( sqlite3_mutex_notheld(pInode->pLockMutex) );
       sqlite3_mutex_enter(pInode->pLockMutex);
       flags &= (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);
@@ -40789,7 +40787,7 @@
   *pGid = 0;
   if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){
     char zDb[MAX_PATHNAME+1];     /* Database file path */
-    int nDb = 0;                      /* Number of valid bytes in zDb */
+    int nDb;                      /* Number of valid bytes in zDb */
 
     /* zPath is a path to a WAL or journal file. The following block derives
     ** the path to the associated database file from zPath. This block handles
@@ -40864,7 +40862,7 @@
   int fd = -1;                   /* File descriptor returned by open() */
   int openFlags = 0;             /* Flags to pass to open() */
   int eType = flags&0x0FFF00;  /* Type of file to open */
-  int noLock = 0;                    /* True to omit locking primitives */
+  int noLock;                    /* True to omit locking primitives */
   int rc = SQLITE_OK;            /* Function Return Code */
   int ctrlFlags = 0;             /* UNIXFILE_* flags */
 
@@ -40939,7 +40937,7 @@
 #endif
 
   if( eType==SQLITE_OPEN_MAIN_DB ){
-    UnixUnusedFd *pUnused = NULL;
+    UnixUnusedFd *pUnused;
     pUnused = findReusableFd(zName, flags);
     if( pUnused ){
       fd = pUnused->fd;
@@ -40981,9 +40979,9 @@
   openFlags |= (O_LARGEFILE|O_BINARY|O_NOFOLLOW);
 
   if( fd<0 ){
-    mode_t openMode = 0;              /* Permissions to create file with */
-    uid_t uid = 0;                    /* Userid for the file */
-    gid_t gid = 0;                    /* Groupid for the file */
+    mode_t openMode;              /* Permissions to create file with */
+    uid_t uid;                    /* Userid for the file */
+    gid_t gid;                    /* Groupid for the file */
     rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);
     if( rc!=SQLITE_OK ){
       assert( !p->pPreallocatedUnused );
@@ -41154,7 +41152,7 @@
   }
 #ifndef SQLITE_DISABLE_DIRSYNC
   if( (dirSync & 1)!=0 ){
-    int fd = 0;
+    int fd;
     rc = osOpenDirectory(zPath, &fd);
     if( rc==SQLITE_OK ){
       if( full_fsync(fd,0,0) ){
@@ -41211,7 +41209,7 @@
 */
 static int unixBackupDir(const char *z, int *pJ){
   int j = *pJ;
-  int i = 0;
+  int i;
   if( j<=0 ) return 0;
   for(i=j-1; i>0 && z[i-1]!='/'; i--){}
   if( i==0 ) return 0;
@@ -41234,7 +41232,7 @@
 ){
   int nPath = sqlite3Strlen30(zPath);
   int iOff = 0;
-  int i = 0, j = 0;
+  int i, j;
   if( zPath[0]!='/' ){
     if( osGetcwd(zOut, nOut-2)==0 ){
       return unixLogError(SQLITE_CANTOPEN_BKPT, "getcwd", zPath);
@@ -41306,7 +41304,7 @@
   return mkFullPathname(zPath, zOut, nOut);
 #else
   int rc = SQLITE_OK;
-  int nByte = 0;
+  int nByte;
   int nLink = 0;                /* Number of symbolic links followed so far */
   const char *zIn = zPath;      /* Input path for each iteration of loop */
   char *zDel = 0;
@@ -41350,7 +41348,7 @@
           rc = unixLogError(SQLITE_CANTOPEN_BKPT, "readlink", zIn);
         }else{
           if( zDel[0]!='/' ){
-            int n = 0;
+            int n;
             for(n = sqlite3Strlen30(zIn); n>0 && zIn[n-1]!='/'; n--);
             if( nByte+n+1>nOut ){
               rc = SQLITE_CANTOPEN_BKPT;
@@ -41401,7 +41399,7 @@
 ** error message.
 */
 static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){
-  const char *zErr = NULL;
+  const char *zErr;
   UNUSED_PARAMETER(NotUsed);
   unixEnterMutex();
   zErr = dlerror();
@@ -41428,7 +41426,7 @@
   ** other hand, dlsym() will not work on such a system either, so we have
   ** not really lost anything.
   */
-  void (*(*x = 0)(void*,const char*))(void);
+  void (*(*x)(void*,const char*))(void);
   UNUSED_PARAMETER(NotUsed);
   x = (void(*(*)(void*,const char*))(void))dlsym;
   return (*x)(p, zSym);
@@ -41467,10 +41465,10 @@
   randomnessPid = osGetpid(0);
 #if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)
   {
-    int fd = 0, got = 0;
+    int fd, got;
     fd = robust_open("/dev/urandom", O_RDONLY, 0);
     if( fd<0 ){
-      time_t t = 0;
+      time_t t;
       time(&t);
       memcpy(zBuf, &t, sizeof(t));
       memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));
@@ -41569,7 +41567,7 @@
 */
 static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){
   sqlite3_int64 i = 0;
-  int rc = 0;
+  int rc;
   UNUSED_PARAMETER(NotUsed);
   rc = unixCurrentTimeInt64(0, &i);
   *prNow = i/86400000.0;
@@ -42869,7 +42867,7 @@
     UNIXVFS("unix-proxy",    proxyIoFinder ),
 #endif
   };
-  unsigned int i = 0;          /* Loop counter */
+  unsigned int i;          /* Loop counter */
 
   /* Double-check that the aSyscall[] array has been constructed
   ** correctly.  See ticket [bb3a86e890c8e96ab] */
@@ -49293,7 +49291,7 @@
 static int memdbClose(sqlite3_file *pFile){
   MemStore *p = ((MemFile*)pFile)->pStore;
   if( p->zFName ){
-    int i = 0;
+    int i;
 #ifndef SQLITE_MUTEX_OMIT
     sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
 #endif
@@ -49355,7 +49353,7 @@
 ** Try to enlarge the memory allocation to hold at least sz bytes
 */
 static int memdbEnlarge(MemStore *p, sqlite3_int64 newSz){
-  unsigned char *pNew = NULL;
+  unsigned char *pNew;
   if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || NEVER(p->nMmap>0) ){
     return SQLITE_FULL;
   }
@@ -49389,7 +49387,7 @@
     return SQLITE_IOERR_WRITE;
   }
   if( iOfst+iAmt>p->sz ){
-    int rc = 0;
+    int rc;
     if( iOfst+iAmt>p->szAlloc
      && (rc = memdbEnlarge(p, iOfst+iAmt))!=SQLITE_OK
     ){
@@ -49589,13 +49587,13 @@
 ){
   MemFile *pFile = (MemFile*)pFd;
   MemStore *p = 0;
-  int szName = 0;
+  int szName;
   UNUSED_PARAMETER(pVfs);
 
   memset(pFile, 0, sizeof(*pFile));
   szName = sqlite3Strlen30(zName);
   if( szName>1 && zName[0]=='/' ){
-    int i = 0;
+    int i;
 #ifndef SQLITE_MUTEX_OMIT
     sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
 #endif
@@ -49607,7 +49605,7 @@
       }
     }
     if( p==0 ){
-      MemStore **apNew = NULL;
+      MemStore **apNew;
       p = sqlite3Malloc( sizeof(*p) + szName + 3 );
       if( p==0 ){
         sqlite3_mutex_leave(pVfsMutex);
@@ -49774,7 +49772,7 @@
 */
 static MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){
   MemFile *p = 0;
-  MemStore *pStore = NULL;
+  MemStore *pStore;
   int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);
   if( rc ) return 0;
   if( p->base.pMethods!=&memdb_io_methods ) return 0;
@@ -49794,15 +49792,15 @@
   sqlite3_int64 *piSize,    /* Write size here, if not NULL */
   unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */
 ){
-  MemFile *p = NULL;
-  int iDb = 0;
-  Btree *pBt = NULL;
-  sqlite3_int64 sz = 0;
+  MemFile *p;
+  int iDb;
+  Btree *pBt;
+  sqlite3_int64 sz;
   int szPage = 0;
   sqlite3_stmt *pStmt = 0;
-  unsigned char *pOut = NULL;
-  char *zSql = NULL;
-  int rc = 0;
+  unsigned char *pOut;
+  char *zSql;
+  int rc;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -49848,7 +49846,7 @@
       if( pOut ){
         int nPage = sqlite3_column_int(pStmt, 0);
         Pager *pPager = sqlite3BtreePager(pBt);
-        int pgno = 0;
+        int pgno;
         for(pgno=1; pgno<=nPage; pgno++){
           DbPage *pPage = 0;
           unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);
@@ -49877,11 +49875,11 @@
   sqlite3_int64 szBuf,    /* Total size of buffer pData[] */
   unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */
 ){
-  MemFile *p = NULL;
-  char *zSql = NULL;
+  MemFile *p;
+  char *zSql;
   sqlite3_stmt *pStmt = 0;
-  int rc = 0;
-  int iDb = 0;
+  int rc;
+  int iDb;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -49947,7 +49945,7 @@
 */
 SQLITE_PRIVATE int sqlite3MemdbInit(void){
   sqlite3_vfs *pLower = sqlite3_vfs_find(0);
-  unsigned int sz = 0;
+  unsigned int sz;
   if( NEVER(pLower==0) ) return SQLITE_ERROR;
   sz = pLower->szOsFile;
   memdb_vfs.pAppData = pLower;
@@ -50078,7 +50076,7 @@
 ** malloc fails.
 */
 SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32 iSize){
-  Bitvec *p = NULL;
+  Bitvec *p;
   assert( sizeof(*p)==BITVEC_SZ );
   p = sqlite3MallocZero( sizeof(*p) );
   if( p ){
@@ -50132,7 +50130,7 @@
 ** Otherwise the behavior is undefined.
 */
 SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i){
-  u32 h = 0;
+  u32 h;
   if( p==0 ) return SQLITE_OK;
   assert( i>0 );
   assert( i<=p->iSize );
@@ -50173,8 +50171,8 @@
   /* make our hash too "full".  */
 bitvec_set_rehash:
   if( p->nSet>=BITVEC_MXHASH ){
-    unsigned int j = 0;
-    int rc = 0;
+    unsigned int j;
+    int rc;
     u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));
     if( aiValues==0 ){
       return SQLITE_NOMEM_BKPT;
@@ -50217,7 +50215,7 @@
   if( p->iSize<=BITVEC_NBIT ){
     p->u.aBitmap[i/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1)));
   }else{
-    unsigned int j = 0;
+    unsigned int j;
     u32 *aiValues = pBuf;
     memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
     memset(p->u.aHash, 0, sizeof(p->u.aHash));
@@ -50242,7 +50240,7 @@
 SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p){
   if( p==0 ) return;
   if( p->iDivisor ){
-    unsigned int i = 0;
+    unsigned int i;
     for(i=0; i<BITVEC_NPTR; i++){
       sqlite3BitvecDestroy(p->u.apSub[i]);
     }
@@ -50303,8 +50301,8 @@
   Bitvec *pBitvec = 0;
   unsigned char *pV = 0;
   int rc = -1;
-  int i = 0, nx = 0, pc = 0, op = 0;
-  void *pTmpSpace = NULL;
+  int i, nx, pc, op;
+  void *pTmpSpace;
 
   /* Allocate the Bitvec to be tested and a linear array of
   ** bits to act as the reference */
@@ -50622,7 +50620,7 @@
     ** suggested cache size is set to N. */
     return p->szCache;
   }else{
-    i64 n = 0;
+    i64 n;
     /* IMPLEMANTATION-OF: R-59858-46238 If the argument N is negative, then the
     ** number of cache pages is adjusted to be a number of pages that would
     ** use approximately abs(N*1024) bytes of memory based on the current
@@ -50701,7 +50699,7 @@
 SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){
   assert( pCache->nRefSum==0 && pCache->pDirty==0 );
   if( pCache->szPage ){
-    sqlite3_pcache *pNew = NULL;
+    sqlite3_pcache *pNew;
     pNew = sqlite3GlobalConfig.pcache2.xCreate(
                 szPage, pCache->szExtra + ROUND8(sizeof(PgHdr)),
                 pCache->bPurgeable
@@ -50747,8 +50745,8 @@
   Pgno pgno,            /* Page number to obtain */
   int createFlag        /* If true, create page if it does not exist already */
 ){
-  int eCreate = 0;
-  sqlite3_pcache_page *pRes = NULL;
+  int eCreate;
+  sqlite3_pcache_page *pRes;
 
   assert( pCache!=0 );
   assert( pCache->pCache!=0 );
@@ -50788,7 +50786,7 @@
   Pgno pgno,                      /* Page number to obtain */
   sqlite3_pcache_page **ppPage    /* Write result here */
 ){
-  PgHdr *pPg = NULL;
+  PgHdr *pPg;
   if( pCache->eCreate==2 ) return 0;
 
   if( sqlite3PcachePagecount(pCache)>pCache->szSpill ){
@@ -50810,7 +50808,7 @@
       for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);
     }
     if( pPg ){
-      int rc = 0;
+      int rc;
 #ifdef SQLITE_LOG_CACHE_SPILL
       sqlite3_log(SQLITE_FULL,
                   "spill page %d making room for %d - cache used: %d/%d",
@@ -50844,7 +50842,7 @@
   Pgno pgno,                  /* Page number obtained */
   sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */
 ){
-  PgHdr *pPgHdr = NULL;
+  PgHdr *pPgHdr;
   assert( pPage!=0 );
   pPgHdr = (PgHdr*)pPage->pExtra;
   assert( pPgHdr->pPage==0 );
@@ -50870,7 +50868,7 @@
   Pgno pgno,                  /* Page number obtained */
   sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */
 ){
-  PgHdr *pPgHdr = NULL;
+  PgHdr *pPgHdr;
 
   assert( pPage!=0 );
   pPgHdr = (PgHdr *)pPage->pExtra;
@@ -50967,7 +50965,7 @@
 ** Make every page in the cache clean.
 */
 SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache *pCache){
-  PgHdr *p = NULL;
+  PgHdr *p;
   pcacheTrace(("%p.CLEAN-ALL\n",pCache));
   while( (p = pCache->pDirty)!=0 ){
     sqlite3PcacheMakeClean(p);
@@ -50978,7 +50976,7 @@
 ** Clear the PGHDR_NEED_SYNC and PGHDR_WRITEABLE flag from all dirty pages.
 */
 SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache *pCache){
-  PgHdr *p = NULL;
+  PgHdr *p;
   pcacheTrace(("%p.CLEAR-WRITEABLE\n",pCache));
   for(p=pCache->pDirty; p; p=p->pDirtyNext){
     p->flags &= ~(PGHDR_NEED_SYNC|PGHDR_WRITEABLE);
@@ -50990,7 +50988,7 @@
 ** Clear the PGHDR_NEED_SYNC flag from all dirty pages.
 */
 SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *pCache){
-  PgHdr *p = NULL;
+  PgHdr *p;
   for(p=pCache->pDirty; p; p=p->pDirtyNext){
     p->flags &= ~PGHDR_NEED_SYNC;
   }
@@ -51024,8 +51022,8 @@
 */
 SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){
   if( pCache->pCache ){
-    PgHdr *p = NULL;
-    PgHdr *pNext = NULL;
+    PgHdr *p;
+    PgHdr *pNext;
     pcacheTrace(("%p.TRUNCATE %d\n",pCache,pgno));
     for(p=pCache->pDirty; p; p=pNext){
       pNext = p->pDirtyNext;
@@ -51040,7 +51038,7 @@
       }
     }
     if( pgno==0 && pCache->nRefSum ){
-      sqlite3_pcache_page *pPage1 = NULL;
+      sqlite3_pcache_page *pPage1;
       pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache,1,0);
       if( ALWAYS(pPage1) ){  /* Page 1 is always available in cache, because
                              ** pCache->nRefSum>0 */
@@ -51073,7 +51071,7 @@
 ** Do not bother fixing the pDirtyPrev pointers.
 */
 static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){
-  PgHdr result, *pTail = NULL;
+  PgHdr result, *pTail;
   pTail = &result;
   assert( pA!=0 && pB!=0 );
   for(;;){
@@ -51110,8 +51108,8 @@
 */
 #define N_SORT_BUCKET  32
 static PgHdr *pcacheSortDirtyList(PgHdr *pIn){
-  PgHdr *a[N_SORT_BUCKET], *p = NULL;
-  int i = 0;
+  PgHdr *a[N_SORT_BUCKET], *p;
+  int i;
   memset(a, 0, sizeof(a));
   while( pIn ){
     p = pIn;
@@ -51145,7 +51143,7 @@
 ** Return a list of all dirty pages in the cache, sorted by page number.
 */
 SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache){
-  PgHdr *p = NULL;
+  PgHdr *p;
   for(p=pCache->pDirty; p; p=p->pDirtyNext){
     p->pDirty = p->pDirtyNext;
   }
@@ -51202,7 +51200,7 @@
 ** be the larger of the szSpill and szCache.
 */
 SQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *p, int mxPage){
-  int res = 0;
+  int res;
   assert( p->pCache!=0 );
   if( mxPage ){
     if( mxPage<0 ){
@@ -51234,7 +51232,7 @@
 ** of the configured cache size.
 */
 SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache *pCache){
-  PgHdr *pDirty = NULL;
+  PgHdr *pDirty;
   int nDirty = 0;
   int nCache = numberOfCachePages(pCache);
   for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext) nDirty++;
@@ -51531,7 +51529,7 @@
 */
 SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){
   if( pcache1.isInit ){
-    PgFreeslot *p = NULL;
+    PgFreeslot *p;
     if( pBuf==0 ) sz = n = 0;
     if( n==0 ) sz = 0;
     sz = ROUNDDOWN8(sz);
@@ -51556,8 +51554,8 @@
 ** true if pCache->pFree ends up containing one or more free pages.
 */
 static int pcache1InitBulk(PCache1 *pCache){
-  i64 szBulk = 0;
-  char *zBulk = NULL;
+  i64 szBulk;
+  char *zBulk;
   if( pcache1.nInitPage==0 ) return 0;
   /* Do not bother with a bulk allocation if the cache size very small */
   if( pCache->nMax<3 ) return 0;
@@ -51639,7 +51637,7 @@
 static void pcache1Free(void *p){
   if( p==0 ) return;
   if( SQLITE_WITHIN(p, pcache1.pStart, pcache1.pEnd) ){
-    PgFreeslot *pSlot = NULL;
+    PgFreeslot *pSlot;
     sqlite3_mutex_enter(pcache1.mutex);
     sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);
     pSlot = (PgFreeslot*)p;
@@ -51688,7 +51686,7 @@
 */
 static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){
   PgHdr1 *p = 0;
-  void *pPg = NULL;
+  void *pPg;
 
   assert( sqlite3_mutex_held(pCache->pGroup->mutex) );
   if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){
@@ -51739,7 +51737,7 @@
 ** Free a page object allocated by pcache1AllocPage().
 */
 static void pcache1FreePage(PgHdr1 *p){
-  PCache1 *pCache = NULL;
+  PCache1 *pCache;
   assert( p!=0 );
   pCache = p->pCache;
   assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );
@@ -51807,9 +51805,9 @@
 ** The PCache mutex must be held when this function is called.
 */
 static void pcache1ResizeHash(PCache1 *p){
-  PgHdr1 **apNew = NULL;
-  unsigned int nNew = 0;
-  unsigned int i = 0;
+  PgHdr1 **apNew;
+  unsigned int nNew;
+  unsigned int i;
 
   assert( sqlite3_mutex_held(p->pGroup->mutex) );
 
@@ -51825,7 +51823,7 @@
   pcache1EnterMutex(p->pGroup);
   if( apNew ){
     for(i=0; i<p->nHash; i++){
-      PgHdr1 *pPage = NULL;
+      PgHdr1 *pPage;
       PgHdr1 *pNext = p->apHash[i];
       while( (pPage = pNext)!=0 ){
         unsigned int h = pPage->iKey % nNew;
@@ -51873,9 +51871,9 @@
 ** The PGroup mutex must be held when this function is called.
 */
 static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){
-  unsigned int h = 0;
+  unsigned int h;
   PCache1 *pCache = pPage->pCache;
-  PgHdr1 **pp = NULL;
+  PgHdr1 **pp;
 
   assert( sqlite3_mutex_held(pCache->pGroup->mutex) );
   h = pPage->iKey % pCache->nHash;
@@ -51892,7 +51890,7 @@
 */
 static void pcache1EnforceMaxPage(PCache1 *pCache){
   PGroup *pGroup = pCache->pGroup;
-  PgHdr1 *p = NULL;
+  PgHdr1 *p;
   assert( sqlite3_mutex_held(pGroup->mutex) );
   while( pGroup->nPurgeable>pGroup->nMaxPage
       && (p=pGroup->lru.pLruPrev)->isAnchor==0
@@ -51920,7 +51918,7 @@
   unsigned int iLimit          /* Drop pages with this pgno or larger */
 ){
   TESTONLY( int nPage = 0; )  /* To assert pCache->nPage is correct */
-  unsigned int h = 0, iStop = 0;
+  unsigned int h, iStop;
   assert( sqlite3_mutex_held(pCache->pGroup->mutex) );
   assert( pCache->iMaxKey >= iLimit );
   assert( pCache->nHash > 0 );
@@ -51939,8 +51937,8 @@
     iStop = h - 1;
   }
   for(;;){
-    PgHdr1 **pp = NULL;
-    PgHdr1 *pPage = NULL;
+    PgHdr1 **pp;
+    PgHdr1 *pPage;
     assert( h<pCache->nHash );
     pp = &pCache->apHash[h];
     while( (pPage = *pp)!=0 ){
@@ -52034,9 +52032,9 @@
 ** Allocate a new cache.
 */
 static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){
-  PCache1 *pCache = NULL;      /* The newly created page cache */
-  PGroup *pGroup = NULL;       /* The group the new page cache will belong to */
-  int sz = 0;               /* Bytes of memory required to allocate the new cache */
+  PCache1 *pCache;      /* The newly created page cache */
+  PGroup *pGroup;       /* The group the new page cache will belong to */
+  int sz;               /* Bytes of memory required to allocate the new cache */
 
   assert( (szPage & (szPage-1))==0 && szPage>=512 && szPage<=65536 );
   assert( szExtra < 300 );
@@ -52085,7 +52083,7 @@
 */
 static void pcache1Cachesize(sqlite3_pcache *p, int nMax){
   PCache1 *pCache = (PCache1 *)p;
-  u32 n = 0;
+  u32 n;
   assert( nMax>=0 );
   if( pCache->bPurgeable ){
     PGroup *pGroup = pCache->pGroup;
@@ -52112,7 +52110,7 @@
   PCache1 *pCache = (PCache1*)p;
   if( pCache->bPurgeable ){
     PGroup *pGroup = pCache->pGroup;
-    unsigned int savedMaxPage = 0;
+    unsigned int savedMaxPage;
     pcache1EnterMutex(pGroup);
     savedMaxPage = pGroup->nMaxPage;
     pGroup->nMaxPage = 0;
@@ -52126,7 +52124,7 @@
 ** Implementation of the sqlite3_pcache.xPagecount method.
 */
 static int pcache1Pagecount(sqlite3_pcache *p){
-  int n = 0;
+  int n;
   PCache1 *pCache = (PCache1*)p;
   pcache1EnterMutex(pCache->pGroup);
   n = pCache->nPage;
@@ -52148,7 +52146,7 @@
   unsigned int iKey,
   int createFlag
 ){
-  unsigned int nPinned = 0;
+  unsigned int nPinned;
   PGroup *pGroup = pCache->pGroup;
   PgHdr1 *pPage = 0;
 
@@ -52173,7 +52171,7 @@
    && !pGroup->lru.pLruPrev->isAnchor
    && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))
   ){
-    PCache1 *pOther = NULL;
+    PCache1 *pOther;
     pPage = pGroup->lru.pLruPrev;
     assert( PAGE_IS_UNPINNED(pPage) );
     pcache1RemoveFromHash(pPage, 0);
@@ -52390,8 +52388,8 @@
 ){
   PCache1 *pCache = (PCache1 *)p;
   PgHdr1 *pPage = (PgHdr1 *)pPg;
-  PgHdr1 **pp = NULL;
-  unsigned int h = 0;
+  PgHdr1 **pp;
+  unsigned int h;
   assert( pPage->iKey==iOld );
   assert( pPage->pCache==pCache );
 
@@ -52706,7 +52704,7 @@
 */
 SQLITE_PRIVATE void sqlite3RowSetClear(void *pArg){
   RowSet *p = (RowSet*)pArg;
-  struct RowSetChunk *pChunk = NULL, *pNextChunk = NULL;
+  struct RowSetChunk *pChunk, *pNextChunk;
   for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){
     pNextChunk = pChunk->pNextChunk;
     sqlite3DbFree(p->db, pChunk);
@@ -52742,7 +52740,7 @@
   if( p->nFresh==0 ){  /*OPTIMIZATION-IF-FALSE*/
     /* We could allocate a fresh RowSetEntry each time one is needed, but it
     ** is more efficient to pull a preallocated entry from the pool */
-    struct RowSetChunk *pNew = NULL;
+    struct RowSetChunk *pNew;
     pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));
     if( pNew==0 ){
       return 0;
@@ -52763,8 +52761,8 @@
 ** memory allocation fails.
 */
 SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet *p, i64 rowid){
-  struct RowSetEntry *pEntry = NULL;  /* The new entry */
-  struct RowSetEntry *pLast = NULL;   /* The last prior entry */
+  struct RowSetEntry *pEntry;  /* The new entry */
+  struct RowSetEntry *pLast;   /* The last prior entry */
 
   /* This routine is never called after sqlite3RowSetNext() */
   assert( p!=0 && (p->rsFlags & ROWSET_NEXT)==0 );
@@ -52798,7 +52796,7 @@
   struct RowSetEntry *pB     /* Second sorted list to be merged */
 ){
   struct RowSetEntry head;
-  struct RowSetEntry *pTail = NULL;
+  struct RowSetEntry *pTail;
 
   pTail = &head;
   assert( pA!=0 && pB!=0 );
@@ -52829,8 +52827,8 @@
 ** increasing v.
 */
 static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){
-  unsigned int i = 0;
-  struct RowSetEntry *pNext = NULL, *aBucket[40];
+  unsigned int i;
+  struct RowSetEntry *pNext, *aBucket[40];
 
   memset(aBucket, 0, sizeof(aBucket));
   while( pIn ){
@@ -52864,7 +52862,7 @@
 ){
   assert( pIn!=0 );
   if( pIn->pLeft ){
-    struct RowSetEntry *p = NULL;
+    struct RowSetEntry *p;
     rowSetTreeToList(pIn->pLeft, ppFirst, &p);
     p->pRight = pIn;
   }else{
@@ -52896,8 +52894,8 @@
   struct RowSetEntry **ppList,
   int iDepth
 ){
-  struct RowSetEntry *p = NULL;         /* Root of the new tree */
-  struct RowSetEntry *pLeft = NULL;     /* Left subtree */
+  struct RowSetEntry *p;         /* Root of the new tree */
+  struct RowSetEntry *pLeft;     /* Left subtree */
   if( *ppList==0 ){ /*OPTIMIZATION-IF-TRUE*/
     /* Prevent unnecessary deep recursion when we run out of entries */
     return 0;
@@ -52929,9 +52927,9 @@
 ** as deep as it needs to be in order to contain the entire list.
 */
 static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){
-  int iDepth = 0;           /* Depth of the tree so far */
-  struct RowSetEntry *p = NULL;       /* Current tree root */
-  struct RowSetEntry *pLeft = NULL;   /* Left subtree */
+  int iDepth;           /* Depth of the tree so far */
+  struct RowSetEntry *p;       /* Current tree root */
+  struct RowSetEntry *pLeft;   /* Left subtree */
 
   assert( pList!=0 );
   p = pList;
@@ -52995,7 +52993,7 @@
 ** pRowSet->pForest so that they can be tested.
 */
 SQLITE_PRIVATE int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid){
-  struct RowSetEntry *p = NULL, *pTree = NULL;
+  struct RowSetEntry *p, *pTree;
 
   /* This routine is never called after sqlite3RowSetNext() */
   assert( pRowSet!=0 && (pRowSet->rsFlags & ROWSET_NEXT)==0 );
@@ -53017,7 +53015,7 @@
           pTree->pLeft = rowSetListToTree(p);
           break;
         }else{
-          struct RowSetEntry *pAux = NULL, *pTail = NULL;
+          struct RowSetEntry *pAux, *pTail;
           rowSetTreeToList(pTree->pLeft, &pAux, &pTail);
           pTree->pLeft = 0;
           p = rowSetEntryMerge(pAux, p);
@@ -54285,9 +54283,9 @@
 */
 static int subjRequiresPage(PgHdr *pPg){
   Pager *pPager = pPg->pPager;
-  PagerSavepoint *p = NULL;
+  PagerSavepoint *p;
   Pgno pgno = pPg->pgno;
-  int i = 0;
+  int i;
   for(i=0; i<pPager->nSavepoint; i++){
     p = &pPager->aSavepoint[i];
     if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){
@@ -54517,11 +54515,11 @@
 ** error code is returned.
 */
 static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u32 nSuper){
-  int rc = 0;                    /* Return code */
-  u32 len = 0;                   /* Length in bytes of super-journal name */
-  i64 szJ = 0;                   /* Total size in bytes of journal file pJrnl */
-  u32 cksum = 0;                 /* MJ checksum value read from journal */
-  u32 u = 0;                     /* Unsigned loop counter */
+  int rc;                    /* Return code */
+  u32 len;                   /* Length in bytes of super-journal name */
+  i64 szJ;                   /* Total size in bytes of journal file pJrnl */
+  u32 cksum;                 /* MJ checksum value read from journal */
+  u32 u;                     /* Unsigned loop counter */
   unsigned char aMagic[8];   /* A buffer to hold the magic header */
   zSuper[0] = '\0';
 
@@ -54630,7 +54628,7 @@
     ** to sync the file following this operation.
     */
     if( rc==SQLITE_OK && iLimit>0 ){
-      i64 sz = 0;
+      i64 sz;
       rc = sqlite3OsFileSize(pPager->jfd, &sz);
       if( rc==SQLITE_OK && sz>iLimit ){
         rc = sqlite3OsTruncate(pPager->jfd, iLimit);
@@ -54659,8 +54657,8 @@
   int rc = SQLITE_OK;                 /* Return code */
   char *zHeader = pPager->pTmpSpace;  /* Temporary space used to build header */
   u32 nHeader = (u32)pPager->pageSize;/* Size of buffer pointed to by zHeader */
-  u32 nWrite = 0;                         /* Bytes of header sector written */
-  int ii = 0;                             /* Loop counter */
+  u32 nWrite;                         /* Bytes of header sector written */
+  int ii;                             /* Loop counter */
 
   assert( isOpen(pPager->jfd) );      /* Journal file must be open. */
 
@@ -54780,9 +54778,9 @@
   u32 *pNRec,                  /* OUT: Value read from the nRec field */
   u32 *pDbSize                 /* OUT: Value of original database size field */
 ){
-  int rc = 0;                      /* Return code */
+  int rc;                      /* Return code */
   unsigned char aMagic[8];     /* A buffer to hold the magic header */
-  i64 iHdrOff = 0;                 /* Offset of journal header being read */
+  i64 iHdrOff;                 /* Offset of journal header being read */
 
   assert( isOpen(pPager->jfd) );      /* Journal file must be open. */
 
@@ -54823,8 +54821,8 @@
   }
 
   if( pPager->journalOff==0 ){
-    u32 iPageSize = 0;               /* Page-size field of journal header */
-    u32 iSectorSize = 0;             /* Sector-size field of journal header */
+    u32 iPageSize;               /* Page-size field of journal header */
+    u32 iSectorSize;             /* Sector-size field of journal header */
 
     /* Read the page-size and sector-size journal header fields. */
     if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))
@@ -54899,10 +54897,10 @@
 ** this call is a no-op.
 */
 static int writeSuperJournal(Pager *pPager, const char *zSuper){
-  int rc = 0;                          /* Return code */
-  int nSuper = 0;                      /* Length of string zSuper */
-  i64 iHdrOff = 0;                     /* Offset of header in journal file */
-  i64 jrnlSize = 0;                    /* Size of journal file on disk */
+  int rc;                          /* Return code */
+  int nSuper;                      /* Length of string zSuper */
+  i64 iHdrOff;                     /* Offset of header in journal file */
+  i64 jrnlSize;                    /* Size of journal file on disk */
   u32 cksum = 0;                   /* Checksum of string zSuper */
 
   assert( pPager->setSuper==0 );
@@ -54985,7 +54983,7 @@
 ** if it is open and the pager is not in exclusive mode.
 */
 static void releaseAllSavepoints(Pager *pPager){
-  int ii = 0;               /* Iterator for looping through Pager.aSavepoint */
+  int ii;               /* Iterator for looping through Pager.aSavepoint */
   for(ii=0; ii<pPager->nSavepoint; ii++){
     sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
   }
@@ -55004,7 +55002,7 @@
 ** or SQLITE_NOMEM if a malloc failure occurs.
 */
 static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){
-  int ii = 0;                   /* Loop counter */
+  int ii;                   /* Loop counter */
   int rc = SQLITE_OK;       /* Result code */
 
   for(ii=0; ii<pPager->nSavepoint; ii++){
@@ -55051,7 +55049,7 @@
     sqlite3WalEndReadTransaction(pPager->pWal);
     pPager->eState = PAGER_OPEN;
   }else if( !pPager->exclusiveMode ){
-    int rc = 0;                       /* Error code returned by pagerUnlockDb() */
+    int rc;                       /* Error code returned by pagerUnlockDb() */
     int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0;
 
     /* If the operating system support deletion of open files, then
@@ -55461,13 +55459,13 @@
   int isMainJrnl,               /* 1 -> main journal. 0 -> sub-journal. */
   int isSavepnt                 /* True for a savepoint rollback */
 ){
-  int rc = 0;
-  PgHdr *pPg = NULL;                   /* An existing page in the cache */
-  Pgno pgno = 0;                    /* The page number of a page in journal */
-  u32 cksum = 0;                    /* Checksum used for sanity checking */
-  char *aData = NULL;                  /* Temporary storage for the page */
-  sqlite3_file *jfd = NULL;            /* The file descriptor for the journal file */
-  int isSynced = 0;                 /* True if journal page is synced */
+  int rc;
+  PgHdr *pPg;                   /* An existing page in the cache */
+  Pgno pgno;                    /* The page number of a page in journal */
+  u32 cksum;                    /* Checksum used for sanity checking */
+  char *aData;                  /* Temporary storage for the page */
+  sqlite3_file *jfd;            /* The file descriptor for the journal file */
+  int isSynced;                 /* True if journal page is synced */
 
   assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */
   assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */
@@ -55638,7 +55636,7 @@
     ** of an internal error resulting in an automatic call to
     ** sqlite3PagerRollback().
     */
-    void *pData = NULL;
+    void *pData;
     pData = pPg->pData;
     memcpy(pData, (u8*)aData, pPager->pageSize);
     pPager->xReiniter(pPg);
@@ -55703,15 +55701,15 @@
 */
 static int pager_delsuper(Pager *pPager, const char *zSuper){
   sqlite3_vfs *pVfs = pPager->pVfs;
-  int rc = 0;                   /* Return code */
-  sqlite3_file *pSuper = NULL;     /* Malloc'd super-journal file descriptor */
-  sqlite3_file *pJournal = NULL;   /* Malloc'd child-journal file descriptor */
+  int rc;                   /* Return code */
+  sqlite3_file *pSuper;     /* Malloc'd super-journal file descriptor */
+  sqlite3_file *pJournal;   /* Malloc'd child-journal file descriptor */
   char *zSuperJournal = 0;  /* Contents of super-journal file */
-  i64 nSuperJournal = 0;        /* Size of super-journal file */
-  char *zJournal = NULL;           /* Pointer to one journal within MJ file */
-  char *zSuperPtr = NULL;          /* Space to hold super-journal filename */
+  i64 nSuperJournal;        /* Size of super-journal file */
+  char *zJournal;           /* Pointer to one journal within MJ file */
+  char *zSuperPtr;          /* Space to hold super-journal filename */
   char *zFree = 0;          /* Free this buffer */
-  int nSuperPtr = 0;            /* Amount of space allocated to zSuperPtr[] */
+  int nSuperPtr;            /* Amount of space allocated to zSuperPtr[] */
 
   /* Allocate space for both the pJournal and pSuper file descriptors.
   ** If successful, open the super-journal file for reading.
@@ -55750,7 +55748,7 @@
 
   zJournal = zSuperJournal;
   while( (zJournal-zSuperJournal)<nSuperJournal ){
-    int exists = 0;
+    int exists;
     rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);
     if( rc!=SQLITE_OK ){
       goto delsuper_out;
@@ -55763,7 +55761,7 @@
       ** SUPER_JOURNAL here so that the VFS will not send the zJournal
       ** name into sqlite3_database_file_object().
       */
-      int c = 0;
+      int c;
       int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);
       rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);
       if( rc!=SQLITE_OK ){
@@ -55827,7 +55825,7 @@
   if( isOpen(pPager->fd)
    && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)
   ){
-    i64 currentSize = 0, newSize = 0;
+    i64 currentSize, newSize;
     int szPage = pPager->pageSize;
     assert( pPager->eLock==EXCLUSIVE_LOCK );
     /* TODO: Is it safe to use Pager.dbFileSize here? */
@@ -55964,14 +55962,14 @@
 */
 static int pager_playback(Pager *pPager, int isHot){
   sqlite3_vfs *pVfs = pPager->pVfs;
-  i64 szJ = 0;                 /* Size of the journal file in bytes */
-  u32 nRec = 0;                /* Number of Records in the journal */
-  u32 u = 0;                   /* Unsigned loop counter */
+  i64 szJ;                 /* Size of the journal file in bytes */
+  u32 nRec;                /* Number of Records in the journal */
+  u32 u;                   /* Unsigned loop counter */
   Pgno mxPg = 0;           /* Size of the original file in pages */
-  int rc = 0;                  /* Result code of a subroutine */
+  int rc;                  /* Result code of a subroutine */
   int res = 1;             /* Value returned by sqlite3OsAccess() */
   char *zSuper = 0;        /* Name of super-journal file if any */
-  int needPagerReset = 0;      /* True to reset page prior to first page rollback */
+  int needPagerReset;      /* True to reset page prior to first page rollback */
   int nPlayback = 0;       /* Total number of pages restored from journal */
   u32 savedPageSize = pPager->pageSize;
 
@@ -56246,7 +56244,7 @@
 ** needed, as determined by the pPager->changeCountDone state variable.
 */
 static void pager_write_changecounter(PgHdr *pPg){
-  u32 change_counter = 0;
+  u32 change_counter;
   if( NEVER(pPg==0) ) return;
 
   /* Increment the value just read and write it back to byte 24. */
@@ -56276,7 +56274,7 @@
 static int pagerUndoCallback(void *pCtx, Pgno iPg){
   int rc = SQLITE_OK;
   Pager *pPager = (Pager *)pCtx;
-  PgHdr *pPg = NULL;
+  PgHdr *pPg;
 
   assert( pagerUseWal(pPager) );
   pPg = sqlite3PagerLookup(pPager, iPg);
@@ -56309,8 +56307,8 @@
 ** This function is called to rollback a transaction on a WAL database.
 */
 static int pagerRollbackWal(Pager *pPager){
-  int rc = 0;                         /* Return Code */
-  PgHdr *pList = NULL;                   /* List of dirty pages to revert */
+  int rc;                         /* Return Code */
+  PgHdr *pList;                   /* List of dirty pages to revert */
 
   /* For all pages in the cache that are currently dirty or have already
   ** been written (but not committed) to the log file, do one of the
@@ -56346,9 +56344,9 @@
   Pgno nTruncate,                 /* Database size after this commit */
   int isCommit                    /* True if this is a commit */
 ){
-  int rc = 0;                         /* Return code */
-  int nList = 0;                      /* Number of pages in pList */
-  PgHdr *p = NULL;                       /* For looping over pages */
+  int rc;                         /* Return code */
+  int nList;                      /* Number of pages in pList */
+  PgHdr *p;                       /* For looping over pages */
 
   assert( pPager->pWal );
   assert( pList );
@@ -56408,7 +56406,7 @@
 ** other writers or checkpointers.
 */
 static int pagerBeginReadTransaction(Pager *pPager){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
   int changed = 0;                /* True if cache must be reset */
 
   assert( pagerUseWal(pPager) );
@@ -56441,7 +56439,7 @@
 ** SQLITE_IOERR_FSTAT) is returned and *pnPage is left unmodified.
 */
 static int pagerPagecount(Pager *pPager, Pgno *pnPage){
-  Pgno nPage = 0;                     /* Value to return via *pnPage */
+  Pgno nPage;                     /* Value to return via *pnPage */
 
   /* Query the WAL sub-system for the database size. The WalDbsize()
   ** function returns zero if the WAL is not open (i.e. Pager.pWal==0), or
@@ -56506,13 +56504,13 @@
   assert( pPager->eLock>=SHARED_LOCK );
 
   if( !pPager->tempFile ){
-    int isWal = 0;                    /* True if WAL file exists */
+    int isWal;                    /* True if WAL file exists */
     rc = sqlite3OsAccess(
         pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal
     );
     if( rc==SQLITE_OK ){
       if( isWal ){
-        Pgno nPage = 0;                   /* Size of the database file */
+        Pgno nPage;                   /* Size of the database file */
 
         rc = pagerPagecount(pPager, &nPage);
         if( rc ) return rc;
@@ -56568,8 +56566,8 @@
 ** is played back. If one is encountered it is simply skipped.
 */
 static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){
-  i64 szJ = 0;                 /* Effective size of the main journal */
-  i64 iHdrOff = 0;             /* End of first segment of main-journal records */
+  i64 szJ;                 /* Effective size of the main journal */
+  i64 iHdrOff;             /* End of first segment of main-journal records */
   int rc = SQLITE_OK;      /* Return code */
   Bitvec *pDone = 0;       /* Bitvec to ensure pages played back only once */
 
@@ -56626,9 +56624,9 @@
   ** continue adding pages rolled back to pDone.
   */
   while( rc==SQLITE_OK && pPager->journalOff<szJ ){
-    u32 ii = 0;            /* Loop counter */
+    u32 ii;            /* Loop counter */
     u32 nJRec = 0;     /* Number of Journal Records */
-    u32 dummy = 0;
+    u32 dummy;
     rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);
     assert( rc!=SQLITE_DONE );
 
@@ -56654,7 +56652,7 @@
   ** will be skipped.  Out-of-range pages are also skipped.
   */
   if( pSavepoint ){
-    u32 ii = 0;            /* Loop counter */
+    u32 ii;            /* Loop counter */
     i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);
 
     if( pagerUseWal(pPager) ){
@@ -56698,7 +56696,7 @@
 #if SQLITE_MAX_MMAP_SIZE>0
   sqlite3_file *fd = pPager->fd;
   if( isOpen(fd) && fd->pMethods->iVersion>=3 ){
-    sqlite3_int64 sz = 0;
+    sqlite3_int64 sz;
     sz = pPager->szMmap;
     pPager->bUseFetch = (sz>0);
     setGetterMethod(pPager);
@@ -56839,7 +56837,7 @@
   sqlite3_file *pFile,  /* Write the file descriptor here */
   int vfsFlags          /* Flags passed through to the VFS */
 ){
-  int rc = 0;               /* Return code */
+  int rc;               /* Return code */
 
 #ifdef SQLITE_TEST
   sqlite3_opentemp_count++;  /* Used for testing and analysis only */
@@ -56878,7 +56876,7 @@
   int (*xBusyHandler)(void *),         /* Pointer to busy-handler function */
   void *pBusyHandlerArg                /* Argument to pass to xBusyHandler */
 ){
-  void **ap = NULL;
+  void **ap;
   pPager->xBusyHandler = xBusyHandler;
   pPager->pBusyHandlerArg = pBusyHandlerArg;
   ap = (void **)&pPager->xBusyHandler;
@@ -57096,7 +57094,7 @@
 ** variable to locktype before returning.
 */
 static int pager_wait_on_lock(Pager *pPager, int locktype){
-  int rc = 0;                              /* Return code */
+  int rc;                              /* Return code */
 
   /* Check that this is either a no-op (because the requested lock is
   ** already held), or one of the transitions that the busy-handler
@@ -57225,7 +57223,7 @@
   void *pData,                    /* xFetch()'d data for this page */
   PgHdr **ppPage                  /* OUT: Acquired page object */
 ){
-  PgHdr *p = NULL;                       /* Memory mapped page to return */
+  PgHdr *p;                       /* Memory mapped page to return */
 
   if( pPager->pMmapFreelist ){
     *ppPage = p = pPager->pMmapFreelist;
@@ -57277,8 +57275,8 @@
 ** Free all PgHdr objects stored in the Pager.pMmapFreelist list.
 */
 static void pagerFreeMapHdrs(Pager *pPager){
-  PgHdr *p = NULL;
-  PgHdr *pNext = NULL;
+  PgHdr *p;
+  PgHdr *pNext;
   for(p=pPager->pMmapFreelist; p; p=pNext){
     pNext = p->pDirty;
     sqlite3_free(p);
@@ -57292,7 +57290,7 @@
 */
 static int databaseIsUnmoved(Pager *pPager){
   int bHasMoved = 0;
-  int rc = 0;
+  int rc;
 
   if( pPager->tempFile ) return SQLITE_OK;
   if( pPager->dbSize==0 ) return SQLITE_OK;
@@ -57433,7 +57431,7 @@
 ** error is encountered, then the IO error code is returned to the caller.
 */
 static int syncJournal(Pager *pPager, int newHdr){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
 
   assert( pPager->eState==PAGER_WRITER_CACHEMOD
        || pPager->eState==PAGER_WRITER_DBMOD
@@ -57473,7 +57471,7 @@
         ** as a temporary buffer to inspect the first couple of bytes of
         ** the potential journal header.
         */
-        i64 iNextHdrOffset = 0;
+        i64 iNextHdrOffset;
         u8 aMagic[8];
         u8 zHeader[sizeof(aJournalMagic)+4];
 
@@ -57619,7 +57617,7 @@
     */
     if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){
       i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */
-      char *pData = NULL;                                   /* Data to write */
+      char *pData;                                   /* Data to write */
 
       assert( (pList->flags&PGHDR_NEED_SYNC)==0 );
       if( pList->pgno==1 ) pager_write_changecounter(pList);
@@ -57712,7 +57710,7 @@
     if( rc==SQLITE_OK ){
       void *pData = pPg->pData;
       i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);
-      char *pData2 = NULL;
+      char *pData2;
       pData2 = pData;
       PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));
       rc = write32bits(pPager->sjfd, offset, pPg->pgno);
@@ -57890,7 +57888,7 @@
   int vfsFlags,            /* flags passed through to sqlite3_vfs.xOpen() */
   void (*xReinit)(DbPage*) /* Function to reinitialize pages */
 ){
-  u8 *pPtr = NULL;
+  u8 *pPtr;
   Pager *pPager = 0;       /* Pager object to allocate and return */
   int rc = SQLITE_OK;      /* Return code */
   int tempFile = 0;        /* True for temp files (incl. in-memory files) */
@@ -57901,7 +57899,7 @@
 # define memJM 0
 #endif
   int readOnly = 0;        /* True if this is a read-only file */
-  int journalFileSize = 0;     /* Bytes to allocate for each journal fd */
+  int journalFileSize;     /* Bytes to allocate for each journal fd */
   char *zPathname = 0;     /* Full path to database file */
   int nPathname = 0;       /* Number of bytes in zPathname */
   int useJournal = (flags & PAGER_OMIT_JOURNAL)==0; /* False to omit journal */
@@ -57935,7 +57933,7 @@
   ** leave both nPathname and zPathname set to 0.
   */
   if( zFilename && zFilename[0] ){
-    const char *z = NULL;
+    const char *z;
     nPathname = pVfs->mxPathname+1;
     zPathname = sqlite3DbMallocRaw(0, nPathname*2);
     if( zPathname==0 ){
@@ -58254,7 +58252,7 @@
 ** xOpen.
 */
 SQLITE_API sqlite3_file *sqlite3_database_file_object(const char *zName){
-  Pager *pPager = NULL;
+  Pager *pPager;
   while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){
     zName--;
   }
@@ -58325,7 +58323,7 @@
     */
     rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);
     if( rc==SQLITE_OK && !locked ){
-      Pgno nPage = 0;                 /* Number of pages in database file */
+      Pgno nPage;                 /* Number of pages in database file */
 
       assert( pPager->tempFile==0 );
       rc = pagerPagecount(pPager, &nPage);
@@ -58488,7 +58486,7 @@
       */
       if( !isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){
         sqlite3_vfs * const pVfs = pPager->pVfs;
-        int bExists = 0;              /* True if journal file exists */
+        int bExists;              /* True if journal file exists */
         rc = sqlite3OsAccess(
             pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);
         if( rc==SQLITE_OK && bExists ){
@@ -58702,9 +58700,9 @@
   int flags           /* PAGER_GET_XXX flags */
 ){
   int rc = SQLITE_OK;
-  PgHdr *pPg = NULL;
-  u8 noContent = 0;                   /* True if PAGER_GET_NOCONTENT is set */
-  sqlite3_pcache_page *pBase = NULL;
+  PgHdr *pPg;
+  u8 noContent;                   /* True if PAGER_GET_NOCONTENT is set */
+  sqlite3_pcache_page *pBase;
 
   assert( pPager->errCode==SQLITE_OK );
   assert( pPager->eState>=PAGER_READER );
@@ -58904,7 +58902,7 @@
 ** has ever happened.
 */
 SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){
-  sqlite3_pcache_page *pPage = NULL;
+  sqlite3_pcache_page *pPage;
   assert( pPager!=0 );
   assert( pgno!=0 );
   assert( pPager->pPCache!=0 );
@@ -58942,7 +58940,7 @@
   if( pPg ) sqlite3PagerUnrefNotNull(pPg);
 }
 SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage *pPg){
-  Pager *pPager = NULL;
+  Pager *pPager;
   assert( pPg!=0 );
   assert( pPg->pgno==1 );
   assert( (pPg->flags & PGHDR_MMAP)==0 ); /* Page1 is never memory mapped */
@@ -58998,7 +58996,7 @@
         sqlite3MemJournalOpen(pPager->jfd);
       }else{
         int flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;
-        int nSpill = 0;
+        int nSpill;
 
         if( pPager->tempFile ){
           flags |= (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL);
@@ -59133,9 +59131,9 @@
 */
 static SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg){
   Pager *pPager = pPg->pPager;
-  int rc = 0;
-  u32 cksum = 0;
-  char *pData2 = NULL;
+  int rc;
+  u32 cksum;
+  char *pData2;
   i64 iOff = pPager->journalOff;
 
   /* We should never write to the journal file the page that
@@ -59282,10 +59280,10 @@
 */
 static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg){
   int rc = SQLITE_OK;          /* Return code */
-  Pgno nPageCount = 0;             /* Total number of pages in database file */
-  Pgno pg1 = 0;                    /* First page of the sector pPg is located on. */
+  Pgno nPageCount;             /* Total number of pages in database file */
+  Pgno pg1;                    /* First page of the sector pPg is located on. */
   int nPage = 0;               /* Number of pages starting at pg1 to journal */
-  int ii = 0;                      /* Loop counter */
+  int ii;                      /* Loop counter */
   int needSync = 0;            /* True if any page has PGHDR_NEED_SYNC */
   Pager *pPager = pPg->pPager; /* The pager that owns pPg */
   Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);
@@ -59318,7 +59316,7 @@
 
   for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){
     Pgno pg = pg1+ii;
-    PgHdr *pPage = NULL;
+    PgHdr *pPage;
     if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){
       if( pg!=PAGER_MJ_PGNO(pPager) ){
         rc = sqlite3PagerGet(pPager, pg, &pPage, 0);
@@ -59484,7 +59482,7 @@
 #endif
 
   if( !pPager->changeCountDone && ALWAYS(pPager->dbSize>0) ){
-    PgHdr *pPgHdr = NULL;                /* Reference to page 1 */
+    PgHdr *pPgHdr;                /* Reference to page 1 */
 
     assert( !pPager->tempFile && isOpen(pPager->fd) );
 
@@ -59507,7 +59505,7 @@
 
       /* If running in direct mode, write the contents of page 1 to the file. */
       if( DIRECT_MODE ){
-        const void *zBuf = NULL;
+        const void *zBuf;
         assert( pPager->dbFileSize>0 );
         zBuf = pPgHdr->pData;
         if( rc==SQLITE_OK ){
@@ -59639,7 +59637,7 @@
     ** backup in progress needs to be restarted.  */
     sqlite3BackupRestart(pPager->pBackup);
   }else{
-    PgHdr *pList = NULL;
+    PgHdr *pList;
     if( pagerUseWal(pPager) ){
       PgHdr *pPageOne = 0;
       pList = sqlite3PcacheDirtyList(pPager->pPCache);
@@ -59914,7 +59912,7 @@
   if( pPager->eState<=PAGER_READER ) return SQLITE_OK;
 
   if( pagerUseWal(pPager) ){
-    int rc2 = 0;
+    int rc2;
     rc = sqlite3PagerSavepoint(pPager, SAVEPOINT_ROLLBACK, -1);
     rc2 = pager_end_transaction(pPager, pPager->setSuper, 0);
     if( rc==SQLITE_OK ) rc = rc2;
@@ -60055,8 +60053,8 @@
 static SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint){
   int rc = SQLITE_OK;                       /* Return code */
   int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */
-  int ii = 0;                                   /* Iterator variable */
-  PagerSavepoint *aNew = NULL;                     /* New Pager.aSavepoint array */
+  int ii;                                   /* Iterator variable */
+  PagerSavepoint *aNew;                     /* New Pager.aSavepoint array */
 
   assert( pPager->eState>=PAGER_WRITER_LOCKED );
   assert( assert_pager_state(pPager) );
@@ -60151,8 +60149,8 @@
   assert( iSavepoint>=0 || op==SAVEPOINT_ROLLBACK );
 
   if( rc==SQLITE_OK && iSavepoint<pPager->nSavepoint ){
-    int ii = 0;            /* Iterator variable */
-    int nNew = 0;          /* Number of remaining savepoints after this op. */
+    int ii;            /* Iterator variable */
+    int nNew;          /* Number of remaining savepoints after this op. */
 
     /* Figure out how many savepoints will still be active after this
     ** operation. Store this value in nNew. Then free resources associated
@@ -60288,10 +60286,10 @@
 ** occurs. Otherwise, it returns SQLITE_OK.
 */
 SQLITE_PRIVATE int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){
-  PgHdr *pPgOld = NULL;               /* The page being overwritten. */
+  PgHdr *pPgOld;               /* The page being overwritten. */
   Pgno needSyncPgno = 0;       /* Old value of pPg->pgno, if sync is required */
-  int rc = 0;                      /* Return code */
-  Pgno origPgno = 0;               /* The original page number */
+  int rc;                      /* Return code */
+  Pgno origPgno;               /* The original page number */
 
   assert( pPg->nRef>0 );
   assert( pPager->eState==PAGER_WRITER_CACHEMOD
@@ -60401,7 +60399,7 @@
     ** it is synced into the journal file. This way, it may end up in
     ** the journal file twice, but that is not a problem.
     */
-    PgHdr *pPgHdr = NULL;
+    PgHdr *pPgHdr;
     rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);
     if( rc!=SQLITE_OK ){
       if( needSyncPgno<=pPager->dbOrigSize ){
@@ -60689,7 +60687,7 @@
 ** is obtained instead, immediately release it.
 */
 static int pagerExclusiveLock(Pager *pPager){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
 
   assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );
   rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);
@@ -61593,7 +61591,7 @@
   /* Enlarge the pWal->apWiData[] array if required */
   if( pWal->nWiData<=iPage ){
     sqlite3_int64 nByte = sizeof(u32*)*(iPage+1);
-    volatile u32 **apNew = NULL;
+    volatile u32 **apNew;
     apNew = (volatile u32 **)sqlite3Realloc((void *)pWal->apWiData, nByte);
     if( !apNew ){
       *ppPage = 0;
@@ -61687,7 +61685,7 @@
   const u32 *aIn,  /* Initial checksum value input */
   u32 *aOut        /* OUT: Final checksum value output */
 ){
-  u32 s1 = 0, s2 = 0;
+  u32 s1, s2;
   u32 *aData = (u32 *)a;
   u32 *aEnd = (u32 *)&a[nByte];
 
@@ -61781,7 +61779,7 @@
   u8 *aData,                      /* Pointer to page data */
   u8 *aFrame                      /* OUT: Write encoded frame here */
 ){
-  int nativeCksum = 0;                /* True for native byte-order checksums */
+  int nativeCksum;                /* True for native byte-order checksums */
   u32 *aCksum = pWal->hdr.aFrameCksum;
   assert( WAL_FRAME_HDRSIZE==24 );
   sqlite3Put4byte(&aFrame[0], iPage);
@@ -61812,9 +61810,9 @@
   u8 *aData,                      /* Pointer to page data (for checksum) */
   u8 *aFrame                      /* Frame data */
 ){
-  int nativeCksum = 0;                /* True for native byte-order checksums */
+  int nativeCksum;                /* True for native byte-order checksums */
   u32 *aCksum = pWal->hdr.aFrameCksum;
-  u32 pgno = 0;                       /* Page number of the frame */
+  u32 pgno;                       /* Page number of the frame */
   assert( WAL_FRAME_HDRSIZE==24 );
 
   /* A frame is only valid if the salt values in the frame-header
@@ -61885,7 +61883,7 @@
 ** In locking_mode=EXCLUSIVE, all of these routines become no-ops.
 */
 static int walLockShared(Wal *pWal, int lockIdx){
-  int rc = 0;
+  int rc;
   if( pWal->exclusiveMode ) return SQLITE_OK;
   rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
                         SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);
@@ -61901,7 +61899,7 @@
   WALTRACE(("WAL%p: release SHARED-%s\n", pWal, walLockName(lockIdx)));
 }
 static int walLockExclusive(Wal *pWal, int lockIdx, int n){
-  int rc = 0;
+  int rc;
   if( pWal->exclusiveMode ) return SQLITE_OK;
   rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                         SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);
@@ -61963,7 +61961,7 @@
   int iHash,                      /* Find the iHash'th table */
   WalHashLoc *pLoc                /* OUT: Hash table location */
 ){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
 
   rc = walIndexPage(pWal, iHash, &pLoc->aPgno);
   assert( rc==SQLITE_OK || iHash>0 );
@@ -62026,8 +62024,8 @@
 static void walCleanupHash(Wal *pWal){
   WalHashLoc sLoc;                /* Hash table location */
   int iLimit = 0;                 /* Zero values greater than this */
-  int nByte = 0;                      /* Number of bytes to zero in aPgno[] */
-  int i = 0;                          /* Used to iterate through aHash[] */
+  int nByte;                      /* Number of bytes to zero in aPgno[] */
+  int i;                          /* Used to iterate through aHash[] */
 
   assert( pWal->writeLock );
   testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE-1 );
@@ -62086,7 +62084,7 @@
 ** pPage into WAL frame iFrame.
 */
 static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
   WalHashLoc sLoc;                /* Wal-index hash table location */
 
   rc = walHashGet(pWal, walFramePage(iFrame), &sLoc);
@@ -62095,9 +62093,9 @@
   ** page number array and hash table entry.
   */
   if( rc==SQLITE_OK ){
-    int iKey = 0;                     /* Hash table key */
-    int idx = 0;                      /* Value to write to hash-table slot */
-    int nCollide = 0;                 /* Number of hash collisions */
+    int iKey;                     /* Hash table key */
+    int idx;                      /* Value to write to hash-table slot */
+    int nCollide;                 /* Number of hash collisions */
 
     idx = iFrame - sLoc.iZero;
     assert( idx <= HASHTABLE_NSLOT/2 + 1 );
@@ -62175,10 +62173,10 @@
 ** the necessary locks, this routine returns SQLITE_BUSY.
 */
 static int walIndexRecover(Wal *pWal){
-  int rc = 0;                         /* Return Code */
-  i64 nSize = 0;                      /* Size of log file */
+  int rc;                         /* Return Code */
+  i64 nSize;                      /* Size of log file */
   u32 aFrameCksum[2] = {0, 0};
-  int iLock = 0;                      /* Lock offset to lock for checkpoint */
+  int iLock;                      /* Lock offset to lock for checkpoint */
 
   /* Obtain an exclusive lock on all byte in the locking range not already
   ** locked by the caller. The caller is guaranteed to have locked the
@@ -62209,14 +62207,14 @@
     u8 aBuf[WAL_HDRSIZE];         /* Buffer to load WAL header into */
     u32 *aPrivate = 0;            /* Heap copy of *-shm hash being populated */
     u8 *aFrame = 0;               /* Malloc'd buffer to load entire frame */
-    int szFrame = 0;                  /* Number of bytes in buffer aFrame[] */
-    u8 *aData = NULL;                    /* Pointer to data part of aFrame buffer */
-    int szPage = 0;                   /* Page size according to the log */
-    u32 magic = 0;                    /* Magic value read from WAL header */
-    u32 version = 0;                  /* Magic value read from WAL header */
-    int isValid = 0;                  /* True if this frame is valid */
-    u32 iPg = 0;                      /* Current 32KB wal-index page */
-    u32 iLastFrame = 0;               /* Last frame in wal, based on nSize alone */
+    int szFrame;                  /* Number of bytes in buffer aFrame[] */
+    u8 *aData;                    /* Pointer to data part of aFrame buffer */
+    int szPage;                   /* Page size according to the log */
+    u32 magic;                    /* Magic value read from WAL header */
+    u32 version;                  /* Magic value read from WAL header */
+    int isValid;                  /* True if this frame is valid */
+    u32 iPg;                      /* Current 32KB wal-index page */
+    u32 iLastFrame;               /* Last frame in wal, based on nSize alone */
 
     /* Read in the WAL header. */
     rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);
@@ -62274,11 +62272,11 @@
     /* Read all frames from the log file. */
     iLastFrame = (nSize - WAL_HDRSIZE) / szFrame;
     for(iPg=0; iPg<=(u32)walFramePage(iLastFrame); iPg++){
-      u32 *aShare = NULL;
-      u32 iFrame = 0;                 /* Index of last frame read */
+      u32 *aShare;
+      u32 iFrame;                 /* Index of last frame read */
       u32 iLast = MIN(iLastFrame, HASHTABLE_NPAGE_ONE+iPg*HASHTABLE_NPAGE);
       u32 iFirst = 1 + (iPg==0?0:HASHTABLE_NPAGE_ONE+(iPg-1)*HASHTABLE_NPAGE);
-      u32 nHdr = 0, nHdr32 = 0;
+      u32 nHdr, nHdr32;
       rc = walIndexPage(pWal, iPg, (volatile u32**)&aShare);
       assert( aShare!=0 || rc!=SQLITE_OK );
       if( aShare==0 ) break;
@@ -62286,8 +62284,8 @@
 
       for(iFrame=iFirst; iFrame<=iLast; iFrame++){
         i64 iOffset = walFrameOffset(iFrame, szPage);
-        u32 pgno = 0;                 /* Database page number for frame */
-        u32 nTruncate = 0;            /* dbsize field from frame header */
+        u32 pgno;                 /* Database page number for frame */
+        u32 nTruncate;            /* dbsize field from frame header */
 
         /* Read and decode the next log frame. */
         rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
@@ -62347,8 +62345,8 @@
 
 finished:
   if( rc==SQLITE_OK ){
-    volatile WalCkptInfo *pInfo = NULL;
-    int i = 0;
+    volatile WalCkptInfo *pInfo;
+    int i;
     pWal->hdr.aFrameCksum[0] = aFrameCksum[0];
     pWal->hdr.aFrameCksum[1] = aFrameCksum[1];
     walIndexWriteHdr(pWal);
@@ -62399,7 +62397,7 @@
 */
 static void walIndexClose(Wal *pWal, int isDelete){
   if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE || pWal->bShmUnreliable ){
-    int i = 0;
+    int i;
     for(i=0; i<pWal->nWiData; i++){
       sqlite3_free((void *)pWal->apWiData[i]);
       pWal->apWiData[i] = 0;
@@ -62433,9 +62431,9 @@
   i64 mxWalSize,                  /* Truncate WAL to this size on reset */
   Wal **ppWal                     /* OUT: Allocated Wal handle */
 ){
-  int rc = 0;                         /* Return Code */
-  Wal *pRet = NULL;                      /* Object to allocate and return */
-  int flags = 0;                      /* Flags passed to OsOpen() */
+  int rc;                         /* Return Code */
+  Wal *pRet;                      /* Object to allocate and return */
+  int flags;                      /* Flags passed to OsOpen() */
 
   assert( zWalName && zWalName[0] );
   assert( pDbFd );
@@ -62547,9 +62545,9 @@
   u32 *piPage,                  /* OUT: The page number of the next page */
   u32 *piFrame                  /* OUT: Wal frame index of next page */
 ){
-  u32 iMin = 0;                     /* Result pgno must be greater than iMin */
+  u32 iMin;                     /* Result pgno must be greater than iMin */
   u32 iRet = 0xFFFFFFFF;        /* 0xffffffff is never a valid page number */
-  int i = 0;                        /* For looping through segments */
+  int i;                        /* For looping through segments */
 
   iMin = p->iPrior;
   assert( iMin<0xffffffff );
@@ -62611,8 +62609,8 @@
 
   assert( nLeft>0 && nRight>0 );
   while( iRight<nRight || iLeft<nLeft ){
-    ht_slot logpage = 0;
-    Pgno dbpage = 0;
+    ht_slot logpage;
+    Pgno dbpage;
 
     if( (iLeft<nLeft)
      && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])
@@ -62666,7 +62664,7 @@
   const int nList = *pnList;      /* Size of input list */
   int nMerge = 0;                 /* Number of elements in list aMerge */
   ht_slot *aMerge = 0;            /* List to be merged */
-  int iList = 0;                      /* Index into input list */
+  int iList;                      /* Index into input list */
   u32 iSub = 0;                   /* Index into aSub array */
   struct Sublist aSub[13];        /* Array of sub-lists */
 
@@ -62678,7 +62676,7 @@
     nMerge = 1;
     aMerge = &aList[iList];
     for(iSub=0; iList & (1<<iSub); iSub++){
-      struct Sublist *p = NULL;
+      struct Sublist *p;
       assert( iSub<ArraySize(aSub) );
       p = &aSub[iSub];
       assert( p->aList && p->nList<=(1<<iSub) );
@@ -62691,7 +62689,7 @@
 
   for(iSub++; iSub<ArraySize(aSub); iSub++){
     if( nList & (1<<iSub) ){
-      struct Sublist *p = NULL;
+      struct Sublist *p;
       assert( iSub<ArraySize(aSub) );
       p = &aSub[iSub];
       assert( p->nList<=(1<<iSub) );
@@ -62733,12 +62731,12 @@
 ** WalIterator object when it has finished with it.
 */
 static int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){
-  WalIterator *p = NULL;                 /* Return value */
-  int nSegment = 0;                   /* Number of segments to merge */
-  u32 iLast = 0;                      /* Last frame in log */
-  sqlite3_int64 nByte = 0;            /* Number of bytes to allocate */
-  int i = 0;                          /* Iterator variable */
-  ht_slot *aTmp = NULL;                  /* Temp space used by merge-sort */
+  WalIterator *p;                 /* Return value */
+  int nSegment;                   /* Number of segments to merge */
+  u32 iLast;                      /* Last frame in log */
+  sqlite3_int64 nByte;            /* Number of bytes to allocate */
+  int i;                          /* Iterator variable */
+  ht_slot *aTmp;                  /* Temp space used by merge-sort */
   int rc = SQLITE_OK;             /* Return Code */
 
   /* This routine only runs while holding the checkpoint lock. And
@@ -62774,9 +62772,9 @@
 
     rc = walHashGet(pWal, i, &sLoc);
     if( rc==SQLITE_OK ){
-      int j = 0;                      /* Counter variable */
-      int nEntry = 0;                 /* Number of entries in this segment */
-      ht_slot *aIndex = NULL;            /* Sorted index for this segment */
+      int j;                      /* Counter variable */
+      int nEntry;                 /* Number of entries in this segment */
+      ht_slot *aIndex;            /* Sorted index for this segment */
 
       if( (i+1)==nSegment ){
         nEntry = (int)(iLast - sLoc.iZero);
@@ -62902,7 +62900,7 @@
   int lockIdx,                    /* Offset of first byte to lock */
   int n                           /* Number of bytes to lock */
 ){
-  int rc = 0;
+  int rc;
   do {
     rc = walLockExclusive(pWal, lockIdx, n);
   }while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );
@@ -62942,7 +62940,7 @@
 */
 static void walRestartHdr(Wal *pWal, u32 salt1){
   volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
-  int i = 0;                          /* Loop counter */
+  int i;                          /* Loop counter */
   u32 *aSalt = pWal->hdr.aSalt;   /* Big-endian salt values */
   pWal->nCkpt++;
   pWal->hdr.mxFrame = 0;
@@ -62997,14 +62995,14 @@
   u8 *zBuf                        /* Temporary buffer to use */
 ){
   int rc = SQLITE_OK;             /* Return code */
-  int szPage = 0;                     /* Database page-size */
+  int szPage;                     /* Database page-size */
   WalIterator *pIter = 0;         /* Wal iterator context */
   u32 iDbpage = 0;                /* Next database page to write */
   u32 iFrame = 0;                 /* Wal frame containing data for iDbpage */
-  u32 mxSafeFrame = 0;                /* Max frame that can be backfilled */
-  u32 mxPage = 0;                     /* Max database page to write */
-  int i = 0;                          /* Loop counter */
-  volatile WalCkptInfo *pInfo = NULL;    /* The checkpoint status information */
+  u32 mxSafeFrame;                /* Max frame that can be backfilled */
+  u32 mxPage;                     /* Max database page to write */
+  int i;                          /* Loop counter */
+  volatile WalCkptInfo *pInfo;    /* The checkpoint status information */
 
   szPage = walPagesize(pWal);
   testcase( szPage<=32768 );
@@ -63062,7 +63060,7 @@
       */
       if( rc==SQLITE_OK ){
         i64 nReq = ((i64)mxPage * szPage);
-        i64 nSize = 0;                    /* Current size of database file */
+        i64 nSize;                    /* Current size of database file */
         sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_CKPT_START, 0);
         rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);
         if( rc==SQLITE_OK && nSize<nReq ){
@@ -63081,7 +63079,7 @@
 
       /* Iterate through the contents of the WAL, copying data to the db file */
       while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){
-        i64 iOffset = 0;
+        i64 iOffset;
         assert( walFramePgno(pWal, iFrame)==iDbpage );
         if( AtomicLoad(&db->u1.isInterrupted) ){
           rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;
@@ -63137,7 +63135,7 @@
     if( pInfo->nBackfill<pWal->hdr.mxFrame ){
       rc = SQLITE_BUSY;
     }else if( eMode>=SQLITE_CHECKPOINT_RESTART ){
-      u32 salt1 = 0;
+      u32 salt1;
       sqlite3_randomness(4, &salt1);
       assert( pInfo->nBackfill==pWal->hdr.mxFrame );
       rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);
@@ -63174,8 +63172,8 @@
 ** it to exactly nMax bytes. If an error occurs while doing so, ignore it.
 */
 static void walLimitSize(Wal *pWal, i64 nMax){
-  i64 sz = 0;
-  int rx = 0;
+  i64 sz;
+  int rx;
   sqlite3BeginBenignMalloc();
   rx = sqlite3OsFileSize(pWal->pWalFd, &sz);
   if( rx==SQLITE_OK && (sz > nMax ) ){
@@ -63274,7 +63272,7 @@
 static SQLITE_NO_TSAN int walIndexTryHdr(Wal *pWal, int *pChanged){
   u32 aCksum[2];                  /* Checksum on the header content */
   WalIndexHdr h1, h2;             /* Two copies of the header content */
-  WalIndexHdr volatile *aHdr = NULL;     /* Header in shared memory */
+  WalIndexHdr volatile *aHdr;     /* Header in shared memory */
 
   /* The first page of the wal-index must be mapped at this point. */
   assert( pWal->nWiData>0 && pWal->apWiData[0] );
@@ -63342,9 +63340,9 @@
 ** Otherwise an SQLite error code.
 */
 static int walIndexReadHdr(Wal *pWal, int *pChanged){
-  int rc = 0;                         /* Return code */
-  int badHdr = 0;                     /* True if a header read failed */
-  volatile u32 *page0 = NULL;            /* Chunk of wal-index containing header */
+  int rc;                         /* Return code */
+  int badHdr;                     /* True if a header read failed */
+  volatile u32 *page0;            /* Chunk of wal-index containing header */
 
   /* Ensure that page 0 of the wal-index (the page that contains the
   ** wal-index header) is mapped. Return early if an error occurs here.
@@ -63466,14 +63464,14 @@
 ** If an error occurs, an SQLite error code is returned.
 */
 static int walBeginShmUnreliable(Wal *pWal, int *pChanged){
-  i64 szWal = 0;                      /* Size of wal file on disk in bytes */
-  i64 iOffset = 0;                    /* Current offset when reading wal file */
+  i64 szWal;                      /* Size of wal file on disk in bytes */
+  i64 iOffset;                    /* Current offset when reading wal file */
   u8 aBuf[WAL_HDRSIZE];           /* Buffer to load WAL header into */
   u8 *aFrame = 0;                 /* Malloc'd buffer to load entire frame */
-  int szFrame = 0;                    /* Number of bytes in buffer aFrame[] */
-  u8 *aData = NULL;                      /* Pointer to data part of aFrame buffer */
-  volatile void *pDummy = NULL;          /* Dummy argument for xShmMap */
-  int rc = 0;                         /* Return code */
+  int szFrame;                    /* Number of bytes in buffer aFrame[] */
+  u8 *aData;                      /* Pointer to data part of aFrame buffer */
+  volatile void *pDummy;          /* Dummy argument for xShmMap */
+  int rc;                         /* Return code */
   u32 aSaveCksum[2];              /* Saved copy of pWal->hdr.aFrameCksum */
 
   assert( pWal->bShmUnreliable );
@@ -63578,8 +63576,8 @@
       iOffset+szFrame<=szWal;
       iOffset+=szFrame
   ){
-    u32 pgno = 0;                   /* Database page number for frame */
-    u32 nTruncate = 0;              /* dbsize field from frame header */
+    u32 pgno;                   /* Database page number for frame */
+    u32 nTruncate;              /* dbsize field from frame header */
 
     /* Read and decode the next log frame. */
     rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
@@ -63600,7 +63598,7 @@
  begin_unreliable_shm_out:
   sqlite3_free(aFrame);
   if( rc!=SQLITE_OK ){
-    int i = 0;
+    int i;
     for(i=0; i<pWal->nWiData; i++){
       sqlite3_free((void*)pWal->apWiData[i]);
       pWal->apWiData[i] = 0;
@@ -63663,12 +63661,12 @@
 ** WAL_READ_LOCK() while changing values.
 */
 static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){
-  volatile WalCkptInfo *pInfo = NULL;    /* Checkpoint information in wal-index */
-  u32 mxReadMark = 0;                 /* Largest aReadMark[] value */
-  int mxI = 0;                        /* Index of largest aReadMark[] value */
-  int i = 0;                          /* Loop counter */
+  volatile WalCkptInfo *pInfo;    /* Checkpoint information in wal-index */
+  u32 mxReadMark;                 /* Largest aReadMark[] value */
+  int mxI;                        /* Index of largest aReadMark[] value */
+  int i;                          /* Loop counter */
   int rc = SQLITE_OK;             /* Return code  */
-  u32 mxFrame = 0;                    /* Wal frame to lock to */
+  u32 mxFrame;                    /* Wal frame to lock to */
 
   assert( pWal->readLock<0 );     /* Not currently locked */
 
@@ -63964,7 +63962,7 @@
 ** needs to be flushed.
 */
 SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
   int cnt = 0;                    /* Number of TryBeginRead attempts */
 #ifdef SQLITE_ENABLE_SNAPSHOT
   int bChanged = 0;
@@ -64094,8 +64092,8 @@
 ){
   u32 iRead = 0;                  /* If !=0, WAL frame to return data from */
   u32 iLast = pWal->hdr.mxFrame;  /* Last page in WAL for this reader */
-  int iHash = 0;                      /* Used to loop through N hash tables */
-  int iMinHash = 0;
+  int iHash;                      /* Used to loop through N hash tables */
+  int iMinHash;
 
   /* This routine is only be called from within a read transaction. */
   assert( pWal->readLock>=0 || pWal->lockError );
@@ -64139,10 +64137,10 @@
   iMinHash = walFramePage(pWal->minFrame);
   for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){
     WalHashLoc sLoc;              /* Hash table location */
-    int iKey = 0;                     /* Hash slot index */
-    int nCollide = 0;                 /* Number of hash collisions remaining */
-    int rc = 0;                       /* Error code */
-    u32 iH = 0;
+    int iKey;                     /* Hash slot index */
+    int nCollide;                 /* Number of hash collisions remaining */
+    int rc;                       /* Error code */
+    u32 iH;
 
     rc = walHashGet(pWal, iHash, &sLoc);
     if( rc!=SQLITE_OK ){
@@ -64197,8 +64195,8 @@
   int nOut,                       /* Size of buffer pOut in bytes */
   u8 *pOut                        /* Buffer to write page data to */
 ){
-  int sz = 0;
-  i64 iOffset = 0;
+  int sz;
+  i64 iOffset;
   sz = pWal->hdr.szPage;
   sz = (sz&0xfe00) + ((sz&0x0001)<<16);
   testcase( sz<=32768 );
@@ -64233,7 +64231,7 @@
 ** There can only be a single writer active at a time.
 */
 SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal){
-  int rc = 0;
+  int rc;
 
 #ifdef SQLITE_ENABLE_SETLK_TIMEOUT
   /* If the write-lock is already held, then it was obtained before the
@@ -64306,7 +64304,7 @@
   int rc = SQLITE_OK;
   if( ALWAYS(pWal->writeLock) ){
     Pgno iMax = pWal->hdr.mxFrame;
-    Pgno iFrame = 0;
+    Pgno iFrame;
 
     /* Restore the clients cache of the wal-index header to the state it
     ** was in before the client began writing to the database.
@@ -64395,13 +64393,13 @@
 */
 static int walRestartLog(Wal *pWal){
   int rc = SQLITE_OK;
-  int cnt = 0;
+  int cnt;
 
   if( pWal->readLock==0 ){
     volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
     assert( pInfo->nBackfill==pWal->hdr.mxFrame );
     if( pInfo->nBackfill>0 ){
-      u32 salt1 = 0;
+      u32 salt1;
       sqlite3_randomness(4, &salt1);
       rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);
       if( rc==SQLITE_OK ){
@@ -64424,7 +64422,7 @@
     pWal->readLock = -1;
     cnt = 0;
     do{
-      int notUsed = 0;
+      int notUsed;
       rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);
     }while( rc==WAL_RETRY );
     assert( (rc&0xff)!=SQLITE_BUSY ); /* BUSY not possible when useWal==1 */
@@ -64462,7 +64460,7 @@
   int iAmt,                  /* Number of bytes to write */
   sqlite3_int64 iOffset      /* Start writing at this offset */
 ){
-  int rc = 0;
+  int rc;
   if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){
     int iFirstAmt = (int)(p->iSyncPoint - iOffset);
     rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);
@@ -64487,8 +64485,8 @@
   int nTruncate,              /* The commit flag.  Usually 0.  >0 for commit */
   sqlite3_int64 iOffset       /* Byte offset at which to write */
 ){
-  int rc = 0;                         /* Result code from subfunctions */
-  void *pData = NULL;                    /* Data actually written */
+  int rc;                         /* Result code from subfunctions */
+  void *pData;                    /* Data actually written */
   u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-header in */
   pData = pPage->pData;
   walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);
@@ -64510,10 +64508,10 @@
 static int walRewriteChecksums(Wal *pWal, u32 iLast){
   const int szPage = pWal->szPage;/* Database page size */
   int rc = SQLITE_OK;             /* Return code */
-  u8 *aBuf = NULL;                       /* Buffer to load data from wal file into */
+  u8 *aBuf;                       /* Buffer to load data from wal file into */
   u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-headers in */
-  u32 iRead = 0;                      /* Next frame to read from wal file */
-  i64 iCksumOff = 0;
+  u32 iRead;                      /* Next frame to read from wal file */
+  i64 iCksumOff;
 
   aBuf = sqlite3_malloc(szPage + WAL_FRAME_HDRSIZE);
   if( aBuf==0 ) return SQLITE_NOMEM_BKPT;
@@ -64539,7 +64537,7 @@
     i64 iOff = walFrameOffset(iRead, szPage);
     rc = sqlite3OsRead(pWal->pWalFd, aBuf, szPage+WAL_FRAME_HDRSIZE, iOff);
     if( rc==SQLITE_OK ){
-      u32 iPgno = 0, nDbSize = 0;
+      u32 iPgno, nDbSize;
       iPgno = sqlite3Get4byte(aBuf);
       nDbSize = sqlite3Get4byte(&aBuf[4]);
 
@@ -64564,16 +64562,16 @@
   int isCommit,                   /* True if this is a commit */
   int sync_flags                  /* Flags to pass to OsSync() (or 0) */
 ){
-  int rc = 0;                         /* Used to catch return codes */
-  u32 iFrame = 0;                     /* Next frame address */
-  PgHdr *p = NULL;                       /* Iterator to run through pList with. */
+  int rc;                         /* Used to catch return codes */
+  u32 iFrame;                     /* Next frame address */
+  PgHdr *p;                       /* Iterator to run through pList with. */
   PgHdr *pLast = 0;               /* Last frame in list */
   int nExtra = 0;                 /* Number of extra copies of last page */
-  int szFrame = 0;                    /* The size of a single frame */
-  i64 iOffset = 0;                    /* Next byte to write in WAL file */
+  int szFrame;                    /* The size of a single frame */
+  i64 iOffset;                    /* Next byte to write in WAL file */
   WalWriter w;                    /* The writer */
   u32 iFirst = 0;                 /* First frame that may be overwritten */
-  WalIndexHdr *pLive = NULL;             /* Pointer to shared header */
+  WalIndexHdr *pLive;             /* Pointer to shared header */
 
   assert( pList );
   assert( pWal->writeLock );
@@ -64657,7 +64655,7 @@
 
   /* Write all frames into the log file exactly once */
   for(p=pList; p; p=p->pDirty){
-    int nDbSize = 0;   /* 0 normally.  Positive == commit flag */
+    int nDbSize;   /* 0 normally.  Positive == commit flag */
 
     /* Check if this page has already been written into the wal file by
     ** the current transaction. If so, overwrite the existing frame and
@@ -64669,7 +64667,7 @@
       assert( rc==SQLITE_OK || iWrite==0 );
       if( iWrite>=iFirst ){
         i64 iOff = walFrameOffset(iWrite, szPage) + WAL_FRAME_HDRSIZE;
-        void *pData = NULL;
+        void *pData;
         if( pWal->iReCksum==0 || iWrite<pWal->iReCksum ){
           pWal->iReCksum = iWrite;
         }
@@ -64806,7 +64804,7 @@
   int *pnLog,                     /* OUT: Number of frames in WAL */
   int *pnCkpt                     /* OUT: Number of backfilled frames in WAL */
 ){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
   int isChanged = 0;              /* True if a new wal-index header is loaded */
   int eMode2 = eMode;             /* Mode to pass to walCheckpoint() */
   int (*xBusy2)(void*) = xBusy;   /* Busy handler for eMode2 */
@@ -64953,7 +64951,7 @@
 ** the op==1 case.
 */
 SQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op){
-  int rc = 0;
+  int rc;
   assert( pWal->writeLock==0 );
   assert( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE || op==-1 );
 
@@ -65951,7 +65949,7 @@
 ** in the common case.
 */
 static void SQLITE_NOINLINE btreeLockCarefully(Btree *p){
-  Btree *pLater = NULL;
+  Btree *pLater;
 
   /* In most cases, we should be able to acquire the lock we
   ** want without having to go through the ascending lock
@@ -66032,9 +66030,9 @@
 ** at the same instant.
 */
 static void SQLITE_NOINLINE btreeEnterAll(sqlite3 *db){
-  int i = 0;
+  int i;
   int skipOk = 1;
-  Btree *p = NULL;
+  Btree *p;
   assert( sqlite3_mutex_held(db->mutex) );
   for(i=0; i<db->nDb; i++){
     p = db->aDb[i].pBt;
@@ -66049,8 +66047,8 @@
   if( db->noSharedCache==0 ) btreeEnterAll(db);
 }
 static void SQLITE_NOINLINE btreeLeaveAll(sqlite3 *db){
-  int i = 0;
-  Btree *p = NULL;
+  int i;
+  Btree *p;
   assert( sqlite3_mutex_held(db->mutex) );
   for(i=0; i<db->nDb; i++){
     p = db->aDb[i].pBt;
@@ -66446,7 +66444,7 @@
 */
 static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){
   BtShared *pBt = p->pBt;
-  BtLock *pIter = NULL;
+  BtLock *pIter;
 
   assert( sqlite3BtreeHoldsMutex(p) );
   assert( eLock==READ_LOCK || eLock==WRITE_LOCK );
@@ -66519,7 +66517,7 @@
 static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){
   BtShared *pBt = p->pBt;
   BtLock *pLock = 0;
-  BtLock *pIter = NULL;
+  BtLock *pIter;
 
   assert( sqlite3BtreeHoldsMutex(p) );
   assert( eLock==READ_LOCK || eLock==WRITE_LOCK );
@@ -66627,7 +66625,7 @@
 static void downgradeAllSharedCacheTableLocks(Btree *p){
   BtShared *pBt = p->pBt;
   if( pBt->pWriter==p ){
-    BtLock *pLock = NULL;
+    BtLock *pLock;
     pBt->pWriter = 0;
     pBt->btsFlags &= ~(BTS_EXCLUSIVE|BTS_PENDING);
     for(pLock=pBt->pLock; pLock; pLock=pLock->pNext){
@@ -66678,7 +66676,7 @@
 ** on the shared btree structure pBt.
 */
 static void invalidateAllOverflowCache(BtShared *pBt){
-  BtCursor *p = NULL;
+  BtCursor *p;
   assert( sqlite3_mutex_held(pBt->mutex) );
   for(p=pBt->pCursor; p; p=p->pNext){
     invalidateOverflowCache(p);
@@ -66705,7 +66703,7 @@
   i64 iRow,               /* The rowid that might be changing */
   int isClearTable        /* True if all rows are being deleted */
 ){
-  BtCursor *p = NULL;
+  BtCursor *p;
   assert( pBtree->hasIncrblobCur );
   assert( sqlite3BtreeHoldsMutex(pBtree) );
   pBtree->hasIncrblobCur = 0;
@@ -66799,7 +66797,7 @@
 ** Release all of the apPage[] pages for a cursor.
 */
 static void btreeReleaseAllCursorPages(BtCursor *pCur){
-  int i = 0;
+  int i;
   if( pCur->iPage>=0 ){
     for(i=0; i<pCur->iPage; i++){
       releasePageNotNull(pCur->apPage[i]);
@@ -66838,7 +66836,7 @@
     ** up to the size of 1 varint plus 1 8-byte value when the cursor
     ** position is restored. Hence the 17 bytes of padding allocated
     ** below. */
-    void *pKey = NULL;
+    void *pKey;
     pCur->nKey = sqlite3BtreePayloadSize(pCur);
     pKey = sqlite3Malloc( pCur->nKey + 9 + 8 );
     if( pKey ){
@@ -66865,7 +66863,7 @@
 ** prior to calling this routine.
 */
 static int saveCursorPosition(BtCursor *pCur){
-  int rc = 0;
+  int rc;
 
   assert( CURSOR_VALID==pCur->eState || CURSOR_SKIPNEXT==pCur->eState );
   assert( 0==pCur->pKey );
@@ -66915,7 +66913,7 @@
 ** event that cursors are in need to being saved.
 */
 static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){
-  BtCursor *p = NULL;
+  BtCursor *p;
   assert( sqlite3_mutex_held(pBt->mutex) );
   assert( pExcept==0 || pExcept->pBt==pBt );
   for(p=pBt->pCursor; p; p=p->pNext){
@@ -66975,8 +66973,8 @@
   int bias,           /* Bias search to the high end */
   int *pRes           /* Write search results here */
 ){
-  int rc = 0;                    /* Status code */
-  UnpackedRecord *pIdxKey = NULL;   /* Unpacked index key */
+  int rc;                    /* Status code */
+  UnpackedRecord *pIdxKey;   /* Unpacked index key */
 
   if( pKey ){
     KeyInfo *pKeyInfo = pCur->pKeyInfo;
@@ -67005,7 +67003,7 @@
 ** saveCursorPosition().
 */
 static int btreeRestoreCursorPosition(BtCursor *pCur){
-  int rc = 0;
+  int rc;
   int skipNext = 0;
   assert( cursorOwnsBtShared(pCur) );
   assert( pCur->eState>=CURSOR_REQUIRESEEK );
@@ -67080,7 +67078,7 @@
 ** TRUE from sqlite3BtreeCursorHasMoved().
 */
 SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){
-  int rc = 0;
+  int rc;
 
   assert( pCur!=0 );
   assert( pCur->eState!=CURSOR_VALID );
@@ -67128,8 +67126,8 @@
 ** requires that ptrmapPageno(*,1)!=1.
 */
 static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){
-  int nPagesPerMapPage = 0;
-  Pgno iPtrMap = 0, ret = 0;
+  int nPagesPerMapPage;
+  Pgno iPtrMap, ret;
   assert( sqlite3_mutex_held(pBt->mutex) );
   if( pgno<2 ) return 0;
   nPagesPerMapPage = (pBt->usableSize/5)+1;
@@ -67152,11 +67150,11 @@
 ** into *pRC.
 */
 static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC){
-  DbPage *pDbPage = NULL;  /* The pointer map page */
-  u8 *pPtrmap = NULL;      /* The pointer map data */
-  Pgno iPtrmap = 0;     /* The pointer map page number */
-  int offset = 0;       /* Offset in pointer map page */
-  int rc = 0;           /* Return code from subfunctions */
+  DbPage *pDbPage;  /* The pointer map page */
+  u8 *pPtrmap;      /* The pointer map data */
+  Pgno iPtrmap;     /* The pointer map page number */
+  int offset;       /* Offset in pointer map page */
+  int rc;           /* Return code from subfunctions */
 
   if( *pRC ) return;
 
@@ -67211,11 +67209,11 @@
 ** An error code is returned if something goes wrong, otherwise SQLITE_OK.
 */
 static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){
-  DbPage *pDbPage = NULL;   /* The pointer map page */
-  int iPtrmap = 0;       /* Pointer map page index */
-  u8 *pPtrmap = NULL;       /* Pointer map page data */
-  int offset = 0;        /* Offset of entry in pointer map */
-  int rc = 0;
+  DbPage *pDbPage;   /* The pointer map page */
+  int iPtrmap;       /* Pointer map page index */
+  u8 *pPtrmap;       /* Pointer map page data */
+  int offset;        /* Offset of entry in pointer map */
+  int rc;
 
   assert( sqlite3_mutex_held(pBt->mutex) );
 
@@ -67283,9 +67281,9 @@
   ** Warning:  changing the way overflow payload is distributed in any
   ** way will result in an incompatible file format.
   */
-  int minLocal = 0;  /* Minimum amount of payload held locally */
-  int maxLocal = 0;  /* Maximum amount of payload held locally */
-  int surplus = 0;   /* Overflow payload available for local storage */
+  int minLocal;  /* Minimum amount of payload held locally */
+  int maxLocal;  /* Maximum amount of payload held locally */
+  int surplus;   /* Overflow payload available for local storage */
 
   minLocal = pPage->minLocal;
   maxLocal = pPage->maxLocal;
@@ -67305,13 +67303,13 @@
 ** page pPage, return the number of bytes of payload stored locally.
 */
 static int btreePayloadToLocal(MemPage *pPage, i64 nPayload){
-  int maxLocal = 0;  /* Maximum amount of payload held locally */
+  int maxLocal;  /* Maximum amount of payload held locally */
   maxLocal = pPage->maxLocal;
   if( nPayload<=maxLocal ){
     return nPayload;
   }else{
-    int minLocal = 0;  /* Minimum amount of payload held locally */
-    int surplus = 0;   /* Overflow payload available for local storage */
+    int minLocal;  /* Minimum amount of payload held locally */
+    int surplus;   /* Overflow payload available for local storage */
     minLocal = pPage->minLocal;
     surplus = minLocal + (nPayload - minLocal)%(pPage->pBt->usableSize-4);
     return ( surplus <= maxLocal ) ? surplus : minLocal;
@@ -67354,9 +67352,9 @@
   u8 *pCell,              /* Pointer to the cell text. */
   CellInfo *pInfo         /* Fill in this structure */
 ){
-  u8 *pIter = NULL;              /* For scanning through pCell */
-  u32 nPayload = 0;           /* Number of bytes of cell payload */
-  u64 iKey = 0;               /* Extracted Key value */
+  u8 *pIter;              /* For scanning through pCell */
+  u32 nPayload;           /* Number of bytes of cell payload */
+  u64 iKey;               /* Extracted Key value */
 
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
   assert( pPage->leaf==0 || pPage->leaf==1 );
@@ -67389,7 +67387,7 @@
   */
   iKey = *pIter;
   if( iKey>=0x80 ){
-    u8 x = 0;
+    u8 x;
     iKey = ((iKey&0x7f)<<7) | ((x = *++pIter) & 0x7f);
     if( x>=0x80 ){
       iKey = (iKey<<7) | ((x =*++pIter) & 0x7f);
@@ -67436,8 +67434,8 @@
   u8 *pCell,              /* Pointer to the cell text. */
   CellInfo *pInfo         /* Fill in this structure */
 ){
-  u8 *pIter = NULL;              /* For scanning through pCell */
-  u32 nPayload = 0;           /* Number of bytes of cell payload */
+  u8 *pIter;              /* For scanning through pCell */
+  u32 nPayload;           /* Number of bytes of cell payload */
 
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
   assert( pPage->leaf==0 || pPage->leaf==1 );
@@ -67490,8 +67488,8 @@
 */
 static u16 cellSizePtr(MemPage *pPage, u8 *pCell){
   u8 *pIter = pCell + pPage->childPtrSize; /* For looping over bytes of pCell */
-  u8 *pEnd = NULL;                                /* End mark for a varint */
-  u32 nSize = 0;                               /* Size value to return */
+  u8 *pEnd;                                /* End mark for a varint */
+  u32 nSize;                               /* Size value to return */
 
 #ifdef SQLITE_DEBUG
   /* The value returned by this function should always be the same as
@@ -67538,7 +67536,7 @@
 }
 static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell){
   u8 *pIter = pCell + 4; /* For looping over bytes of pCell */
-  u8 *pEnd = NULL;              /* End mark for a varint */
+  u8 *pEnd;              /* End mark for a varint */
 
 #ifdef SQLITE_DEBUG
   /* The value returned by this function should always be the same as
@@ -67580,7 +67578,7 @@
   assert( pCell!=0 );
   pPage->xParseCell(pPage, pCell, &info);
   if( info.nLocal<info.nPayload ){
-    Pgno ovfl = 0;
+    Pgno ovfl;
     if( SQLITE_WITHIN(pSrc->aDataEnd, pCell, pCell+info.nLocal) ){
       testcase( pSrc!=pPage );
       *pRC = SQLITE_CORRUPT_BKPT;
@@ -67606,20 +67604,20 @@
 ** cells are packed tightly at the end of the page.
 */
 static int defragmentPage(MemPage *pPage, int nMaxFrag){
-  int i = 0;                     /* Loop counter */
-  int pc = 0;                    /* Address of the i-th cell */
-  int hdr = 0;                   /* Offset to the page header */
-  int size = 0;                  /* Size of a cell */
-  int usableSize = 0;            /* Number of usable bytes on a page */
-  int cellOffset = 0;            /* Offset to the cell pointer array */
-  int cbrk = 0;                  /* Offset to the cell content area */
-  int nCell = 0;                 /* Number of cells on the page */
-  unsigned char *data = NULL;       /* The page data */
-  unsigned char *temp = NULL;       /* Temp area for cell content */
-  unsigned char *src = NULL;        /* Source of content */
-  int iCellFirst = 0;            /* First allowable cell index */
-  int iCellLast = 0;             /* Last possible cell index */
-  int iCellStart = 0;            /* First cell offset in input */
+  int i;                     /* Loop counter */
+  int pc;                    /* Address of the i-th cell */
+  int hdr;                   /* Offset to the page header */
+  int size;                  /* Size of a cell */
+  int usableSize;            /* Number of usable bytes on a page */
+  int cellOffset;            /* Offset to the cell pointer array */
+  int cbrk;                  /* Offset to the cell content area */
+  int nCell;                 /* Number of cells on the page */
+  unsigned char *data;       /* The page data */
+  unsigned char *temp;       /* Temp area for cell content */
+  unsigned char *src;        /* Source of content */
+  int iCellFirst;            /* First allowable cell index */
+  int iCellLast;             /* Last possible cell index */
+  int iCellStart;            /* First cell offset in input */
 
   assert( sqlite3PagerIswriteable(pPage->pDbPage) );
   assert( pPage->pBt!=0 );
@@ -67648,7 +67646,7 @@
       if( iFree2>usableSize-4 ) return SQLITE_CORRUPT_PAGE(pPage);
       if( 0==iFree2 || (data[iFree2]==0 && data[iFree2+1]==0) ){
         u8 *pEnd = &data[cellOffset + nCell*2];
-        u8 *pAddr = NULL;
+        u8 *pAddr;
         int sz2 = 0;
         int sz = get2byte(&data[iFree+2]);
         int top = get2byte(&data[hdr+5]);
@@ -67682,7 +67680,7 @@
   iCellLast = usableSize - 4;
   iCellStart = get2byte(&data[hdr+5]);
   for(i=0; i<nCell; i++){
-    u8 *pAddr = NULL;     /* The i-th cell pointer */
+    u8 *pAddr;     /* The i-th cell pointer */
     pAddr = &data[cellOffset + i*2];
     pc = get2byte(pAddr);
     testcase( pc==iCellFirst );
@@ -67746,9 +67744,9 @@
   u8 * const aData = pPg->aData;             /* Page data */
   int iAddr = hdr + 1;                       /* Address of ptr to pc */
   int pc = get2byte(&aData[iAddr]);          /* Address of a free slot */
-  int x = 0;                                     /* Excess size of the slot */
+  int x;                                     /* Excess size of the slot */
   int maxPC = pPg->pBt->usableSize - nByte;  /* Max address for a usable slot */
-  int size = 0;                                  /* Size of the free slot */
+  int size;                                  /* Size of the free slot */
 
   assert( pc>0 );
   while( pc<=maxPC ){
@@ -67814,9 +67812,9 @@
 static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){
   const int hdr = pPage->hdrOffset;    /* Local cache of pPage->hdrOffset */
   u8 * const data = pPage->aData;      /* Local cache of pPage->aData */
-  int top = 0;                             /* First byte of cell content area */
+  int top;                             /* First byte of cell content area */
   int rc = SQLITE_OK;                  /* Integer return code */
-  int gap = 0;        /* First byte of gap between cell pointers and cell content */
+  int gap;        /* First byte of gap between cell pointers and cell content */
 
   assert( sqlite3PagerIswriteable(pPage->pDbPage) );
   assert( pPage->pBt );
@@ -67854,7 +67852,7 @@
   if( (data[hdr+2] || data[hdr+1]) && gap+2<=top ){
     u8 *pSpace = pageFindSlot(pPage, nByte, &rc);
     if( pSpace ){
-      int g2 = 0;
+      int g2;
       assert( pSpace+nByte<=data+pPage->pBt->usableSize );
       *pIdx = g2 = (int)(pSpace-data);
       if( g2<=gap ){
@@ -67908,12 +67906,12 @@
 ** routine and return SQLITE_CORRUPT if any problems are found.
 */
 static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){
-  u16 iPtr = 0;                             /* Address of ptr to next freeblock */
-  u16 iFreeBlk = 0;                         /* Address of the next freeblock */
-  u8 hdr = 0;                               /* Page header size.  0 or 100 */
+  u16 iPtr;                             /* Address of ptr to next freeblock */
+  u16 iFreeBlk;                         /* Address of the next freeblock */
+  u8 hdr;                               /* Page header size.  0 or 100 */
   u8 nFrag = 0;                         /* Reduction in fragmentation */
   u16 iOrigSize = iSize;                /* Original value of iSize */
-  u16 x = 0;                                /* Offset to cell content area */
+  u16 x;                                /* Offset to cell content area */
   u32 iEnd = iStart + iSize;            /* First byte past the iStart buffer */
   unsigned char *data = pPage->aData;   /* Page content */
 
@@ -68015,7 +68013,7 @@
 **         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF
 */
 static int decodeFlags(MemPage *pPage, int flagByte){
-  BtShared *pBt = NULL;     /* A copy of pPage->pBt */
+  BtShared *pBt;     /* A copy of pPage->pBt */
 
   assert( pPage->hdrOffset==(pPage->pgno==1 ? 100 : 0) );
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
@@ -68068,14 +68066,14 @@
 ** in the pPage->nFree field.
 */
 static int btreeComputeFreeSpace(MemPage *pPage){
-  int pc = 0;            /* Address of a freeblock within pPage->aData[] */
-  u8 hdr = 0;            /* Offset to beginning of page header */
-  u8 *data = NULL;          /* Equal to pPage->aData */
-  int usableSize = 0;    /* Amount of usable space on each page */
-  int nFree = 0;         /* Number of unused bytes on the page */
-  int top = 0;           /* First byte of the cell content area */
-  int iCellFirst = 0;    /* First allowable cell or freeblock offset */
-  int iCellLast = 0;     /* Last possible cell or freeblock offset */
+  int pc;            /* Address of a freeblock within pPage->aData[] */
+  u8 hdr;            /* Offset to beginning of page header */
+  u8 *data;          /* Equal to pPage->aData */
+  int usableSize;    /* Amount of usable space on each page */
+  int nFree;         /* Number of unused bytes on the page */
+  int top;           /* First byte of the cell content area */
+  int iCellFirst;    /* First allowable cell or freeblock offset */
+  int iCellLast;     /* Last possible cell or freeblock offset */
 
   assert( pPage->pBt!=0 );
   assert( pPage->pBt->db!=0 );
@@ -68103,7 +68101,7 @@
   pc = get2byte(&data[hdr+1]);
   nFree = data[hdr+7] + top;  /* Init nFree to non-freeblock free space */
   if( pc>0 ){
-    u32 next = 0, size = 0;
+    u32 next, size;
     if( pc<top ){
       /* EVIDENCE-OF: R-55530-52930 In a well-formed b-tree page, there will
       ** always be at least one cell before the first freeblock.
@@ -68150,14 +68148,14 @@
 ** PRAGMA cell_size_check=ON
 */
 static SQLITE_NOINLINE int btreeCellSizeCheck(MemPage *pPage){
-  int iCellFirst = 0;    /* First allowable cell or freeblock offset */
-  int iCellLast = 0;     /* Last possible cell or freeblock offset */
-  int i = 0;             /* Index into the cell pointer array */
-  int sz = 0;            /* Size of a cell */
-  int pc = 0;            /* Address of a freeblock within pPage->aData[] */
-  u8 *data = NULL;          /* Equal to pPage->aData */
-  int usableSize = 0;    /* Maximum usable space on the page */
-  int cellOffset = 0;    /* Start of cell content area */
+  int iCellFirst;    /* First allowable cell or freeblock offset */
+  int iCellLast;     /* Last possible cell or freeblock offset */
+  int i;             /* Index into the cell pointer array */
+  int sz;            /* Size of a cell */
+  int pc;            /* Address of a freeblock within pPage->aData[] */
+  u8 *data;          /* Equal to pPage->aData */
+  int usableSize;    /* Maximum usable space on the page */
+  int cellOffset;    /* Start of cell content area */
 
   iCellFirst = pPage->cellOffset + 2*pPage->nCell;
   usableSize = pPage->pBt->usableSize;
@@ -68191,8 +68189,8 @@
 ** we failed to detect any corruption.
 */
 static int btreeInitPage(MemPage *pPage){
-  u8 *data = NULL;          /* Equal to pPage->aData */
-  BtShared *pBt = NULL;        /* The main btree structure */
+  u8 *data;          /* Equal to pPage->aData */
+  BtShared *pBt;        /* The main btree structure */
 
   assert( pPage->pBt!=0 );
   assert( pPage->pBt->db!=0 );
@@ -68247,7 +68245,7 @@
   unsigned char *data = pPage->aData;
   BtShared *pBt = pPage->pBt;
   u8 hdr = pPage->hdrOffset;
-  u16 first = 0;
+  u16 first;
 
   assert( sqlite3PagerPagenumber(pPage->pDbPage)==pPage->pgno || CORRUPT_DB );
   assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );
@@ -68310,8 +68308,8 @@
   MemPage **ppPage,    /* Return the page in this parameter */
   int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */
 ){
-  int rc = 0;
-  DbPage *pDbPage = NULL;
+  int rc;
+  DbPage *pDbPage;
 
   assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );
   assert( sqlite3_mutex_held(pBt->mutex) );
@@ -68327,7 +68325,7 @@
 ** MemPage.aData elements if needed.
 */
 static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){
-  DbPage *pDbPage = NULL;
+  DbPage *pDbPage;
   assert( sqlite3_mutex_held(pBt->mutex) );
   pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
   if( pDbPage ){
@@ -68368,8 +68366,8 @@
   BtCursor *pCur,                 /* Cursor to receive the page, or NULL */
   int bReadOnly                   /* True for a read-only page */
 ){
-  int rc = 0;
-  DbPage *pDbPage = NULL;
+  int rc;
+  DbPage *pDbPage;
   assert( sqlite3_mutex_held(pBt->mutex) );
   assert( pCur==0 || ppPage==&pCur->pPage );
   assert( pCur==0 || bReadOnly==pCur->curPagerFlags );
@@ -68482,7 +68480,7 @@
 ** page to agree with the restored data.
 */
 static void pageReinit(DbPage *pData){
-  MemPage *pPage = NULL;
+  MemPage *pPage;
   pPage = (MemPage *)sqlite3PagerGetExtra(pData);
   assert( sqlite3PagerPageRefcount(pData)>0 );
   if( pPage->isInit ){
@@ -68540,10 +68538,10 @@
   int vfsFlags            /* Flags passed through to sqlite3_vfs.xOpen() */
 ){
   BtShared *pBt = 0;             /* Shared part of btree structure */
-  Btree *p = NULL;                      /* Handle to return */
+  Btree *p;                      /* Handle to return */
   sqlite3_mutex *mutexOpen = 0;  /* Prevents a race condition. Ticket #3537 */
   int rc = SQLITE_OK;            /* Result code from this function */
-  u8 nReserve = 0;                   /* Byte of unused space on each page */
+  u8 nReserve;                   /* Byte of unused space on each page */
   unsigned char zDbHeader[100];  /* Database header content */
 
   /* True if opening an ephemeral, temporary database */
@@ -68630,7 +68628,7 @@
         assert( pBt->nRef>0 );
         if( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0))
                  && sqlite3PagerVfs(pBt->pPager)==pVfs ){
-          int iDb = 0;
+          int iDb;
           for(iDb=db->nDb-1; iDb>=0; iDb--){
             Btree *pExisting = db->aDb[iDb].pBt;
             if( pExisting && pExisting->pBt==pBt ){
@@ -68764,8 +68762,8 @@
   ** The list is kept in ascending order by pBt address.
   */
   if( p->sharable ){
-    int i = 0;
-    Btree *pSib = NULL;
+    int i;
+    Btree *pSib;
     for(i=0; i<db->nDb; i++){
       if( (pSib = db->aDb[i].pBt)!=0 && pSib->sharable ){
         while( pSib->pPrev ){ pSib = pSib->pPrev; }
@@ -68800,7 +68798,7 @@
     sqlite3_free(p);
     *ppBtree = 0;
   }else{
-    sqlite3_file *pFile = NULL;
+    sqlite3_file *pFile;
 
     /* If the B-Tree was successfully opened, set the pager-cache size to the
     ** default value. Except, when opening on an existing shared pager-cache,
@@ -68832,7 +68830,7 @@
 static int removeFromSharingList(BtShared *pBt){
 #ifndef SQLITE_OMIT_SHARED_CACHE
   MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )
-  BtShared *pList = NULL;
+  BtShared *pList;
   int removed = 0;
 
   assert( sqlite3_mutex_notheld(pBt->mutex) );
@@ -69003,7 +69001,7 @@
 */
 SQLITE_PRIVATE int sqlite3BtreeSetSpillSize(Btree *p, int mxPage){
   BtShared *pBt = p->pBt;
-  int res = 0;
+  int res;
   assert( sqlite3_mutex_held(p->db->mutex) );
   sqlite3BtreeEnter(p);
   res = sqlite3PagerSetSpillsize(pBt->pPager, mxPage);
@@ -69070,7 +69068,7 @@
 */
 SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){
   int rc = SQLITE_OK;
-  int x = 0;
+  int x;
   BtShared *pBt = p->pBt;
   assert( nReserve>=0 && nReserve<=255 );
   sqlite3BtreeEnter(p);
@@ -69116,7 +69114,7 @@
 ** database handle that owns *p, causing undefined behavior.
 */
 SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p){
-  int n = 0;
+  int n;
   assert( sqlite3_mutex_held(p->pBt->mutex) );
   n = p->pBt->pageSize - p->pBt->usableSize;
   return n;
@@ -69132,7 +69130,7 @@
 ** The amount of reserve can only grow - never shrink.
 */
 SQLITE_PRIVATE int sqlite3BtreeGetRequestedReserve(Btree *p){
-  int n1 = 0, n2 = 0;
+  int n1, n2;
   sqlite3BtreeEnter(p);
   n1 = (int)p->pBt->nReserveWanted;
   n2 = sqlite3BtreeGetReserveNoMutex(p);
@@ -69147,7 +69145,7 @@
 ** Regardless of the value of mxPage, return the maximum page count.
 */
 SQLITE_PRIVATE Pgno sqlite3BtreeMaxPageCount(Btree *p, Pgno mxPage){
-  Pgno n = 0;
+  Pgno n;
   sqlite3BtreeEnter(p);
   n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage);
   sqlite3BtreeLeave(p);
@@ -69173,7 +69171,7 @@
 ** the amount of disk I/O.
 */
 SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree *p, int newFlag){
-  int b = 0;
+  int b;
   if( p==0 ) return 0;
   sqlite3BtreeEnter(p);
   assert( BTS_OVERWRITE==BTS_SECURE_DELETE*2 );
@@ -69221,7 +69219,7 @@
 #ifdef SQLITE_OMIT_AUTOVACUUM
   return BTREE_AUTOVACUUM_NONE;
 #else
-  int rc = 0;
+  int rc;
   sqlite3BtreeEnter(p);
   rc = (
     (!p->pBt->autoVacuum)?BTREE_AUTOVACUUM_NONE:
@@ -69274,9 +69272,9 @@
 ** is returned if we run out of memory.
 */
 static int lockBtree(BtShared *pBt){
-  int rc = 0;              /* Result code from subfunctions */
-  MemPage *pPage1 = NULL;     /* Page 1 of the database file */
-  u32 nPage = 0;           /* Number of pages in the database */
+  int rc;              /* Result code from subfunctions */
+  MemPage *pPage1;     /* Page 1 of the database file */
+  u32 nPage;           /* Number of pages in the database */
   u32 nPageFile = 0;   /* Number of pages in the database file */
 
   assert( sqlite3_mutex_held(pBt->mutex) );
@@ -69298,8 +69296,8 @@
     nPage = 0;
   }
   if( nPage>0 ){
-    u32 pageSize = 0;
-    u32 usableSize = 0;
+    u32 pageSize;
+    u32 usableSize;
     u8 *page1 = pPage1->aData;
     rc = SQLITE_NOTADB;
     /* EVIDENCE-OF: R-43737-39999 Every valid SQLite database file begins
@@ -69501,9 +69499,9 @@
 ** the database.
 */
 static int newDatabase(BtShared *pBt){
-  MemPage *pP1 = NULL;
-  unsigned char *data = NULL;
-  int rc = 0;
+  MemPage *pP1;
+  unsigned char *data;
+  int rc;
 
   assert( sqlite3_mutex_held(pBt->mutex) );
   if( pBt->nPage>0 ){
@@ -69545,7 +69543,7 @@
 ** if successful, or an SQLite error code otherwise.
 */
 SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p){
-  int rc = 0;
+  int rc;
   sqlite3BtreeEnter(p);
   p->pBt->nPage = 0;
   rc = newDatabase(p->pBt);
@@ -69629,7 +69627,7 @@
     ){
       pBlock = pBt->pWriter->db;
     }else if( wrflag>1 ){
-      BtLock *pIter = NULL;
+      BtLock *pIter;
       for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
         if( pIter->pBtree!=p ){
           pBlock = pIter->pBtree->db;
@@ -69769,9 +69767,9 @@
 ** map entries for the overflow pages as well.
 */
 static int setChildPtrmaps(MemPage *pPage){
-  int i = 0;                             /* Counter variable */
-  int nCell = 0;                         /* Number of cells in page pPage */
-  int rc = 0;                            /* Return code */
+  int i;                             /* Counter variable */
+  int nCell;                         /* Number of cells in page pPage */
+  int rc;                            /* Return code */
   BtShared *pBt = pPage->pBt;
   Pgno pgno = pPage->pgno;
 
@@ -69823,9 +69821,9 @@
     }
     put4byte(pPage->aData, iTo);
   }else{
-    int i = 0;
-    int nCell = 0;
-    int rc = 0;
+    int i;
+    int nCell;
+    int rc;
 
     rc = pPage->isInit ? SQLITE_OK : btreeInitPage(pPage);
     if( rc ) return rc;
@@ -69882,10 +69880,10 @@
   Pgno iFreePage,          /* The location to move pDbPage to */
   int isCommit             /* isCommit flag passed to sqlite3PagerMovepage */
 ){
-  MemPage *pPtrPage = NULL;   /* The page that contains a pointer to pDbPage */
+  MemPage *pPtrPage;   /* The page that contains a pointer to pDbPage */
   Pgno iDbPage = pDbPage->pgno;
   Pager *pPager = pBt->pPager;
-  int rc = 0;
+  int rc;
 
   assert( eType==PTRMAP_OVERFLOW2 || eType==PTRMAP_OVERFLOW1 ||
       eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE );
@@ -69969,15 +69967,15 @@
 ** operation, or false for an incremental vacuum.
 */
 static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){
-  Pgno nFreeList = 0;           /* Number of pages still on the free-list */
-  int rc = 0;
+  Pgno nFreeList;           /* Number of pages still on the free-list */
+  int rc;
 
   assert( sqlite3_mutex_held(pBt->mutex) );
   assert( iLastPg>nFin );
 
   if( !PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg!=PENDING_BYTE_PAGE(pBt) ){
-    u8 eType = 0;
-    Pgno iPtrPage = 0;
+    u8 eType;
+    Pgno iPtrPage;
 
     nFreeList = get4byte(&pBt->pPage1->aData[36]);
     if( nFreeList==0 ){
@@ -69999,8 +69997,8 @@
         ** truncated to zero after this function returns, so it doesn't
         ** matter if it still contains some garbage entries.
         */
-        Pgno iFreePg = 0;
-        MemPage *pFreePg = NULL;
+        Pgno iFreePg;
+        MemPage *pFreePg;
         rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, BTALLOC_EXACT);
         if( rc!=SQLITE_OK ){
           return rc;
@@ -70009,8 +70007,8 @@
         releasePage(pFreePg);
       }
     } else {
-      Pgno iFreePg = 0;             /* Index of free page to move pLastPg to */
-      MemPage *pLastPg = NULL;
+      Pgno iFreePg;             /* Index of free page to move pLastPg to */
+      MemPage *pLastPg;
       u8 eMode = BTALLOC_ANY;   /* Mode parameter for allocateBtreePage() */
       Pgno iNear = 0;           /* nearby parameter for allocateBtreePage() */
 
@@ -70031,7 +70029,7 @@
         iNear = nFin;
       }
       do {
-        MemPage *pFreePg = NULL;
+        MemPage *pFreePg;
         rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);
         if( rc!=SQLITE_OK ){
           releasePage(pLastPg);
@@ -70065,9 +70063,9 @@
 ** size of the database in pages following an auto-vacuum operation.
 */
 static Pgno finalDbSize(BtShared *pBt, Pgno nOrig, Pgno nFree){
-  int nEntry = 0;                     /* Number of entries on one ptrmap page */
-  Pgno nPtrmap = 0;                   /* Number of PtrMap pages to be freed */
-  Pgno nFin = 0;                      /* Return value */
+  int nEntry;                     /* Number of entries on one ptrmap page */
+  Pgno nPtrmap;                   /* Number of PtrMap pages to be freed */
+  Pgno nFin;                      /* Return value */
 
   nEntry = pBt->usableSize/5;
   nPtrmap = (nFree-nOrig+PTRMAP_PAGENO(pBt, nOrig)+nEntry)/nEntry;
@@ -70091,7 +70089,7 @@
 ** SQLITE_OK is returned. Otherwise an SQLite error code.
 */
 SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *p){
-  int rc = 0;
+  int rc;
   BtShared *pBt = p->pBt;
 
   sqlite3BtreeEnter(p);
@@ -70129,9 +70127,9 @@
 */
 static int autoVacuumCommit(Btree *p){
   int rc = SQLITE_OK;
-  Pager *pPager = NULL;
-  BtShared *pBt = NULL;
-  sqlite3 *db = NULL;
+  Pager *pPager;
+  BtShared *pBt;
+  sqlite3 *db;
   VVA_ONLY( int nRef );
 
   assert( p!=0 );
@@ -70143,11 +70141,11 @@
   invalidateAllOverflowCache(pBt);
   assert(pBt->autoVacuum);
   if( !pBt->incrVacuum ){
-    Pgno nFin = 0;         /* Number of pages in database after autovacuuming */
-    Pgno nFree = 0;        /* Number of pages on the freelist initially */
-    Pgno nVac = 0;         /* Number of pages to vacuum */
-    Pgno iFree = 0;        /* The next page to be freed */
-    Pgno nOrig = 0;        /* Database size before freeing */
+    Pgno nFin;         /* Number of pages in database after autovacuuming */
+    Pgno nFree;        /* Number of pages on the freelist initially */
+    Pgno nVac;         /* Number of pages to vacuum */
+    Pgno iFree;        /* The next page to be freed */
+    Pgno nOrig;        /* Database size before freeing */
 
     nOrig = btreePagecount(pBt);
     if( PTRMAP_ISPAGE(pBt, nOrig) || nOrig==PENDING_BYTE_PAGE(pBt) ){
@@ -70161,7 +70159,7 @@
     nFree = get4byte(&pBt->pPage1->aData[36]);
     db = p->db;
     if( db->xAutovacPages ){
-      int iDb = 0;
+      int iDb;
       for(iDb=0; ALWAYS(iDb<db->nDb); iDb++){
         if( db->aDb[iDb].pBt==p ) break;
       }
@@ -70337,7 +70335,7 @@
   ** transaction and set the shared state to TRANS_READ.
   */
   if( p->inTrans==TRANS_WRITE ){
-    int rc = 0;
+    int rc;
     BtShared *pBt = p->pBt;
     assert( pBt->inTransaction==TRANS_WRITE );
     assert( pBt->nTransaction>0 );
@@ -70360,7 +70358,7 @@
 ** Do both phases of a commit.
 */
 SQLITE_PRIVATE int sqlite3BtreeCommit(Btree *p){
-  int rc = 0;
+  int rc;
   sqlite3BtreeEnter(p);
   rc = sqlite3BtreeCommitPhaseOne(p, 0);
   if( rc==SQLITE_OK ){
@@ -70397,7 +70395,7 @@
 ** saving a cursor position, an SQLite error code.
 */
 SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode, int writeOnly){
-  BtCursor *p = NULL;
+  BtCursor *p;
   int rc = SQLITE_OK;
 
   assert( (writeOnly==0 || writeOnly==1) && BTCF_WriteFlag==1 );
@@ -70448,9 +70446,9 @@
 ** are no active cursors, it also releases the read lock.
 */
 SQLITE_PRIVATE int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){
-  int rc = 0;
+  int rc;
   BtShared *pBt = p->pBt;
-  MemPage *pPage1 = NULL;
+  MemPage *pPage1;
 
   assert( writeOnly==1 || writeOnly==0 );
   assert( tripCode==SQLITE_ABORT_ROLLBACK || tripCode==SQLITE_OK );
@@ -70469,7 +70467,7 @@
   btreeIntegrity(p);
 
   if( p->inTrans==TRANS_WRITE ){
-    int rc2 = 0;
+    int rc2;
 
     assert( TRANS_WRITE==pBt->inTransaction );
     rc2 = sqlite3PagerRollback(pBt->pPager);
@@ -70513,7 +70511,7 @@
 ** using the sqlite3BtreeSavepoint() function.
 */
 SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
-  int rc = 0;
+  int rc;
   BtShared *pBt = p->pBt;
   sqlite3BtreeEnter(p);
   assert( p->inTrans==TRANS_WRITE );
@@ -70622,7 +70620,7 @@
   BtCursor *pCur                         /* Space for new cursor */
 ){
   BtShared *pBt = p->pBt;                /* Shared b-tree handle */
-  BtCursor *pX = NULL;                          /* Looping over other all cursors */
+  BtCursor *pX;                          /* Looping over other all cursors */
 
   assert( sqlite3BtreeHoldsMutex(p) );
   assert( wrFlag==0
@@ -70688,7 +70686,7 @@
   struct KeyInfo *pKeyInfo,              /* First arg to comparison function */
   BtCursor *pCur                         /* Space for new cursor */
 ){
-  int rc = 0;
+  int rc;
   sqlite3BtreeEnter(p);
   rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
   sqlite3BtreeLeave(p);
@@ -70936,9 +70934,9 @@
   ** number ovfl to determine the next page number.
   */
   if( pBt->autoVacuum ){
-    Pgno pgno = 0;
+    Pgno pgno;
     Pgno iGuess = ovfl+1;
-    u8 eType = 0;
+    u8 eType;
 
     while( PTRMAP_ISPAGE(pBt, iGuess) || iGuess==PENDING_BYTE_PAGE(pBt) ){
       iGuess++;
@@ -71040,7 +71038,7 @@
   unsigned char *pBuf, /* Write the bytes into this buffer */
   int eOp              /* zero to read. non-zero to write. */
 ){
-  unsigned char *aPayload = NULL;
+  unsigned char *aPayload;
   int rc = SQLITE_OK;
   int iIdx = 0;
   MemPage *pPage = pCur->pPage;               /* Btree page of current entry */
@@ -71088,7 +71086,7 @@
 
   if( rc==SQLITE_OK && amt>0 ){
     const u32 ovflSize = pBt->usableSize - 4;  /* Bytes content per ovfl page */
-    Pgno nextPage = 0;
+    Pgno nextPage;
 
     nextPage = get4byte(&aPayload[pCur->info.nLocal]);
 
@@ -71192,7 +71190,7 @@
 #endif
 
         {
-          DbPage *pDbPage = NULL;
+          DbPage *pDbPage;
           rc = sqlite3PagerGet(pBt->pPager, nextPage, &pDbPage,
               (eOp==0 ? PAGER_GET_READONLY : 0)
           );
@@ -71256,7 +71254,7 @@
   u32 amt,
   void *pBuf
 ){
-  int rc = 0;
+  int rc;
   if ( pCur->eState==CURSOR_INVALID ){
     return SQLITE_ABORT;
   }
@@ -71297,7 +71295,7 @@
   BtCursor *pCur,      /* Cursor pointing to entry to read from */
   u32 *pAmt            /* Write the number of available bytes here */
 ){
-  int amt = 0;
+  int amt;
   assert( pCur!=0 && pCur->iPage>=0 && pCur->pPage);
   assert( pCur->eState==CURSOR_VALID );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
@@ -71396,7 +71394,7 @@
 ** the largest cell index.
 */
 static void moveToParent(BtCursor *pCur){
-  MemPage *pLeaf = NULL;
+  MemPage *pLeaf;
   assert( cursorOwnsBtShared(pCur) );
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->iPage>0 );
@@ -71437,7 +71435,7 @@
 ** b-tree).
 */
 static int moveToRoot(BtCursor *pCur){
-  MemPage *pRoot = NULL;
+  MemPage *pRoot;
   int rc = SQLITE_OK;
 
   assert( cursorOwnsBtShared(pCur) );
@@ -71503,7 +71501,7 @@
   if( pRoot->nCell>0 ){
     pCur->eState = CURSOR_VALID;
   }else if( !pRoot->leaf ){
-    Pgno subpage = 0;
+    Pgno subpage;
     if( pRoot->pgno!=1 ) return SQLITE_CORRUPT_BKPT;
     subpage = get4byte(&pRoot->aData[pRoot->hdrOffset+8]);
     pCur->eState = CURSOR_VALID;
@@ -71523,9 +71521,9 @@
 ** in ascending order.
 */
 static int moveToLeftmost(BtCursor *pCur){
-  Pgno pgno = 0;
+  Pgno pgno;
   int rc = SQLITE_OK;
-  MemPage *pPage = NULL;
+  MemPage *pPage;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( pCur->eState==CURSOR_VALID );
@@ -71548,7 +71546,7 @@
 ** key in ascending order.
 */
 static int moveToRightmost(BtCursor *pCur){
-  Pgno pgno = 0;
+  Pgno pgno;
   int rc = SQLITE_OK;
   MemPage *pPage = 0;
 
@@ -71571,7 +71569,7 @@
 ** or set *pRes to 1 if the table is empty.
 */
 SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){
-  int rc = 0;
+  int rc;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
@@ -71593,7 +71591,7 @@
 ** or set *pRes to 1 if the table is empty.
 */
 SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor *pCur, int *pRes){
-  int rc = 0;
+  int rc;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
@@ -71663,7 +71661,7 @@
   int biasRight,           /* If true, bias the search to the high end */
   int *pRes                /* Write search results here */
 ){
-  int rc = 0;
+  int rc;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
@@ -71723,10 +71721,10 @@
   assert( pCur->curIntKey );
 
   for(;;){
-    int lwr = 0, upr = 0, idx = 0, c = 0;
-    Pgno chldPg = 0;
+    int lwr, upr, idx, c;
+    Pgno chldPg;
     MemPage *pPage = pCur->pPage;
-    u8 *pCell = NULL;                          /* Pointer to current cell in pPage */
+    u8 *pCell;                          /* Pointer to current cell in pPage */
 
     /* pPage->nCell must be greater than zero. If this is the root-page
     ** the cursor would have been INVALID above and this for(;;) loop
@@ -71741,7 +71739,7 @@
     assert( biasRight==0 || biasRight==1 );
     idx = upr>>(1-biasRight); /* idx = biasRight ? upr : (lwr+upr)/2; */
     for(;;){
-      i64 nCellKey = 0;
+      i64 nCellKey;
       pCell = findCellPastPtr(pPage, idx);
       if( pPage->intKeyLeaf ){
         while( 0x80 <= *(pCell++) ){
@@ -71830,8 +71828,8 @@
   UnpackedRecord *pIdxKey, /* Unpacked index key */
   int *pRes                /* Write search results here */
 ){
-  int rc = 0;
-  RecordCompare xRecordCompare = 0;
+  int rc;
+  RecordCompare xRecordCompare;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
@@ -71865,10 +71863,10 @@
   assert( pCur->iPage==0 || pCur->apPage[0]->intKey==pCur->curIntKey );
   assert( pCur->curIntKey || pIdxKey );
   for(;;){
-    int lwr = 0, upr = 0, idx = 0, c = 0;
-    Pgno chldPg = 0;
+    int lwr, upr, idx, c;
+    Pgno chldPg;
     MemPage *pPage = pCur->pPage;
-    u8 *pCell = NULL;                          /* Pointer to current cell in pPage */
+    u8 *pCell;                          /* Pointer to current cell in pPage */
 
     /* pPage->nCell must be greater than zero. If this is the root-page
     ** the cursor would have been INVALID above and this for(;;) loop
@@ -71882,7 +71880,7 @@
     upr = pPage->nCell-1;
     idx = upr>>1; /* idx = (lwr+upr)/2; */
     for(;;){
-      int nCell = 0;  /* Size of the pCell cell in bytes */
+      int nCell;  /* Size of the pCell cell in bytes */
       pCell = findCellPastPtr(pPage, idx);
 
       /* The maximum supported page-size is 65536 bytes. This means that
@@ -71917,7 +71915,7 @@
         ** up to two varints past the end of the buffer. An extra 18
         ** bytes of padding is allocated at the end of the buffer in
         ** case this happens.  */
-        void *pCellKey = NULL;
+        void *pCellKey;
         u8 * const pCellBody = pCell - pPage->childPtrSize;
         const int nOverrun = 18;  /* Size of the overrun padding */
         pPage->xParseCell(pPage, pCellBody, &pCur->info);
@@ -72012,8 +72010,8 @@
 ** available.
 */
 SQLITE_PRIVATE i64 sqlite3BtreeRowCountEst(BtCursor *pCur){
-  i64 n = 0;
-  u8 i = 0;
+  i64 n;
+  u8 i;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
@@ -72052,9 +72050,9 @@
 ** this hint, but COMDB2 does.
 */
 static SQLITE_NOINLINE int btreeNext(BtCursor *pCur){
-  int rc = 0;
-  int idx = 0;
-  MemPage *pPage = NULL;
+  int rc;
+  int idx;
+  MemPage *pPage;
 
   assert( cursorOwnsBtShared(pCur) );
   if( pCur->eState!=CURSOR_VALID ){
@@ -72112,7 +72110,7 @@
   }
 }
 SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int flags){
-  MemPage *pPage = NULL;
+  MemPage *pPage;
   UNUSED_PARAMETER( flags );  /* Used in COMDB2 but not native SQLite */
   assert( cursorOwnsBtShared(pCur) );
   assert( flags==0 || flags==1 );
@@ -72152,8 +72150,8 @@
 ** use this hint, but COMDB2 does.
 */
 static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur){
-  int rc = 0;
-  MemPage *pPage = NULL;
+  int rc;
+  MemPage *pPage;
 
   assert( cursorOwnsBtShared(pCur) );
   assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );
@@ -72245,13 +72243,13 @@
   Pgno nearby,           /* Search for a page near this one */
   u8 eMode               /* BTALLOC_EXACT, BTALLOC_LT, or BTALLOC_ANY */
 ){
-  MemPage *pPage1 = NULL;
-  int rc = 0;
-  u32 n = 0;     /* Number of pages on the freelist */
-  u32 k = 0;     /* Number of leaves on the trunk of the freelist */
+  MemPage *pPage1;
+  int rc;
+  u32 n;     /* Number of pages on the freelist */
+  u32 k;     /* Number of leaves on the trunk of the freelist */
   MemPage *pTrunk = 0;
   MemPage *pPrevTrunk = 0;
-  Pgno mxPage = 0;     /* Total size of the database file */
+  Pgno mxPage;     /* Total size of the database file */
 
   assert( sqlite3_mutex_held(pBt->mutex) );
   assert( eMode==BTALLOC_ANY || (nearby>0 && IfNotOmitAV(pBt->autoVacuum)) );
@@ -72266,7 +72264,7 @@
   }
   if( n>0 ){
     /* There are pages on the freelist.  Reuse one of those pages. */
-    Pgno iTrunk = 0;
+    Pgno iTrunk;
     u8 searchList = 0; /* If the free-list must be searched for 'nearby' */
     u32 nSearch = 0;   /* Count of the number of search attempts */
 
@@ -72277,7 +72275,7 @@
 #ifndef SQLITE_OMIT_AUTOVACUUM
     if( eMode==BTALLOC_EXACT ){
       if( nearby<=mxPage ){
-        u8 eType = 0;
+        u8 eType;
         assert( nearby>0 );
         assert( pBt->autoVacuum );
         rc = ptrmapGet(pBt, nearby, &eType, 0);
@@ -72378,7 +72376,7 @@
           ** pointers to free-list leaves. The first leaf becomes a trunk
           ** page in this case.
           */
-          MemPage *pNewTrunk = NULL;
+          MemPage *pNewTrunk;
           Pgno iNewTrunk = get4byte(&pTrunk->aData[8]);
           if( iNewTrunk>mxPage ){
             rc = SQLITE_CORRUPT_PGNO(iTrunk);
@@ -72414,11 +72412,11 @@
 #endif
       }else if( k>0 ){
         /* Extract a leaf from the trunk */
-        u32 closest = 0;
-        Pgno iPage = 0;
+        u32 closest;
+        Pgno iPage;
         unsigned char *aData = pTrunk->aData;
         if( nearby>0 ){
-          u32 i = 0;
+          u32 i;
           closest = 0;
           if( eMode==BTALLOC_LE ){
             for(i=0; i<k; i++){
@@ -72429,7 +72427,7 @@
               }
             }
           }else{
-            int dist = 0;
+            int dist;
             dist = sqlite3AbsInt32(get4byte(&aData[8]) - nearby);
             for(i=1; i<k; i++){
               int d2 = sqlite3AbsInt32(get4byte(&aData[8+i*4]) - nearby);
@@ -72453,7 +72451,7 @@
         if( !searchList
          || (iPage==nearby || (iPage<nearby && eMode==BTALLOC_LE))
         ){
-          int noContent = 0;
+          int noContent;
           *pPgno = iPage;
           TRACE(("ALLOCATE: %d was leaf %d of %d on trunk %d"
                  ": %d more free pages\n",
@@ -72564,9 +72562,9 @@
   MemPage *pTrunk = 0;                /* Free-list trunk page */
   Pgno iTrunk = 0;                    /* Page number of free-list trunk page */
   MemPage *pPage1 = pBt->pPage1;      /* Local reference to page 1 */
-  MemPage *pPage = NULL;                     /* Page being freed. May be NULL. */
-  int rc = 0;                             /* Return Code */
-  u32 nFree = 0;                          /* Initial number of pages on free-list */
+  MemPage *pPage;                     /* Page being freed. May be NULL. */
+  int rc;                             /* Return Code */
+  u32 nFree;                          /* Initial number of pages on free-list */
 
   assert( sqlite3_mutex_held(pBt->mutex) );
   assert( CORRUPT_DB || iPage>1 );
@@ -72616,7 +72614,7 @@
   ** is possible to add the page as a new free-list leaf.
   */
   if( nFree!=0 ){
-    u32 nLeaf = 0;                /* Initial number of leaf cells on trunk page */
+    u32 nLeaf;                /* Initial number of leaf cells on trunk page */
 
     iTrunk = get4byte(&pPage1->aData[32]);
     if( iTrunk>btreePagecount(pBt) ){
@@ -72708,11 +72706,11 @@
   unsigned char *pCell,    /* First byte of the Cell */
   CellInfo *pInfo          /* Size information about the cell */
 ){
-  BtShared *pBt = NULL;
-  Pgno ovflPgno = 0;
-  int rc = 0;
-  int nOvfl = 0;
-  u32 ovflPageSize = 0;
+  BtShared *pBt;
+  Pgno ovflPgno;
+  int rc;
+  int nOvfl;
+  u32 ovflPageSize;
 
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
   assert( pInfo->nLocal!=pInfo->nPayload );
@@ -72804,16 +72802,16 @@
   const BtreePayload *pX,        /* Payload with which to construct the cell */
   int *pnSize                    /* Write cell size here */
 ){
-  int nPayload = 0;
-  const u8 *pSrc = NULL;
-  int nSrc = 0, n = 0, rc = 0, mn = 0;
-  int spaceLeft = 0;
-  MemPage *pToRelease = NULL;
-  unsigned char *pPrior = NULL;
-  unsigned char *pPayload = NULL;
-  BtShared *pBt = NULL;
-  Pgno pgnoOvfl = 0;
-  int nHeader = 0;
+  int nPayload;
+  const u8 *pSrc;
+  int nSrc, n, rc, mn;
+  int spaceLeft;
+  MemPage *pToRelease;
+  unsigned char *pPrior;
+  unsigned char *pPayload;
+  BtShared *pBt;
+  Pgno pgnoOvfl;
+  int nHeader;
 
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
 
@@ -72989,11 +72987,11 @@
 ** "sz" must be the number of bytes in the cell.
 */
 static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){
-  u32 pc = 0;         /* Offset to cell content of cell being deleted */
-  u8 *data = NULL;       /* pPage->aData */
-  u8 *ptr = NULL;        /* Used to move bytes around within data[] */
-  int rc = 0;         /* The return code */
-  int hdr = 0;        /* Beginning of the header.  0 most pages.  100 page 1 */
+  u32 pc;         /* Offset to cell content of cell being deleted */
+  u8 *data;       /* pPage->aData */
+  u8 *ptr;        /* Used to move bytes around within data[] */
+  int rc;         /* The return code */
+  int hdr;        /* Beginning of the header.  0 most pages.  100 page 1 */
 
   if( *pRC ) return;
   assert( idx>=0 );
@@ -73062,9 +73060,9 @@
   int *pRC          /* Read and write return code from here */
 ){
   int idx = 0;      /* Where to write new cell content in data[] */
-  int j = 0;            /* Loop counter */
-  u8 *data = NULL;         /* The content of the whole page */
-  u8 *pIns = NULL;         /* The point in pPage->aCellIdx[] where no cell inserted */
+  int j;            /* Loop counter */
+  u8 *data;         /* The content of the whole page */
+  u8 *pIns;         /* The point in pPage->aCellIdx[] where no cell inserted */
 
   assert( *pRC==SQLITE_OK );
   assert( i>=0 && i<=pPage->nCell+pPage->nOverflow );
@@ -73295,13 +73293,13 @@
   const int usableSize = pPg->pBt->usableSize;
   u8 * const pEnd = &aData[usableSize];
   int i = iFirst;                 /* Which cell to copy from pCArray*/
-  u32 j = 0;                          /* Start of cell content area */
+  u32 j;                          /* Start of cell content area */
   int iEnd = i+nCell;             /* Loop terminator */
   u8 *pCellptr = pPg->aCellIdx;
   u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);
-  u8 *pData = NULL;
-  int k = 0;                          /* Current slot in pCArray->apEnd[] */
-  u8 *pSrcEnd = NULL;                    /* Current pCArray->apEnd[k] value */
+  u8 *pData;
+  int k;                          /* Current slot in pCArray->apEnd[] */
+  u8 *pSrcEnd;                    /* Current pCArray->apEnd[k] value */
 
   assert( i<iEnd );
   j = get2byte(&aData[hdr+5]);
@@ -73387,15 +73385,15 @@
   u8 *aData = pPg->aData;         /* Complete page */
   u8 *pData = *ppData;            /* Content area.  A subset of aData[] */
   int iEnd = iFirst + nCell;      /* End of loop. One past last cell to ins */
-  int k = 0;                          /* Current slot in pCArray->apEnd[] */
-  u8 *pEnd = NULL;                       /* Maximum extent of cell data */
+  int k;                          /* Current slot in pCArray->apEnd[] */
+  u8 *pEnd;                       /* Maximum extent of cell data */
   assert( CORRUPT_DB || pPg->hdrOffset==0 );    /* Never called on page 1 */
   if( iEnd<=iFirst ) return 0;
   for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
   pEnd = pCArray->apEnd[k];
   while( 1 /*Exit by break*/ ){
-    int sz = 0, rc = 0;
-    u8 *pSlot = NULL;
+    int sz, rc;
+    u8 *pSlot;
     assert( pCArray->szCell[i]!=0 );
     sz = pCArray->szCell[i];
     if( (aData[1]==0 && aData[2]==0) || (pSlot = pageFindSlot(pPg,sz,&rc))==0 ){
@@ -73449,7 +73447,7 @@
   u8 * const pEnd = &aData[pPg->pBt->usableSize];
   u8 * const pStart = &aData[pPg->hdrOffset + 8 + pPg->childPtrSize];
   int nRet = 0;
-  int i = 0;
+  int i;
   int iEnd = iFirst + nCell;
   u8 *pFree = 0;
   int szFree = 0;
@@ -73457,7 +73455,7 @@
   for(i=iFirst; i<iEnd; i++){
     u8 *pCell = pCArray->apCell[i];
     if( SQLITE_WITHIN(pCell, pStart, pEnd) ){
-      int sz = 0;
+      int sz;
       /* No need to use cachedCellSize() here.  The sizes of all cells that
       ** are to be freed have already been computing while deciding which
       ** cells need freeing */
@@ -73509,9 +73507,9 @@
   const int hdr = pPg->hdrOffset;
   u8 *pBegin = &pPg->aCellIdx[nNew * 2];
   int nCell = pPg->nCell;       /* Cells stored on pPg */
-  u8 *pData = NULL;
-  u8 *pCellptr = NULL;
-  int i = 0;
+  u8 *pData;
+  u8 *pCellptr;
+  int i;
   int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;
   int iNewEnd = iNew + nNew;
 
@@ -73629,9 +73627,9 @@
 */
 static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){
   BtShared *const pBt = pPage->pBt;    /* B-Tree Database */
-  MemPage *pNew = NULL;                       /* Newly allocated page */
-  int rc = 0;                              /* Return Code */
-  Pgno pgnoNew = 0;                        /* Page number of pNew */
+  MemPage *pNew;                       /* Newly allocated page */
+  int rc;                              /* Return Code */
+  Pgno pgnoNew;                        /* Page number of pNew */
 
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
   assert( sqlite3PagerIswriteable(pParent->pDbPage) );
@@ -73652,7 +73650,7 @@
     u8 *pOut = &pSpace[4];
     u8 *pCell = pPage->apOvfl[0];
     u16 szCell = pPage->xCellSize(pPage, pCell);
-    u8 *pStop = NULL;
+    u8 *pStop;
     CellArray b;
 
     assert( sqlite3PagerIswriteable(pNew->pDbPage) );
@@ -73789,8 +73787,8 @@
     u8 * const aTo = pTo->aData;
     int const iFromHdr = pFrom->hdrOffset;
     int const iToHdr = ((pTo->pgno==1) ? 100 : 0);
-    int rc = 0;
-    int iData = 0;
+    int rc;
+    int iData;
 
 
     assert( pFrom->isInit );
@@ -73871,29 +73869,29 @@
   int isRoot,                     /* True if pParent is a root-page */
   int bBulk                       /* True if this call is part of a bulk load */
 ){
-  BtShared *pBt = NULL;               /* The whole database */
+  BtShared *pBt;               /* The whole database */
   int nMaxCells = 0;           /* Allocated size of apCell, szCell, aFrom. */
   int nNew = 0;                /* Number of pages in apNew[] */
-  int nOld = 0;                    /* Number of pages in apOld[] */
-  int i = 0, j = 0, k = 0;                 /* Loop counters */
-  int nxDiv = 0;                   /* Next divider slot in pParent->aCell[] */
+  int nOld;                    /* Number of pages in apOld[] */
+  int i, j, k;                 /* Loop counters */
+  int nxDiv;                   /* Next divider slot in pParent->aCell[] */
   int rc = SQLITE_OK;          /* The return code */
-  u16 leafCorrection = 0;          /* 4 if pPage is a leaf.  0 if not */
-  int leafData = 0;                /* True if pPage is a leaf of a LEAFDATA tree */
-  int usableSpace = 0;             /* Bytes in pPage beyond the header */
-  int pageFlags = 0;               /* Value of pPage->aData[0] */
+  u16 leafCorrection;          /* 4 if pPage is a leaf.  0 if not */
+  int leafData;                /* True if pPage is a leaf of a LEAFDATA tree */
+  int usableSpace;             /* Bytes in pPage beyond the header */
+  int pageFlags;               /* Value of pPage->aData[0] */
   int iSpace1 = 0;             /* First unused byte of aSpace1[] */
   int iOvflSpace = 0;          /* First unused byte of aOvflSpace[] */
-  int szScratch = 0;               /* Size of scratch memory requested */
+  int szScratch;               /* Size of scratch memory requested */
   MemPage *apOld[NB];          /* pPage and up to two siblings */
   MemPage *apNew[NB+2];        /* pPage and up to NB siblings after balancing */
-  u8 *pRight = NULL;                  /* Location in parent of right-sibling pointer */
+  u8 *pRight;                  /* Location in parent of right-sibling pointer */
   u8 *apDiv[NB-1];             /* Divider cells in pParent */
   int cntNew[NB+2];            /* Index in b.paCell[] of cell after i-th page */
   int cntOld[NB+2];            /* Old index in b.apCell[] */
   int szNew[NB+2];             /* Combined size of cells placed on i-th page */
-  u8 *aSpace1 = NULL;                 /* Space for copies of dividers cells */
-  Pgno pgno = 0;                   /* Temp var to store a page number in */
+  u8 *aSpace1;                 /* Space for copies of dividers cells */
+  Pgno pgno;                   /* Temp var to store a page number in */
   u8 abDone[NB+2];             /* True after i'th new page is populated */
   Pgno aPgno[NB+2];            /* Page numbers of new pages before shuffling */
   Pgno aPgOrder[NB+2];         /* Copy of aPgno[] used for sorting pages */
@@ -73992,7 +73990,7 @@
       ** buffer. It will be copied out again as soon as the aSpace[] buffer
       ** is allocated.  */
       if( pBt->btsFlags & BTS_FAST_SECURE ){
-        int iOff = 0;
+        int iOff;
 
         /* If the following if() condition is not true, the db is corrupted.
         ** The call to dropCell() below will detect this.  */
@@ -74053,7 +74051,7 @@
     u8 *aData = pOld->aData;
     u16 maskPage = pOld->maskPage;
     u8 *piCell = aData + pOld->cellOffset;
-    u8 *piEnd = NULL;
+    u8 *piEnd;
     VVA_ONLY( int nCellAtStart = b.nCell; )
 
     /* Verify that all sibling pages are of the same "type" (table-leaf,
@@ -74111,7 +74109,7 @@
     cntOld[i] = b.nCell;
     if( i<nOld-1 && !leafData){
       u16 sz = (u16)szNew[i];
-      u8 *pTemp = NULL;
+      u8 *pTemp;
       assert( b.nCell<nMaxCells );
       b.szCell[b.nCell] = sz;
       pTemp = &aSpace1[iSpace1];
@@ -74181,7 +74179,7 @@
   }
   k = nOld;
   for(i=0; i<k; i++){
-    int sz = 0;
+    int sz;
     while( szNew[i]>usableSpace ){
       if( i+1>=k ){
         k = i+2;
@@ -74237,8 +74235,8 @@
   for(i=k-1; i>0; i--){
     int szRight = szNew[i];  /* Size of sibling on the right */
     int szLeft = szNew[i-1]; /* Size of sibling on the left */
-    int r = 0;              /* Index of right-most cell in left sibling */
-    int d = 0;              /* Index of first cell to the left of right sibling */
+    int r;              /* Index of right-most cell in left sibling */
+    int d;              /* Index of first cell to the left of right sibling */
 
     r = cntNew[i-1] - 1;
     d = r + 1 - leafData;
@@ -74284,7 +74282,7 @@
   */
   pageFlags = apOld[0]->aData[0];
   for(i=0; i<k; i++){
-    MemPage *pNew = NULL;
+    MemPage *pNew;
     if( i<nOld ){
       pNew = apNew[i] = apOld[i];
       apOld[i] = 0;
@@ -74403,7 +74401,7 @@
   ** populated, not here.
   */
   if( ISAUTOVACUUM ){
-    MemPage *pOld = NULL;
+    MemPage *pOld;
     MemPage *pNew = pOld = apNew[0];
     int cntOldNext = pNew->nCell + pNew->nOverflow;
     int iNew = 0;
@@ -74446,10 +74444,10 @@
 
   /* Insert new divider cells into pParent. */
   for(i=0; i<nNew-1; i++){
-    u8 *pCell = NULL;
-    u8 *pTemp = NULL;
-    int sz = 0;
-    u8 *pSrcEnd = NULL;
+    u8 *pCell;
+    u8 *pTemp;
+    int sz;
+    u8 *pSrcEnd;
     MemPage *pNew = apNew[i];
     j = cntNew[i];
 
@@ -74533,9 +74531,9 @@
     if( i>=0                            /* On the upwards pass, or... */
      || cntOld[iPg-1]>=cntNew[iPg-1]    /* Condition (1) is true */
     ){
-      int iNew = 0;
-      int iOld = 0;
-      int nNewCell = 0;
+      int iNew;
+      int iOld;
+      int nNewCell;
 
       /* Verify condition (1):  If cells are moving left, update iPg
       ** only after iPg-1 has already been updated. */
@@ -74662,7 +74660,7 @@
 ** an error code is returned and *ppChild is set to 0.
 */
 static int balance_deeper(MemPage *pRoot, MemPage **ppChild){
-  int rc = 0;                        /* Return value from subprocedures */
+  int rc;                        /* Return value from subprocedures */
   MemPage *pChild = 0;           /* Pointer to a new child page */
   Pgno pgnoChild = 0;            /* Page number of the new child page */
   BtShared *pBt = pRoot->pBt;    /* The BTree */
@@ -74720,7 +74718,7 @@
 ** first SQL table, violating invariants on the first insert.
 */
 static int anotherValidCursor(BtCursor *pCur){
-  BtCursor *pOther = NULL;
+  BtCursor *pOther;
   for(pOther=pCur->pBt->pCursor; pOther; pOther=pOther->pNext){
     if( pOther!=pCur
      && pOther->eState==CURSOR_VALID
@@ -74752,7 +74750,7 @@
   VVA_ONLY( int balance_deeper_called = 0 );
 
   do {
-    int iPage = 0;
+    int iPage;
     MemPage *pPage = pCur->pPage;
 
     if( NEVER(pPage->nFree<0) && btreeComputeFreeSpace(pPage) ) break;
@@ -74878,7 +74876,7 @@
   int nData = pX->nData - iOffset;
   if( nData<=0 ){
     /* Overwritting with zeros */
-    int i = 0;
+    int i;
     for(i=0; i<iAmt && pDest[i]==0; i++){}
     if( i<iAmt ){
       int rc = sqlite3PagerWrite(pPage->pDbPage);
@@ -74912,13 +74910,13 @@
 ** contained in pX.
 */
 static int btreeOverwriteCell(BtCursor *pCur, const BtreePayload *pX){
-  int iOffset = 0;                        /* Next byte of pX->pData to write */
+  int iOffset;                        /* Next byte of pX->pData to write */
   int nTotal = pX->nData + pX->nZero; /* Total bytes of to write */
-  int rc = 0;                             /* Return code */
+  int rc;                             /* Return code */
   MemPage *pPage = pCur->pPage;       /* Page being written */
-  BtShared *pBt = NULL;                      /* Btree */
-  Pgno ovflPgno = 0;                      /* Next overflow page to write */
-  u32 ovflPageSize = 0;                   /* Size to write on overflow page */
+  BtShared *pBt;                      /* Btree */
+  Pgno ovflPgno;                      /* Next overflow page to write */
+  u32 ovflPageSize;                   /* Size to write on overflow page */
 
   if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd
    || pCur->info.pPayload < pPage->aData + pPage->cellOffset
@@ -74996,14 +74994,14 @@
   int flags,                     /* True if this is likely an append */
   int seekResult                 /* Result of prior MovetoUnpacked() call */
 ){
-  int rc = 0;
+  int rc;
   int loc = seekResult;          /* -1: before desired location  +1: after */
   int szNew = 0;
-  int idx = 0;
-  MemPage *pPage = NULL;
+  int idx;
+  MemPage *pPage;
   Btree *p = pCur->pBtree;
   BtShared *pBt = p->pBt;
-  unsigned char *oldCell = NULL;
+  unsigned char *oldCell;
   unsigned char *newCell = 0;
 
   assert( (flags & (BTREE_SAVEPOSITION|BTREE_APPEND|BTREE_PREFORMAT))==flags );
@@ -75302,9 +75300,9 @@
   int rc = SQLITE_OK;
   BtShared *pBt = pDest->pBt;
   u8 *aOut = pBt->pTmpSpace;    /* Pointer to next output buffer */
-  const u8 *aIn = NULL;                /* Pointer to next input buffer */
-  u32 nIn = 0;                      /* Size of input buffer aIn[] */
-  u32 nRem = 0;                     /* Bytes of data still to copy */
+  const u8 *aIn;                /* Pointer to next input buffer */
+  u32 nIn;                      /* Size of input buffer aIn[] */
+  u32 nRem;                     /* Bytes of data still to copy */
 
   getCellInfo(pSrc);
   aOut += putVarint32(aOut, pSrc->info.nPayload);
@@ -75324,7 +75322,7 @@
     Pgno ovflIn = 0;
     DbPage *pPageIn = 0;
     MemPage *pPageOut = 0;
-    u32 nOut = 0;                     /* Size of output buffer aOut[] */
+    u32 nOut;                     /* Size of output buffer aOut[] */
 
     nOut = btreePayloadToLocal(pDest->pPage, pSrc->info.nPayload);
     pBt->nPreformatSize = nOut + (aOut - pBt->pTmpSpace);
@@ -75366,7 +75364,7 @@
       }while( rc==SQLITE_OK && nOut>0 );
 
       if( rc==SQLITE_OK && nRem>0 && ALWAYS(pPgnoOut) ){
-        Pgno pgnoNew = 0;
+        Pgno pgnoNew;
         MemPage *pNew = 0;
         rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);
         put4byte(pPgnoOut, pgnoNew);
@@ -75411,13 +75409,13 @@
 SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){
   Btree *p = pCur->pBtree;
   BtShared *pBt = p->pBt;
-  int rc = 0;                    /* Return code */
-  MemPage *pPage = NULL;            /* Page to delete cell from */
-  unsigned char *pCell = NULL;      /* Pointer to cell to delete */
-  int iCellIdx = 0;              /* Index of cell to delete */
-  int iCellDepth = 0;            /* Depth of node containing pCell */
+  int rc;                    /* Return code */
+  MemPage *pPage;            /* Page to delete cell from */
+  unsigned char *pCell;      /* Pointer to cell to delete */
+  int iCellIdx;              /* Index of cell to delete */
+  int iCellDepth;            /* Depth of node containing pCell */
   CellInfo info;             /* Size of the cell being deleted */
-  u8 bPreserve = 0;              /* Keep cursor valid.  2 for CURSOR_SKIPNEXT */
+  u8 bPreserve;              /* Keep cursor valid.  2 for CURSOR_SKIPNEXT */
 
   assert( cursorOwnsBtShared(pCur) );
   assert( pBt->inTransaction==TRANS_WRITE );
@@ -75521,9 +75519,9 @@
   ** node to replace the deleted cell.  */
   if( !pPage->leaf ){
     MemPage *pLeaf = pCur->pPage;
-    int nCell = 0;
-    Pgno n = 0;
-    unsigned char *pTmp = NULL;
+    int nCell;
+    Pgno n;
+    unsigned char *pTmp;
 
     if( pLeaf->nFree<0 ){
       rc = btreeComputeFreeSpace(pLeaf);
@@ -75611,10 +75609,10 @@
 */
 static int btreeCreateTable(Btree *p, Pgno *piTable, int createTabFlags){
   BtShared *pBt = p->pBt;
-  MemPage *pRoot = NULL;
-  Pgno pgnoRoot = 0;
-  int rc = 0;
-  int ptfFlags = 0;          /* Page-type flage for the root page of new table */
+  MemPage *pRoot;
+  Pgno pgnoRoot;
+  int rc;
+  int ptfFlags;          /* Page-type flage for the root page of new table */
 
   assert( sqlite3BtreeHoldsMutex(p) );
   assert( pBt->inTransaction==TRANS_WRITE );
@@ -75627,8 +75625,8 @@
   }
 #else
   if( pBt->autoVacuum ){
-    Pgno pgnoMove = 0;      /* Move a page here to make room for the root-page */
-    MemPage *pPageMove = NULL; /* The page to move to. */
+    Pgno pgnoMove;      /* Move a page here to make room for the root-page */
+    MemPage *pPageMove; /* The page to move to. */
 
     /* Creating a new table may probably require moving an existing database
     ** to make room for the new tables root page. In case this page turns
@@ -75755,7 +75753,7 @@
   return SQLITE_OK;
 }
 SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree *p, Pgno *piTable, int flags){
-  int rc = 0;
+  int rc;
   sqlite3BtreeEnter(p);
   rc = btreeCreateTable(p, piTable, flags);
   sqlite3BtreeLeave(p);
@@ -75772,11 +75770,11 @@
   int freePageFlag,        /* Deallocate page if true */
   i64 *pnChange            /* Add number of Cells freed to this counter */
 ){
-  MemPage *pPage = NULL;
-  int rc = 0;
-  unsigned char *pCell = NULL;
-  int i = 0;
-  int hdr = 0;
+  MemPage *pPage;
+  int rc;
+  unsigned char *pCell;
+  int i;
+  int hdr;
   CellInfo info;
 
   assert( sqlite3_mutex_held(pBt->mutex) );
@@ -75834,7 +75832,7 @@
 ** is incremented by the number of entries in the table.
 */
 SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree *p, int iTable, i64 *pnChange){
-  int rc = 0;
+  int rc;
   BtShared *pBt = p->pBt;
   sqlite3BtreeEnter(p);
   assert( p->inTrans==TRANS_WRITE );
@@ -75884,7 +75882,7 @@
 ** meta[3] is updated by this procedure.
 */
 static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){
-  int rc = 0;
+  int rc;
   MemPage *pPage = 0;
   BtShared *pBt = p->pBt;
 
@@ -75910,7 +75908,7 @@
   releasePage(pPage);
 #else
   if( pBt->autoVacuum ){
-    Pgno maxRootPgno = 0;
+    Pgno maxRootPgno;
     sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &maxRootPgno);
 
     if( iTable==maxRootPgno ){
@@ -75927,7 +75925,7 @@
       ** number in the database. So move the page that does into the
       ** gap left by the deleted root-page.
       */
-      MemPage *pMove = NULL;
+      MemPage *pMove;
       releasePage(pPage);
       rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
       if( rc!=SQLITE_OK ){
@@ -75969,7 +75967,7 @@
   return rc;
 }
 SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
-  int rc = 0;
+  int rc;
   sqlite3BtreeEnter(p);
   rc = btreeDropTable(p, iTable, piMoved);
   sqlite3BtreeLeave(p);
@@ -76029,8 +76027,8 @@
 */
 SQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){
   BtShared *pBt = p->pBt;
-  unsigned char *pP1 = NULL;
-  int rc = 0;
+  unsigned char *pP1;
+  int rc;
   assert( idx>=1 && idx<=15 );
   sqlite3BtreeEnter(p);
   assert( p->inTrans==TRANS_WRITE );
@@ -76061,7 +76059,7 @@
 */
 SQLITE_PRIVATE int sqlite3BtreeCount(sqlite3 *db, BtCursor *pCur, i64 *pnEntry){
   i64 nEntry = 0;                      /* Value to return in *pnEntry */
-  int rc = 0;                              /* Return code */
+  int rc;                              /* Return code */
 
   rc = moveToRoot(pCur);
   if( rc==SQLITE_EMPTY ){
@@ -76073,8 +76071,8 @@
   ** page in the B-Tree structure (not including overflow pages).
   */
   while( rc==SQLITE_OK && !AtomicLoad(&db->u1.isInterrupted) ){
-    int iIdx = 0;                          /* Index of child node in parent */
-    MemPage *pPage = NULL;                    /* Current page of the b-tree */
+    int iIdx;                          /* Index of child node in parent */
+    MemPage *pPage;                    /* Current page of the b-tree */
 
     /* If this is a leaf page or the tree is not an int-key tree, then
     ** this page contains countable entries. Increment the entry counter
@@ -76214,9 +76212,9 @@
   u8 eType,              /* Expected pointer map type */
   Pgno iParent           /* Expected pointer map parent page number */
 ){
-  int rc = 0;
-  u8 ePtrmapType = 0;
-  Pgno iPtrmapParent = 0;
+  int rc;
+  u8 ePtrmapType;
+  Pgno iPtrmapParent;
 
   rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
   if( rc!=SQLITE_OK ){
@@ -76243,12 +76241,12 @@
   Pgno iPage,           /* Page number for first page in the list */
   u32 N                 /* Expected number of pages in the list */
 ){
-  int i = 0;
+  int i;
   u32 expected = N;
   int nErrAtStart = pCheck->nErr;
   while( iPage!=0 && pCheck->mxErr ){
-    DbPage *pOvflPage = NULL;
-    unsigned char *pOvflData = NULL;
+    DbPage *pOvflPage;
+    unsigned char *pOvflData;
     if( checkRef(pCheck, iPage) ) break;
     N--;
     if( sqlite3PagerGet(pCheck->pPager, (Pgno)iPage, &pOvflPage, 0) ){
@@ -76327,7 +76325,7 @@
 ** lower 16 bits are the index of the last byte of that range.
 */
 static void btreeHeapInsert(u32 *aHeap, u32 x){
-  u32 j = 0, i = ++aHeap[0];
+  u32 j, i = ++aHeap[0];
   aHeap[i] = x;
   while( (j = i/2)>0 && aHeap[j]>aHeap[i] ){
     x = aHeap[j];
@@ -76337,7 +76335,7 @@
   }
 }
 static int btreeHeapPull(u32 *aHeap, u32 *pOut){
-  u32 j = 0, i = 0, x = 0;
+  u32 j, i, x;
   if( (x = aHeap[0])==0 ) return 0;
   *pOut = aHeap[1];
   aHeap[1] = aHeap[x];
@@ -76377,26 +76375,26 @@
   i64 maxKey            /* Error if integer primary key greater than this */
 ){
   MemPage *pPage = 0;      /* The page being analyzed */
-  int i = 0;                   /* Loop counter */
-  int rc = 0;                  /* Result code from subroutine call */
+  int i;                   /* Loop counter */
+  int rc;                  /* Result code from subroutine call */
   int depth = -1, d2;      /* Depth of a subtree */
-  int pgno = 0;                /* Page number */
-  int nFrag = 0;               /* Number of fragmented bytes on the page */
-  int hdr = 0;                 /* Offset to the page header */
-  int cellStart = 0;           /* Offset to the start of the cell pointer array */
-  int nCell = 0;               /* Number of cells */
+  int pgno;                /* Page number */
+  int nFrag;               /* Number of fragmented bytes on the page */
+  int hdr;                 /* Offset to the page header */
+  int cellStart;           /* Offset to the start of the cell pointer array */
+  int nCell;               /* Number of cells */
   int doCoverageCheck = 1; /* True if cell coverage checking should be done */
   int keyCanBeEqual = 1;   /* True if IPK can be equal to maxKey
                            ** False if IPK must be strictly less than maxKey */
-  u8 *data = NULL;                /* Page content */
-  u8 *pCell = NULL;               /* Cell content */
-  u8 *pCellIdx = NULL;            /* Next element of the cell pointer array */
-  BtShared *pBt = NULL;           /* The BtShared object that owns pPage */
-  u32 pc = 0;                  /* Address of a cell */
-  u32 usableSize = 0;          /* Usable size of the page */
-  u32 contentOffset = 0;       /* Offset to the start of the cell content area */
+  u8 *data;                /* Page content */
+  u8 *pCell;               /* Cell content */
+  u8 *pCellIdx;            /* Next element of the cell pointer array */
+  BtShared *pBt;           /* The BtShared object that owns pPage */
+  u32 pc;                  /* Address of a cell */
+  u32 usableSize;          /* Usable size of the page */
+  u32 contentOffset;       /* Offset to the start of the cell content area */
   u32 *heap = 0;           /* Min-heap used for checking cell coverage */
-  u32 x = 0, prev = 0;         /* Next and previous entry on the min-heap */
+  u32 x, prev = 0;         /* Next and previous entry on the min-heap */
   const char *saved_zPfx = pCheck->zPfx;
   int saved_v1 = pCheck->v1;
   int saved_v2 = pCheck->v2;
@@ -76503,8 +76501,8 @@
 
     /* Check the content overflow list */
     if( info.nPayload>info.nLocal ){
-      u32 nPage = 0;       /* Number of pages on the overflow chain */
-      Pgno pgnoOvfl = 0;   /* First page of the overflow chain */
+      u32 nPage;       /* Number of pages on the overflow chain */
+      Pgno pgnoOvfl;   /* First page of the overflow chain */
       assert( pc + info.nSize - 4 <= usableSize );
       nPage = (info.nPayload - info.nLocal + usableSize - 5)/(usableSize - 4);
       pgnoOvfl = get4byte(&pCell[info.nSize - 4]);
@@ -76548,7 +76546,7 @@
       heap = pCheck->heap;
       heap[0] = 0;
       for(i=nCell-1; i>=0; i--){
-        u32 size = 0;
+        u32 size;
         pc = get2byteAligned(&data[cellStart+i*2]);
         size = pPage->xCellSize(pPage, &data[pc]);
         btreeHeapInsert(heap, (pc<<16)|(pc+size-1));
@@ -76562,7 +76560,7 @@
     */
     i = get2byte(&data[hdr+1]);
     while( i>0 ){
-      int size = 0, j = 0;
+      int size, j;
       assert( (u32)i<=usableSize-4 ); /* Enforced by btreeComputeFreeSpace() */
       size = get2byte(&data[i+2]);
       assert( (u32)(i+size)<=usableSize ); /* due to btreeComputeFreeSpace() */
@@ -76657,7 +76655,7 @@
   int mxErr,    /* Stop reporting errors after this many */
   int *pnErr    /* Write number of errors seen to this variable */
 ){
-  Pgno i = 0;
+  Pgno i;
   IntegrityCk sCheck;
   BtShared *pBt = p->pBt;
   u64 savedDbFlags = pBt->db->flags;
@@ -76725,7 +76723,7 @@
   if( !bPartial ){
     if( pBt->autoVacuum ){
       Pgno mx = 0;
-      Pgno mxInHdr = 0;
+      Pgno mxInHdr;
       for(i=0; (int)i<nRoot; i++) if( mx<aRoot[i] ) mx = aRoot[i];
       mxInHdr = get4byte(&pBt->pPage1->aData[52]);
       if( mx!=mxInHdr ){
@@ -76744,7 +76742,7 @@
   testcase( pBt->db->flags & SQLITE_CellSizeCk );
   pBt->db->flags &= ~(u64)SQLITE_CellSizeCk;
   for(i=0; (int)i<nRoot && sCheck.mxErr; i++){
-    i64 notUsed = 0;
+    i64 notUsed;
     if( aRoot[i]==0 ) continue;
 #ifndef SQLITE_OMIT_AUTOVACUUM
     if( pBt->autoVacuum && aRoot[i]>1 && !bPartial ){
@@ -76902,7 +76900,7 @@
 ** sqlite_schema table. Otherwise SQLITE_OK.
 */
 SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *p){
-  int rc = 0;
+  int rc;
   assert( sqlite3_mutex_held(p->db->mutex) );
   sqlite3BtreeEnter(p);
   rc = querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK);
@@ -76949,7 +76947,7 @@
 ** no modifications are made and SQLITE_CORRUPT is returned.
 */
 SQLITE_PRIVATE int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){
-  int rc = 0;
+  int rc;
   assert( cursorOwnsBtShared(pCsr) );
   assert( sqlite3_mutex_held(pCsr->pBtree->db->mutex) );
   assert( pCsr->curFlags & BTCF_Incrblob );
@@ -77009,7 +77007,7 @@
 */
 SQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
   BtShared *pBt = pBtree->pBt;
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
 
   assert( iVersion==1 || iVersion==2 );
 
@@ -77191,7 +77189,7 @@
 ** of the source.
 */
 static int setDestPgsz(sqlite3_backup *p){
-  int rc = 0;
+  int rc;
   rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),0,0);
   return rc;
 }
@@ -77224,7 +77222,7 @@
   sqlite3* pSrcDb,                      /* Database connection to read from */
   const char *zSrcDb                    /* Name of database within pSrcDb */
 ){
-  sqlite3_backup *p = NULL;                    /* Value to return */
+  sqlite3_backup *p;                    /* Value to return */
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(pSrcDb)||!sqlite3SafetyCheckOk(pDestDb) ){
@@ -77316,7 +77314,7 @@
   const int nCopy = MIN(nSrcPgsz, nDestPgsz);
   const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;
   int rc = SQLITE_OK;
-  i64 iOff = 0;
+  i64 iOff;
 
   assert( sqlite3BtreeGetReserveNoMutex(p->pSrc)>=0 );
   assert( p->bDestLocked );
@@ -77374,7 +77372,7 @@
 ** code if an error occurs.
 */
 static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){
-  i64 iCurrent = 0;
+  i64 iCurrent;
   int rc = sqlite3OsFileSize(pFile, &iCurrent);
   if( rc==SQLITE_OK && iCurrent>iSize ){
     rc = sqlite3OsTruncate(pFile, iSize);
@@ -77387,7 +77385,7 @@
 ** callbacks when pages are changed or the cache invalidated.
 */
 static void attachBackupObject(sqlite3_backup *p){
-  sqlite3_backup **pp = NULL;
+  sqlite3_backup **pp;
   assert( sqlite3BtreeHoldsMutex(p->pSrc) );
   pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
   p->pNext = *pp;
@@ -77399,8 +77397,8 @@
 ** Copy nPage pages from the source b-tree to the destination.
 */
 SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage){
-  int rc = 0;
-  int destMode = 0;       /* Destination journal mode */
+  int rc;
+  int destMode;       /* Destination journal mode */
   int pgszSrc = 0;    /* Source page size */
   int pgszDest = 0;   /* Destination page size */
 
@@ -77417,7 +77415,7 @@
   if( !isFatalError(rc) ){
     Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);     /* Source pager */
     Pager * const pDestPager = sqlite3BtreePager(p->pDest);   /* Dest pager */
-    int ii = 0;                            /* Iterator variable */
+    int ii;                            /* Iterator variable */
     int nSrcPage = -1;                 /* Size of source db in pages */
     int bCloseTrans = 0;               /* True if src db requires unlocking */
 
@@ -77474,7 +77472,7 @@
     for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
       const Pgno iSrcPg = p->iNext;                 /* Source page number */
       if( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) ){
-        DbPage *pSrcPg = NULL;                             /* Source page object */
+        DbPage *pSrcPg;                             /* Source page object */
         rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg,PAGER_GET_READONLY);
         if( rc==SQLITE_OK ){
           rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0);
@@ -77515,7 +77513,7 @@
         }
       }
       if( rc==SQLITE_OK ){
-        int nDestTruncate = 0;
+        int nDestTruncate;
         /* Set nDestTruncate to the final number of pages in the destination
         ** database. The complication here is that the destination page
         ** size may be different to the source page size.
@@ -77553,10 +77551,10 @@
           */
           const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;
           sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);
-          Pgno iPg = 0;
-          int nDstPage = 0;
-          i64 iOff = 0;
-          i64 iEnd = 0;
+          Pgno iPg;
+          int nDstPage;
+          i64 iOff;
+          i64 iEnd;
 
           assert( pFile );
           assert( nDestTruncate==0
@@ -77574,7 +77572,7 @@
           sqlite3PagerPagecount(pDestPager, &nDstPage);
           for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
             if( iPg!=PENDING_BYTE_PAGE(p->pDest->pBt) ){
-              DbPage *pPg = NULL;
+              DbPage *pPg;
               rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0);
               if( rc==SQLITE_OK ){
                 rc = sqlite3PagerWrite(pPg);
@@ -77653,9 +77651,9 @@
 ** Release all resources associated with an sqlite3_backup* handle.
 */
 SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p){
-  sqlite3_backup **pp = NULL;                 /* Ptr to head of pagers backup list */
-  sqlite3 *pSrcDb = NULL;                     /* Source database connection */
-  int rc = 0;                              /* Value to return */
+  sqlite3_backup **pp;                 /* Ptr to head of pagers backup list */
+  sqlite3 *pSrcDb;                     /* Source database connection */
+  int rc;                              /* Value to return */
 
   /* Enter the mutexes */
   if( p==0 ) return SQLITE_OK;
@@ -77755,7 +77753,7 @@
       ** has been modified by a transaction on the source pager. Copy
       ** the new data into the backup.
       */
-      int rc = 0;
+      int rc;
       assert( p->pDestDb );
       sqlite3_mutex_enter(p->pDestDb->mutex);
       rc = backupOnePage(p, iPage, aData, 1);
@@ -77783,7 +77781,7 @@
 ** called.
 */
 SQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *pBackup){
-  sqlite3_backup *p = NULL;                   /* Iterator variable */
+  sqlite3_backup *p;                   /* Iterator variable */
   for(p=pBackup; p; p=p->pNext){
     assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );
     p->iNext = 1;
@@ -77800,8 +77798,8 @@
 ** transaction is committed before returning.
 */
 SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){
-  int rc = 0;
-  sqlite3_file *pFd = NULL;              /* File descriptor for database pTo */
+  int rc;
+  sqlite3_file *pFd;              /* File descriptor for database pTo */
   sqlite3_backup b;
   sqlite3BtreeEnter(pTo);
   sqlite3BtreeEnter(pFrom);
@@ -78052,7 +78050,7 @@
 */
 SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){
 #ifndef SQLITE_OMIT_UTF16
-  int rc = 0;
+  int rc;
 #endif
   assert( pMem!=0 );
   assert( !sqlite3VdbeMemIsRowSet(pMem) );
@@ -78215,7 +78213,7 @@
 */
 #ifndef SQLITE_OMIT_INCRBLOB
 SQLITE_PRIVATE int sqlite3VdbeMemExpandBlob(Mem *pMem){
-  int nByte = 0;
+  int nByte;
   assert( pMem!=0 );
   assert( pMem->flags & MEM_Zero );
   assert( (pMem->flags&MEM_Blob)!=0 || MemNullNochng(pMem) );
@@ -78460,7 +78458,7 @@
   return value;
 }
 SQLITE_PRIVATE i64 sqlite3VdbeIntValue(const Mem *pMem){
-  int flags = 0;
+  int flags;
   assert( pMem!=0 );
   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
   assert( EIGHT_BYTE_ALIGNMENT(pMem) );
@@ -78522,7 +78520,7 @@
 ** MEM_Int if we can.
 */
 SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem *pMem){
-  i64 ix = 0;
+  i64 ix;
   assert( pMem!=0 );
   assert( pMem->flags & MEM_Real );
   assert( !sqlite3VdbeMemIsRowSet(pMem) );
@@ -78606,8 +78604,8 @@
   testcase( pMem->flags & MEM_IntReal );
   testcase( pMem->flags & MEM_Null );
   if( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))==0 ){
-    int rc = 0;
-    sqlite3_int64 ix = 0;
+    int rc;
+    sqlite3_int64 ix;
     assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );
     assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
     rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
@@ -78816,7 +78814,7 @@
 */
 SQLITE_PRIVATE int sqlite3VdbeMemSetRowSet(Mem *pMem){
   sqlite3 *db = pMem->db;
-  RowSet *p = NULL;
+  RowSet *p;
   assert( db!=0 );
   assert( !sqlite3VdbeMemIsRowSet(pMem) );
   sqlite3VdbeMemRelease(pMem);
@@ -78966,7 +78964,7 @@
   void (*xDel)(void*) /* Destructor function */
 ){
   i64 nByte = n;      /* New value for pMem->n */
-  int iLimit = 0;         /* Maximum allowed string or blob size */
+  int iLimit;         /* Maximum allowed string or blob size */
   u16 flags = 0;      /* New value for pMem->flags */
 
   assert( pMem!=0 );
@@ -79073,7 +79071,7 @@
   u32 amt,          /* Number of bytes to return. */
   Mem *pMem         /* OUT: Return data in this Mem structure. */
 ){
-  int rc = 0;
+  int rc;
   pMem->flags = MEM_Null;
   if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){
     return SQLITE_CORRUPT_BKPT;
@@ -79380,7 +79378,7 @@
   sqlite3_value **ppVal,          /* Write the new value here */
   struct ValueNewStat4Ctx *pCtx   /* Second argument for valueNew() */
 ){
-  int op = 0;
+  int op;
   char *zVal = 0;
   sqlite3_value *pVal = 0;
   int negInt = 1;
@@ -79398,7 +79396,7 @@
   assert( (pExpr->flags & EP_TokenOnly)==0 || pCtx==0 );
 
   if( op==TK_CAST ){
-    u8 aff = 0;
+    u8 aff;
     assert( !ExprHasProperty(pExpr, EP_IntValue) );
     aff = sqlite3AffinityType(pExpr->u.zToken,0);
     rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
@@ -79472,7 +79470,7 @@
   }
 #ifndef SQLITE_OMIT_BLOB_LITERAL
   else if( op==TK_BLOB ){
-    int nVal = 0;
+    int nVal;
     assert( !ExprHasProperty(pExpr, EP_IntValue) );
     assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );
     assert( pExpr->u.zToken[1]=='\'' );
@@ -79828,7 +79826,7 @@
 */
 SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse *pParse){
   sqlite3 *db = pParse->db;
-  Vdbe *p = NULL;
+  Vdbe *p;
   p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );
   if( p==0 ) return 0;
   memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));
@@ -79922,8 +79920,8 @@
 ** Swap all content between two VDBE structures.
 */
 SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){
-  Vdbe tmp, *pTmp = NULL;
-  char *zTmp = NULL;
+  Vdbe tmp, *pTmp;
+  char *zTmp;
   assert( pA->db==pB->db );
   tmp = *pA;
   *pA = *pB;
@@ -79959,7 +79957,7 @@
 ** correctly deallocated along with the rest of the Vdbe).
 */
 static int growOpArray(Vdbe *v, int nOp){
-  VdbeOp *pNew = NULL;
+  VdbeOp *pNew;
   Parse *p = v->pParse;
 
   /* The SQLITE_TEST_REALLOC_STRESS compile-time option is designed to force
@@ -80036,8 +80034,8 @@
   return sqlite3VdbeAddOp3(p, op, p1, p2, p3);
 }
 SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){
-  int i = 0;
-  VdbeOp *pOp = NULL;
+  int i;
+  VdbeOp *pOp;
 
   i = p->nOp;
   assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
@@ -80110,8 +80108,8 @@
 */
 SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){
   va_list ap;
-  int i = 0;
-  char c = 0;
+  int i;
+  char c;
   va_start(ap, zTypes);
   for(i=0; (c = zTypes[i])!=0; i++){
     if( c=='s' ){
@@ -80165,9 +80163,9 @@
   int eCallCtx          /* Calling context */
 ){
   Vdbe *v = pParse->pVdbe;
-  int nByte = 0;
-  int addr = 0;
-  sqlite3_context *pCtx = NULL;
+  int nByte;
+  int addr;
+  sqlite3_context *pCtx;
   assert( v );
   nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);
   pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);
@@ -80212,7 +80210,7 @@
 ** 0 means "none".
 */
 SQLITE_PRIVATE int sqlite3VdbeExplainParent(Parse *pParse){
-  VdbeOp *pOp = NULL;
+  VdbeOp *pOp;
   if( pParse->addrExplain==0 ) return 0;
   pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);
   return pOp->p2;
@@ -80242,10 +80240,10 @@
   if( pParse->explain==2 )
 #endif
   {
-    char *zMsg = NULL;
-    Vdbe *v = NULL;
+    char *zMsg;
+    Vdbe *v;
     va_list ap;
-    int iThis = 0;
+    int iThis;
     va_start(ap, zFmt);
     zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);
     va_end(ap);
@@ -80278,7 +80276,7 @@
 ** This routine will take ownership of the allocated memory.
 */
 SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere, u16 p5){
-  int j = 0;
+  int j;
   sqlite3VdbeAddOp4(p, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC);
   sqlite3VdbeChangeP5(p, p5);
   for(j=0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);
@@ -80596,7 +80594,7 @@
 */
 static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){
   int nMaxArgs = *pMaxFuncArgs;
-  Op *pOp = NULL;
+  Op *pOp;
   Parse *pParse = p->pParse;
   int *aLabel = pParse->aLabel;
   p->readOnly = 1;
@@ -80657,7 +80655,7 @@
           break;
         }
         case OP_VFilter: {
-          int n = 0;
+          int n;
           assert( (pOp - p->aOp) >= 3 );
           assert( pOp[-1].opcode==OP_Integer );
           n = pOp[-1].p1;
@@ -80779,8 +80777,8 @@
   VdbeOpList const *aOp,       /* The opcodes to be added */
   int iLineno                  /* Source-file line number of first opcode */
 ){
-  int i = 0;
-  VdbeOp *pOut = NULL, *pFirst = NULL;
+  int i;
+  VdbeOp *pOut, *pFirst;
   assert( nOp>0 );
   assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
   if( p->nOp + nOp > p->nOpAlloc && growOpArray(p, nOp) ){
@@ -80975,7 +80973,7 @@
 */
 static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){
   if( aOp ){
-    Op *pOp = NULL;
+    Op *pOp;
     for(pOp=&aOp[nOp-1]; pOp>=aOp; pOp--){
       if( pOp->p4type <= P4_FREE_IF_LE ) freeP4(db, pOp->p4type, pOp->p4.p);
 #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
@@ -81007,7 +81005,7 @@
 ** Change the opcode at addr into OP_Noop
 */
 SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe *p, int addr){
-  VdbeOp *pOp = NULL;
+  VdbeOp *pOp;
   if( p->db->mallocFailed ) return 0;
   assert( addr>=0 && addr<p->nOp );
   pOp = &p->aOp[addr];
@@ -81102,8 +81100,8 @@
   }
 }
 SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){
-  Op *pOp = NULL;
-  sqlite3 *db = NULL;
+  Op *pOp;
+  sqlite3 *db;
   assert( p!=0 );
   db = p->db;
   assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
@@ -81145,7 +81143,7 @@
 ** those cases.
 */
 SQLITE_PRIVATE void sqlite3VdbeAppendP4(Vdbe *p, void *pP4, int n){
-  VdbeOp *pOp = NULL;
+  VdbeOp *pOp;
   assert( n!=P4_INT32 && n!=P4_VTAB );
   assert( n<=0 );
   if( p->db->mallocFailed ){
@@ -81166,7 +81164,7 @@
 */
 SQLITE_PRIVATE void sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){
   Vdbe *v = pParse->pVdbe;
-  KeyInfo *pKeyInfo = NULL;
+  KeyInfo *pKeyInfo;
   assert( v!=0 );
   assert( pIdx!=0 );
   pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
@@ -81441,7 +81439,7 @@
   sqlite3StrAccumInit(&x, 0, 0, 0, SQLITE_MAX_LENGTH);
   switch( pOp->p4type ){
     case P4_KEYINFO: {
-      int j = 0;
+      int j;
       KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;
       assert( pKeyInfo->aSortFlags!=0 );
       sqlite3_str_appendf(&x, "k(%d", pKeyInfo->nKeyField);
@@ -81517,7 +81515,7 @@
     }
 #endif
     case P4_INTARRAY: {
-      u32 i = 0;
+      u32 i;
       u32 *ai = pOp->p4.ai;
       u32 n = ai[0];   /* The first element of an INTARRAY is always the
                        ** count of the number of elements to follow */
@@ -81591,10 +81589,10 @@
 ** be a problem.
 */
 SQLITE_PRIVATE void sqlite3VdbeEnter(Vdbe *p){
-  int i = 0;
-  sqlite3 *db = NULL;
-  Db *aDb = NULL;
-  int nDb = 0;
+  int i;
+  sqlite3 *db;
+  Db *aDb;
+  int nDb;
   if( DbMaskAllZero(p->lockMask) ) return;  /* The common case */
   db = p->db;
   aDb = db->aDb;
@@ -81612,10 +81610,10 @@
 ** Unlock all of the btrees previously locked by a call to sqlite3VdbeEnter().
 */
 static SQLITE_NOINLINE void vdbeLeave(Vdbe *p){
-  int i = 0;
-  sqlite3 *db = NULL;
-  Db *aDb = NULL;
-  int nDb = 0;
+  int i;
+  sqlite3 *db;
+  Db *aDb;
+  int nDb;
   db = p->db;
   aDb = db->aDb;
   nDb = db->nDb;
@@ -81767,13 +81765,13 @@
   int *piAddr,     /* OUT: Write index into (*paOp)[] here */
   Op **paOp        /* OUT: Write the opcode array here */
 ){
-  int nRow = 0;                            /* Stop when row count reaches this */
+  int nRow;                            /* Stop when row count reaches this */
   int nSub = 0;                        /* Number of sub-vdbes seen so far */
   SubProgram **apSub = 0;              /* Array of sub-vdbes */
-  int i = 0;                               /* Next instruction address */
+  int i;                               /* Next instruction address */
   int rc = SQLITE_OK;                  /* Result code */
   Op *aOp = 0;                         /* Opcode array */
-  int iPc = 0;                             /* Rowid.  Copy of value in *piPc */
+  int iPc;                             /* Rowid.  Copy of value in *piPc */
 
   /* When the number of output rows reaches nRow, that means the
   ** listing has finished and sqlite3_step() should return SQLITE_DONE.
@@ -81809,7 +81807,7 @@
     }else{
       /* We are currently listing subprograms.  Figure out which one and
       ** pick up the appropriate opcode. */
-      int j = 0;
+      int j;
       i -= p->nOp;
       assert( apSub!=0 );
       assert( nSub>0 );
@@ -81827,7 +81825,7 @@
     */
     if( pSub!=0 && aOp[i].p4type==P4_SUBPROGRAM ){
       int nByte = (nSub+1)*sizeof(SubProgram*);
-      int j = 0;
+      int j;
       for(j=0; j<nSub; j++){
         if( apSub[j]==aOp[i].p4.pProgram ) break;
       }
@@ -81872,7 +81870,7 @@
 ** allocated by the OP_Program opcode in sqlite3VdbeExec().
 */
 SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame *p){
-  int i = 0;
+  int i;
   Mem *aMem = VdbeFrameMem(p);
   VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];
   assert( sqlite3VdbeFrameIsValid(p) );
@@ -81908,12 +81906,12 @@
 ){
   Mem *pSub = 0;                       /* Memory cell hold array of subprogs */
   sqlite3 *db = p->db;                 /* The database connection */
-  int i = 0;                               /* Loop counter */
+  int i;                               /* Loop counter */
   int rc = SQLITE_OK;                  /* Return code */
   Mem *pMem = &p->aMem[1];             /* First Mem of result set */
   int bListSubprogs = (p->explain==1 || (db->flags & SQLITE_TriggerEQP)!=0);
-  Op *aOp = NULL;                             /* Array of opcodes */
-  Op *pOp = NULL;                             /* Current opcode */
+  Op *aOp;                             /* Array of opcodes */
+  Op *pOp;                             /* Current opcode */
 
   assert( p->explain );
   assert( p->iVdbeMagic==VDBE_MAGIC_RUN );
@@ -82148,12 +82146,12 @@
   Vdbe *p,                       /* The VDBE */
   Parse *pParse                  /* Parsing context */
 ){
-  sqlite3 *db = NULL;                   /* The database connection */
-  int nVar = 0;                      /* Number of parameters */
-  int nMem = 0;                      /* Number of VM memory registers */
-  int nCursor = 0;                   /* Number of cursors required */
-  int nArg = 0;                      /* Number of arguments in subprograms */
-  int n = 0;                         /* Loop counter */
+  sqlite3 *db;                   /* The database connection */
+  int nVar;                      /* Number of parameters */
+  int nMem;                      /* Number of VM memory registers */
+  int nCursor;                   /* Number of cursors required */
+  int nArg;                      /* Number of arguments in subprograms */
+  int n;                         /* Loop counter */
   struct ReusableSpace x;        /* Reusable bulk memory */
 
   assert( p!=0 );
@@ -82196,7 +82194,7 @@
        "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",
        "id", "parent", "notused", "detail"
     };
-    int iFirst = 0, mx = 0, i = 0;
+    int iFirst, mx, i;
     if( nMem<10 ) nMem = 10;
     p->explain = pParse->explain;
     if( pParse->explain==2 ){
@@ -82301,7 +82299,7 @@
 */
 static void closeCursorsInFrame(Vdbe *p){
   if( p->apCsr ){
-    int i = 0;
+    int i;
     for(i=0; i<p->nCursor; i++){
       VdbeCursor *pC = p->apCsr[i];
       if( pC ){
@@ -82348,7 +82346,7 @@
 */
 static void closeAllCursors(Vdbe *p){
   if( p->pFrame ){
-    VdbeFrame *pFrame = NULL;
+    VdbeFrame *pFrame;
     for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);
     sqlite3VdbeFrameRestore(pFrame);
     p->pFrame = 0;
@@ -82377,7 +82375,7 @@
 ** be called on an SQL statement before sqlite3_step().
 */
 SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){
-  int n = 0;
+  int n;
   sqlite3 *db = p->db;
 
   if( p->nResColumn ){
@@ -82408,8 +82406,8 @@
   const char *zName,               /* Pointer to buffer containing name */
   void (*xDel)(void*)              /* Memory management strategy for zName */
 ){
-  int rc = 0;
-  Mem *pColName = NULL;
+  int rc;
+  Mem *pColName;
   assert( idx<p->nResColumn );
   assert( var<COLNAME_N );
   if( p->db->mallocFailed ){
@@ -82430,7 +82428,7 @@
 ** takes care of the super-journal trickery.
 */
 static int vdbeCommit(sqlite3 *db, Vdbe *p){
-  int i = 0;
+  int i;
   int nTrans = 0;  /* Number of databases with an active write-transaction
                    ** that are candidates for a two-phase commit using a
                    ** super-journal */
@@ -82472,7 +82470,7 @@
         /* MEMORY    */ 0,
         /* WAL       */ 0
       };
-      Pager *pPager = NULL;   /* Pager associated with pBt */
+      Pager *pPager;   /* Pager associated with pBt */
       needXcommit = 1;
       sqlite3BtreeEnter(pBt);
       pPager = sqlite3BtreePager(pBt);
@@ -82545,9 +82543,9 @@
     char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);
     sqlite3_file *pSuperJrnl = 0;
     i64 offset = 0;
-    int res = 0;
+    int res;
     int retryCount = 0;
-    int nMainFile = 0;
+    int nMainFile;
 
     /* Select a super-journal file name */
     nMainFile = sqlite3Strlen30(zMainFile);
@@ -82555,7 +82553,7 @@
     if( zSuper==0 ) return SQLITE_NOMEM_BKPT;
     zSuper += 4;
     do {
-      u32 iRandom = 0;
+      u32 iRandom;
       if( retryCount ){
         if( retryCount>100 ){
           sqlite3_log(SQLITE_FULL, "MJ delete: %s", zSuper);
@@ -82728,7 +82726,7 @@
 static SQLITE_NOINLINE int vdbeCloseStatement(Vdbe *p, int eOp){
   sqlite3 *const db = p->db;
   int rc = SQLITE_OK;
-  int i = 0;
+  int i;
   const int iSavepoint = p->iStatement-1;
 
   assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);
@@ -82818,7 +82816,7 @@
 ** means the close did not happen and needs to be repeated.
 */
 SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe *p){
-  int rc = 0;                         /* Used to store transient return codes */
+  int rc;                         /* Used to store transient return codes */
   sqlite3 *db = p->db;
 
   /* This function contains the logic that determines if a statement or
@@ -82849,9 +82847,9 @@
   /* No commit or rollback needed if the program never started or if the
   ** SQL statement does not read or write a database file.  */
   if( p->pc>=0 && p->bIsReader ){
-    int mrc = 0;   /* Primary error code from p->rc */
+    int mrc;   /* Primary error code from p->rc */
     int eStatementOp = 0;
-    int isSpecialError = 0;            /* Set to true if a 'special' error */
+    int isSpecialError;            /* Set to true if a 'special' error */
 
     /* Lock all btrees used by the statement */
     sqlite3VdbeEnter(p);
@@ -83094,7 +83092,7 @@
   int i;
 #endif
 
-  sqlite3 *db = NULL;
+  sqlite3 *db;
   db = p->db;
 
   /* If the VM did not run to completion or if it encountered an
@@ -83241,7 +83239,7 @@
 ** the database connection and frees the object itself.
 */
 SQLITE_PRIVATE void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){
-  SubProgram *pSub = NULL, *pNext = NULL;
+  SubProgram *pSub, *pNext;
   assert( p->db==0 || p->db==db );
   releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);
   for(pSub=p->pProgram; pSub; pSub=pNext){
@@ -83282,7 +83280,7 @@
 ** Delete an entire VDBE.
 */
 SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe *p){
-  sqlite3 *db = NULL;
+  sqlite3 *db;
 
   assert( p!=0 );
   db = p->db;
@@ -83308,7 +83306,7 @@
 ** the appropriate error code.
 */
 SQLITE_PRIVATE int SQLITE_NOINLINE sqlite3VdbeFinishMoveto(VdbeCursor *p){
-  int res = 0, rc = 0;
+  int res, rc;
 #ifdef SQLITE_TEST
   extern int sqlite3_search_count;
 #endif
@@ -83334,7 +83332,7 @@
 ** cursor, set the cursor to point to a NULL row.
 */
 static int SQLITE_NOINLINE handleMovedCursor(VdbeCursor *p){
-  int isDifferentRow = 0, rc = 0;
+  int isDifferentRow, rc;
   assert( p->eCurType==CURTYPE_BTREE );
   assert( p->uc.pCursor!=0 );
   assert( sqlite3BtreeCursorHasMoved(p->uc.pCursor) );
@@ -83373,7 +83371,7 @@
   VdbeCursor *p = *pp;
   assert( p->eCurType==CURTYPE_BTREE || p->eCurType==CURTYPE_PSEUDO );
   if( p->deferredMoveto ){
-    u32 iMap = 0;
+    u32 iMap;
     assert( !p->isEphemeral );
     if( p->ub.aAltMap && (iMap = p->ub.aAltMap[1+*piCol])>0 && !p->nullRow ){
       *pp = p->pAltCursor;
@@ -83607,12 +83605,12 @@
 ** if those bytes were zeroed in buf[].
 */
 SQLITE_PRIVATE u32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){
-  u32 len = 0;
+  u32 len;
 
   /* Integer and Real */
   if( serial_type<=7 && serial_type>0 ){
-    u64 v = 0;
-    u32 i = 0;
+    u64 v;
+    u32 i;
     if( serial_type==7 ){
       assert( sizeof(v)==sizeof(pMem->u.r) );
       memcpy(&v, &pMem->u.r, sizeof(v));
@@ -83804,8 +83802,8 @@
 SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(
   KeyInfo *pKeyInfo               /* Description of the record */
 ){
-  UnpackedRecord *p = NULL;              /* Unpacked record to return */
-  int nByte = 0;                      /* Number of bytes required for *p */
+  UnpackedRecord *p;              /* Unpacked record to return */
+  int nByte;                      /* Number of bytes required for *p */
   nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nKeyField+1);
   p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);
   if( !p ) return 0;
@@ -83828,10 +83826,10 @@
   UnpackedRecord *p      /* Populate this structure before returning. */
 ){
   const unsigned char *aKey = (const unsigned char *)pKey;
-  u32 d = 0;
-  u32 idx = 0;                        /* Offset in aKey[] to read from */
-  u16 u = 0;                          /* Unsigned loop counter */
-  u32 szHdr = 0;
+  u32 d;
+  u32 idx;                        /* Offset in aKey[] to read from */
+  u16 u;                          /* Unsigned loop counter */
+  u32 szHdr;
   Mem *pMem = p->aMem;
 
   p->default_rc = 0;
@@ -83840,7 +83838,7 @@
   d = szHdr;
   u = 0;
   while( idx<szHdr && d<=(u32)nKey ){
-    u32 serial_type = 0;
+    u32 serial_type;
 
     idx += getVarint32(&aKey[idx], serial_type);
     pMem->enc = pKeyInfo->enc;
@@ -84029,8 +84027,8 @@
      ** comparison function directly */
     return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);
   }else{
-    int rc = 0;
-    const void *v1 = NULL, *v2 = NULL;
+    int rc;
+    const void *v1, *v2;
     Mem c1;
     Mem c2;
     sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);
@@ -84056,7 +84054,7 @@
 ** with MEM_Zero.  Return true if it could be a zero-blob.
 */
 static int isAllZero(const char *z, int n){
-  int i = 0;
+  int i;
   for(i=0; i<n; i++){
     if( z[i] ) return 0;
   }
@@ -84069,7 +84067,7 @@
 ** If one blob is a prefix of the other, then the shorter is the lessor.
 */
 SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){
-  int c = 0;
+  int c;
   int n1 = pB1->n;
   int n2 = pB2->n;
 
@@ -84111,8 +84109,8 @@
     if( x>r ) return +1;  /*NO_TEST*/ /* work around bugs in gcov */
     return 0;             /*NO_TEST*/ /* work around bugs in gcov */
   }else{
-    i64 y = 0;
-    double s = 0;
+    i64 y;
+    double s;
     if( r<-9223372036854775808.0 ) return +1;
     if( r>=9223372036854775808.0 ) return -1;
     y = (i64)r;
@@ -84135,8 +84133,8 @@
 ** Two NULL values are considered equal by this function.
 */
 SQLITE_PRIVATE int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){
-  int f1 = 0, f2 = 0;
-  int combined_flags = 0;
+  int f1, f2;
+  int combined_flags;
 
   f1 = pMem1->flags;
   f2 = pMem2->flags;
@@ -84234,7 +84232,7 @@
 ** and returns the value.
 */
 static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){
-  u32 y = 0;
+  u32 y;
   assert( CORRUPT_DB || (serial_type>=1 && serial_type<=9 && serial_type!=7) );
   switch( serial_type ){
     case 0:
@@ -84293,13 +84291,13 @@
   UnpackedRecord *pPKey2,         /* Right key */
   int bSkip                       /* If true, skip the first field */
 ){
-  u32 d1 = 0;                         /* Offset into aKey[] of next data element */
-  int i = 0;                          /* Index of next field to compare */
-  u32 szHdr1 = 0;                     /* Size of record header in bytes */
-  u32 idx1 = 0;                       /* Offset of first type in header */
+  u32 d1;                         /* Offset into aKey[] of next data element */
+  int i;                          /* Index of next field to compare */
+  u32 szHdr1;                     /* Size of record header in bytes */
+  u32 idx1;                       /* Offset of first type in header */
   int rc = 0;                     /* Return value */
   Mem *pRhs = pPKey2->aMem;       /* Next field of pPKey2 to compare */
-  KeyInfo *pKeyInfo = NULL;
+  KeyInfo *pKeyInfo;
   const unsigned char *aKey1 = (const unsigned char *)pKey1;
   Mem mem1;
 
@@ -84307,7 +84305,7 @@
   ** two elements in the keys are equal. Fix the various stack variables so
   ** that this routine begins comparing at the second field. */
   if( bSkip ){
-    u32 s1 = 0;
+    u32 s1;
     idx1 = 1 + getVarint32(&aKey1[1], s1);
     szHdr1 = aKey1[0];
     d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);
@@ -84330,7 +84328,7 @@
   assert( pPKey2->pKeyInfo->nKeyField>0 );
   assert( idx1<=szHdr1 || CORRUPT_DB );
   do{
-    u32 serial_type = 0;
+    u32 serial_type;
 
     /* RHS is an integer */
     if( pRhs->flags & (MEM_Int|MEM_IntReal) ){
@@ -84508,11 +84506,11 @@
 ){
   const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];
   int serial_type = ((const u8*)pKey1)[1];
-  int res = 0;
-  u32 y = 0;
-  u64 x = 0;
-  i64 v = 0;
-  i64 lhs = 0;
+  int res;
+  u32 y;
+  u64 x;
+  i64 v;
+  i64 lhs;
 
   vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);
   assert( (*(u8*)pKey1)<=0x3F || CORRUPT_DB );
@@ -84601,8 +84599,8 @@
   UnpackedRecord *pPKey2        /* Right key */
 ){
   const u8 *aKey1 = (const u8*)pKey1;
-  int serial_type = 0;
-  int res = 0;
+  int serial_type;
+  int res;
 
   assert( pPKey2->aMem[0].flags & MEM_Str );
   vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);
@@ -84615,8 +84613,8 @@
   }else if( !(serial_type & 0x01) ){
     res = pPKey2->r2;      /* (pKey1/nKey1) is a blob */
   }else{
-    int nCmp = 0;
-    int nStr = 0;
+    int nCmp;
+    int nStr;
     int szHdr = aKey1[0];
 
     nStr = (serial_type-12) / 2;
@@ -84713,10 +84711,10 @@
 */
 SQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){
   i64 nCellKey = 0;
-  int rc = 0;
-  u32 szHdr = 0;        /* Size of the header */
-  u32 typeRowid = 0;    /* Serial type of the rowid */
-  u32 lenRowid = 0;     /* Size of the rowid */
+  int rc;
+  u32 szHdr;        /* Size of the header */
+  u32 typeRowid;    /* Serial type of the rowid */
+  u32 lenRowid;     /* Size of the rowid */
   Mem m, v;
 
   /* Get the size of the index entry.  Only indices entries of less
@@ -84797,8 +84795,8 @@
   int *res                         /* Write the comparison result here */
 ){
   i64 nCellKey = 0;
-  int rc = 0;
-  BtCursor *pCur = NULL;
+  int rc;
+  BtCursor *pCur;
   Mem m;
 
   assert( pC->eCurType==CURTYPE_BTREE );
@@ -84858,7 +84856,7 @@
 ** and set to 2 for an advisory expiration.
 */
 SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3 *db, int iCode){
-  Vdbe *p = NULL;
+  Vdbe *p;
   for(p = db->pVdbe; p; p=p->pNext){
     p->expired = iCode+1;
   }
@@ -84928,14 +84926,14 @@
 ** features such as 'now'.
 */
 SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context *pCtx){
-  const VdbeOp *pOp = NULL;
+  const VdbeOp *pOp;
 #ifdef SQLITE_ENABLE_STAT4
   if( pCtx->pVdbe==0 ) return 1;
 #endif
   pOp = pCtx->pVdbe->aOp + pCtx->iOp;
   if( pOp->opcode==OP_PureFunc ){
-    const char *zContext = NULL;
-    char *zMsg = NULL;
+    const char *zContext;
+    char *zMsg;
     if( pOp->p5 & NC_IsCheck ){
       zContext = "a CHECK constraint";
     }else if( pOp->p5 & NC_GenCol ){
@@ -85125,8 +85123,8 @@
 ** know that the profile callback is defined and needs to be invoked.
 */
 static SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p){
-  sqlite3_int64 iNow = 0;
-  sqlite3_int64 iElapse = 0;
+  sqlite3_int64 iNow;
+  sqlite3_int64 iElapse;
   assert( p->startTime>0 );
   assert( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0 );
   assert( db->init.busy==0 );
@@ -85163,7 +85161,7 @@
 ** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
 */
 SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){
-  int rc = 0;
+  int rc;
   if( pStmt==0 ){
     /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
     ** pointer is a harmless no-op. */
@@ -85190,7 +85188,7 @@
 ** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
 */
 SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){
-  int rc = 0;
+  int rc;
   if( pStmt==0 ){
     rc = SQLITE_OK;
   }else{
@@ -85211,7 +85209,7 @@
 ** Set all the parameters in the compiled SQL statement to NULL.
 */
 SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
-  int i = 0;
+  int i;
   int rc = SQLITE_OK;
   Vdbe *p = (Vdbe*)pStmt;
 #if SQLITE_THREADSAFE
@@ -85396,7 +85394,7 @@
 /* Make a copy of an sqlite3_value object
 */
 SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){
-  sqlite3_value *pNew = NULL;
+  sqlite3_value *pNew;
   if( pOrig==0 ) return 0;
   pNew = sqlite3_malloc( sizeof(*pNew) );
   if( pNew==0 ) return 0;
@@ -85663,11 +85661,11 @@
 static int doWalCallbacks(sqlite3 *db){
   int rc = SQLITE_OK;
 #ifndef SQLITE_OMIT_WAL
-  int i = 0;
+  int i;
   for(i=0; i<db->nDb; i++){
     Btree *pBt = db->aDb[i].pBt;
     if( pBt ){
-      int nEntry = 0;
+      int nEntry;
       sqlite3BtreeEnter(pBt);
       nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));
       sqlite3BtreeLeave(pBt);
@@ -85691,8 +85689,8 @@
 ** outer sqlite3_step() wrapper procedure.
 */
 static int sqlite3Step(Vdbe *p){
-  sqlite3 *db = NULL;
-  int rc = 0;
+  sqlite3 *db;
+  int rc;
 
   assert(p);
   if( p->iVdbeMagic!=VDBE_MAGIC_RUN ){
@@ -85828,7 +85826,7 @@
   int rc = SQLITE_OK;      /* Result from sqlite3Step() */
   Vdbe *v = (Vdbe*)pStmt;  /* the prepared statement */
   int cnt = 0;             /* Counter to prevent infinite loop of reprepares */
-  sqlite3 *db = NULL;             /* The database connection */
+  sqlite3 *db;             /* The database connection */
 
   if( vdbeSafetyNotNull(v) ){
     return SQLITE_MISUSE_BKPT;
@@ -85921,8 +85919,8 @@
   sqlite3_value **ppOut,      /* Store the next value from the list here */
   int bNext                   /* 1 for _next(). 0 for _first() */
 ){
-  int rc = 0;
-  ValueList *pRhs = NULL;
+  int rc;
+  ValueList *pRhs;
 
   *ppOut = 0;
   if( pVal==0 ) return SQLITE_MISUSE;
@@ -85937,14 +85935,14 @@
     if( sqlite3BtreeEof(pRhs->pCsr) ) rc = SQLITE_DONE;
   }
   if( rc==SQLITE_OK ){
-    u32 sz = 0;       /* Size of current row in bytes */
+    u32 sz;       /* Size of current row in bytes */
     Mem sMem;     /* Raw content of current row */
     memset(&sMem, 0, sizeof(sMem));
     sz = sqlite3BtreePayloadSize(pRhs->pCsr);
     rc = sqlite3VdbeMemFromBtreeZeroOffset(pRhs->pCsr,(int)sz,&sMem);
     if( rc==SQLITE_OK ){
       u8 *zBuf = (u8*)sMem.z;
-      u32 iSerial = 0;
+      u32 iSerial;
       sqlite3_value *pOut = pRhs->pOut;
       int iOff = 1 + getVarint32(&zBuf[1], iSerial);
       sqlite3VdbeSerialGet(&zBuf[iOff], iSerial, pOut);
@@ -85984,7 +85982,7 @@
 ** the time returned is always the time of the first call.
 */
 SQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){
-  int rc = 0;
+  int rc;
 #ifndef SQLITE_ENABLE_STAT4
   sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;
   assert( p->pVdbe!=0 );
@@ -86047,7 +86045,7 @@
 ** single prepared statement.  The iArg values must match.
 */
 SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
-  AuxData *pAuxData = NULL;
+  AuxData *pAuxData;
 
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
 #if SQLITE_ENABLE_STAT4
@@ -86080,7 +86078,7 @@
   void *pAux,
   void (*xDelete)(void*)
 ){
-  AuxData *pAuxData = NULL;
+  AuxData *pAuxData;
   Vdbe *pVdbe = pCtx->pVdbe;
 
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
@@ -86195,8 +86193,8 @@
 ** of NULL.
 */
 static Mem *columnMem(sqlite3_stmt *pStmt, int i){
-  Vdbe *pVm = NULL;
-  Mem *pOut = NULL;
+  Vdbe *pVm;
+  Mem *pOut;
 
   pVm = (Vdbe *)pStmt;
   if( pVm==0 ) return (Mem*)columnNullValue();
@@ -86250,7 +86248,7 @@
 ** in the result set.
 */
 SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
-  const void *val = NULL;
+  const void *val;
   val = sqlite3_value_blob( columnMem(pStmt,i) );
   /* Even though there is no encoding conversion, value_blob() might
   ** need to call malloc() to expand the result of a zeroblob()
@@ -86333,10 +86331,10 @@
   int useUtf16,            /* True to return the name as UTF16 */
   int useType              /* What type of name */
 ){
-  const void *ret = NULL;
-  Vdbe *p = NULL;
-  int n = 0;
-  sqlite3 *db = NULL;
+  const void *ret;
+  Vdbe *p;
+  int n;
+  sqlite3 *db;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( pStmt==0 ){
     (void)SQLITE_MISUSE_BKPT;
@@ -86470,7 +86468,7 @@
 ** value in any case.
 */
 static int vdbeUnbind(Vdbe *p, int i){
-  Mem *pVar = NULL;
+  Mem *pVar;
   if( vdbeSafetyNotNull(p) ){
     return SQLITE_MISUSE_BKPT;
   }
@@ -86521,8 +86519,8 @@
   u8 encoding            /* Encoding for the data */
 ){
   Vdbe *p = (Vdbe *)pStmt;
-  Mem *pVar = NULL;
-  int rc = 0;
+  Mem *pVar;
+  int rc;
 
   rc = vdbeUnbind(p, i);
   if( rc==SQLITE_OK ){
@@ -86571,7 +86569,7 @@
   return bindText(pStmt, i, zData, nData, xDel, 0);
 }
 SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
-  int rc = 0;
+  int rc;
   Vdbe *p = (Vdbe *)pStmt;
   rc = vdbeUnbind(p, i);
   if( rc==SQLITE_OK ){
@@ -86584,7 +86582,7 @@
   return sqlite3_bind_int64(p, i, (i64)iValue);
 }
 SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
-  int rc = 0;
+  int rc;
   Vdbe *p = (Vdbe *)pStmt;
   rc = vdbeUnbind(p, i);
   if( rc==SQLITE_OK ){
@@ -86594,7 +86592,7 @@
   return rc;
 }
 SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
-  int rc = 0;
+  int rc;
   Vdbe *p = (Vdbe*)pStmt;
   rc = vdbeUnbind(p, i);
   if( rc==SQLITE_OK ){
@@ -86609,7 +86607,7 @@
   const char *zPTtype,
   void (*xDestructor)(void*)
 ){
-  int rc = 0;
+  int rc;
   Vdbe *p = (Vdbe*)pStmt;
   rc = vdbeUnbind(p, i);
   if( rc==SQLITE_OK ){
@@ -86653,7 +86651,7 @@
 }
 #endif /* SQLITE_OMIT_UTF16 */
 SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
-  int rc = 0;
+  int rc;
   switch( sqlite3_value_type((sqlite3_value*)pValue) ){
     case SQLITE_INTEGER: {
       rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);
@@ -86687,7 +86685,7 @@
   return rc;
 }
 SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
-  int rc = 0;
+  int rc;
   Vdbe *p = (Vdbe *)pStmt;
   rc = vdbeUnbind(p, i);
   if( rc==SQLITE_OK ){
@@ -86701,7 +86699,7 @@
   return rc;
 }
 SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){
-  int rc = 0;
+  int rc;
   Vdbe *p = (Vdbe *)pStmt;
   sqlite3_mutex_enter(p->db->mutex);
   if( n>(u64)p->db->aLimit[SQLITE_LIMIT_LENGTH] ){
@@ -86755,7 +86753,7 @@
 SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
   Vdbe *pFrom = (Vdbe*)pFromStmt;
   Vdbe *pTo = (Vdbe*)pToStmt;
-  int i = 0;
+  int i;
   assert( pTo->db==pFrom->db );
   assert( pTo->nVar==pFrom->nVar );
   sqlite3_mutex_enter(pTo->db->mutex);
@@ -86838,7 +86836,7 @@
 ** are no more.
 */
 SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
-  sqlite3_stmt *pNext = NULL;
+  sqlite3_stmt *pNext;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(pDb) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -86860,7 +86858,7 @@
 */
 SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
   Vdbe *pVdbe = (Vdbe*)pStmt;
-  u32 v = 0;
+  u32 v;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !pStmt
    || (op!=SQLITE_STMTSTATUS_MEMUSED && (op<0||op>=ArraySize(pVdbe->aCounter)))
@@ -87234,9 +87232,9 @@
 ** the total number of bytes in the text.
 */
 static int findNextHostParameter(const char *zSql, int *pnToken){
-  int tokenType = 0;
+  int tokenType;
   int nTotal = 0;
-  int n = 0;
+  int n;
 
   *pnToken = 0;
   while( zSql[0] ){
@@ -87280,13 +87278,13 @@
   Vdbe *p,                 /* The prepared statement being evaluated */
   const char *zRawSql      /* Raw text of the SQL statement */
 ){
-  sqlite3 *db = NULL;             /* The database connection */
+  sqlite3 *db;             /* The database connection */
   int idx = 0;             /* Index of a host parameter */
   int nextIndex = 1;       /* Index of next ? host parameter */
-  int n = 0;                   /* Length of a token prefix */
-  int nToken = 0;              /* Length of the parameter token */
-  int i = 0;                   /* Loop counter */
-  Mem *pVar = NULL;               /* Value of a host parameter */
+  int n;                   /* Length of a token prefix */
+  int nToken;              /* Length of the parameter token */
+  int i;                   /* Loop counter */
+  Mem *pVar;               /* Value of a host parameter */
   StrAccum out;            /* Accumulate the output here */
 #ifndef SQLITE_OMIT_UTF16
   Mem utf8;                /* Used to convert UTF16 into UTF8 for display */
@@ -87340,7 +87338,7 @@
       }else if( pVar->flags & MEM_Real ){
         sqlite3_str_appendf(&out, "%!.15g", pVar->u.r);
       }else if( pVar->flags & MEM_Str ){
-        int nOut = 0;  /* Number of bytes of the string text to include in output */
+        int nOut;  /* Number of bytes of the string text to include in output */
 #ifndef SQLITE_OMIT_UTF16
         u8 enc = ENC(db);
         if( enc!=SQLITE_UTF8 ){
@@ -87373,7 +87371,7 @@
       }else if( pVar->flags & MEM_Zero ){
         sqlite3_str_appendf(&out, "zeroblob(%d)", pVar->u.nZero);
       }else{
-        int nOut = 0;  /* Number of bytes of the blob to include in output */
+        int nOut;  /* Number of bytes of the blob to include in output */
         assert( pVar->flags & MEM_Blob );
         sqlite3_str_append(&out, "x'", 2);
         nOut = pVar->n;
@@ -87665,7 +87663,7 @@
   */
   Mem *pMem = iCur>0 ? &p->aMem[p->nMem-iCur] : p->aMem;
 
-  int nByte = 0;
+  int nByte;
   VdbeCursor *pCx = 0;
   nByte =
       ROUND8(sizeof(VdbeCursor)) + 2*sizeof(u32)*nField +
@@ -87740,9 +87738,9 @@
 ** if there is an exact integer representation of the quantity.
 */
 static void applyNumericAffinity(Mem *pRec, int bTryForInt){
-  double rValue = 0;
+  double rValue;
   u8 enc = pRec->enc;
-  int rc = 0;
+  int rc;
   assert( (pRec->flags & (MEM_Str|MEM_Int|MEM_Real|MEM_IntReal))==MEM_Str );
   rc = sqlite3AtoF(pRec->z, &rValue, pRec->n, enc);
   if( rc<=0 ) return;
@@ -87847,8 +87845,8 @@
 ** accordingly.
 */
 static u16 SQLITE_NOINLINE computeNumericType(Mem *pMem){
-  int rc = 0;
-  sqlite3_int64 ix = 0;
+  int rc;
+  sqlite3_int64 ix;
   assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 );
   assert( (pMem->flags & (MEM_Str|MEM_Blob))!=0 );
   if( ExpandBlob(pMem) ){
@@ -88058,7 +88056,7 @@
   return pOut;
 }
 static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp){
-  Mem *pOut = NULL;
+  Mem *pOut;
   assert( pOp->p2>0 );
   assert( pOp->p2<=(p->nMem+1 - p->nCursor) );
   pOut = &p->aMem[pOp->p2];
@@ -88076,7 +88074,7 @@
 ** with pOp->p3.  Return the hash.
 */
 static u64 filterHash(const Mem *aMem, const Op *pOp){
-  int i = 0, mx = 0;
+  int i, mx;
   u64 h = 0;
 
   assert( pOp->p4type==P4_INT32 );
@@ -88130,7 +88128,7 @@
   int iCompare = 0;          /* Result of last comparison */
   u64 nVmStep = 0;           /* Number of virtual machine steps */
 #ifndef SQLITE_OMIT_PROGRESS_CALLBACK
-  u64 nProgressLimit = 0;        /* Invoke xProgress() when nVmStep reaches this */
+  u64 nProgressLimit;        /* Invoke xProgress() when nVmStep reaches this */
 #endif
   Mem *aMem = p->aMem;       /* Copy of p->aMem */
   Mem *pIn1 = 0;             /* 1st input operand */
@@ -88440,7 +88438,7 @@
 ** See also: InitCoroutine
 */
 case OP_EndCoroutine: {           /* in1 */
-  VdbeOp *pCaller = NULL;
+  VdbeOp *pCaller;
   pIn1 = &aMem[pOp->p1];
   assert( pIn1->flags==MEM_Int );
   assert( pIn1->u.i>=0 && pIn1->u.i<p->nOp );
@@ -88466,7 +88464,7 @@
 ** See also: InitCoroutine
 */
 case OP_Yield: {            /* in1, jump */
-  int pcDest = 0;
+  int pcDest;
   pIn1 = &aMem[pOp->p1];
   assert( VdbeMemDynamic(pIn1)==0 );
   pIn1->flags = MEM_Int;
@@ -88526,8 +88524,8 @@
 ** is the same as executing Halt.
 */
 case OP_Halt: {
-  VdbeFrame *pFrame = NULL;
-  int pcx = 0;
+  VdbeFrame *pFrame;
+  int pcx;
 
   pcx = (int)(pOp - aOp);
 #ifdef SQLITE_DEBUG
@@ -88710,8 +88708,8 @@
 ** OP_Ne or OP_Eq.
 */
 case OP_Null: {           /* out2 */
-  int cnt = 0;
-  u16 nullFlag = 0;
+  int cnt;
+  u16 nullFlag;
   pOut = out2Prerelease(p, pOp);
   cnt = pOp->p3-pOp->p2;
   assert( pOp->p3<=(p->nMem+1 - p->nCursor) );
@@ -88776,7 +88774,7 @@
 ** The P4 value is used by sqlite3_bind_parameter_name().
 */
 case OP_Variable: {            /* out2 */
-  Mem *pVar = NULL;       /* Value being transferred */
+  Mem *pVar;       /* Value being transferred */
 
   assert( pOp->p1>0 && pOp->p1<=p->nVar );
   assert( pOp->p4.z==0 || pOp->p4.z==sqlite3VListNumToName(p->pVList,pOp->p1) );
@@ -88803,9 +88801,9 @@
 ** for P3 to be less than 1.
 */
 case OP_Move: {
-  int n = 0;           /* Number of registers left to copy */
-  int p1 = 0;          /* Register to copy from */
-  int p2 = 0;          /* Register to copy to */
+  int n;           /* Number of registers left to copy */
+  int p1;          /* Register to copy from */
+  int p2;          /* Register to copy to */
 
   n = pOp->p3;
   p1 = pOp->p1;
@@ -88848,7 +88846,7 @@
 ** is made of any string or blob constant.  See also OP_SCopy.
 */
 case OP_Copy: {
-  int n = 0;
+  int n;
 
   n = pOp->p3;
   pIn1 = &aMem[pOp->p1];
@@ -88938,8 +88936,8 @@
 ** the result row.
 */
 case OP_ResultRow: {
-  Mem *pMem = NULL;
-  int i = 0;
+  Mem *pMem;
+  int i;
   assert( p->nResColumn==pOp->p2 );
   assert( pOp->p1>0 || CORRUPT_DB );
   assert( pOp->p1+pOp->p2<=(p->nMem+1 - p->nCursor)+1 );
@@ -88996,9 +88994,9 @@
 ** to avoid a memcpy().
 */
 case OP_Concat: {           /* same as TK_CONCAT, in1, in2, out3 */
-  i64 nByte = 0;          /* Total size of the output string or blob */
-  u16 flags1 = 0;         /* Initial flags for P1 */
-  u16 flags2 = 0;         /* Initial flags for P2 */
+  i64 nByte;          /* Total size of the output string or blob */
+  u16 flags1;         /* Initial flags for P1 */
+  u16 flags2;         /* Initial flags for P2 */
 
   pIn1 = &aMem[pOp->p1];
   pIn2 = &aMem[pOp->p2];
@@ -89096,13 +89094,13 @@
 case OP_Multiply:              /* same as TK_STAR, in1, in2, out3 */
 case OP_Divide:                /* same as TK_SLASH, in1, in2, out3 */
 case OP_Remainder: {           /* same as TK_REM, in1, in2, out3 */
-  u16 flags = 0;      /* Combined MEM_* flags from both inputs */
-  u16 type1 = 0;      /* Numeric type of left operand */
-  u16 type2 = 0;      /* Numeric type of right operand */
-  i64 iA = 0;         /* Integer value of left operand */
-  i64 iB = 0;         /* Integer value of right operand */
-  double rA = 0;      /* Real value of left operand */
-  double rB = 0;      /* Real value of right operand */
+  u16 flags;      /* Combined MEM_* flags from both inputs */
+  u16 type1;      /* Numeric type of left operand */
+  u16 type2;      /* Numeric type of right operand */
+  i64 iA;         /* Integer value of left operand */
+  i64 iB;         /* Integer value of right operand */
+  double rA;      /* Real value of left operand */
+  double rB;      /* Real value of right operand */
 
   pIn1 = &aMem[pOp->p1];
   type1 = numericType(pIn1);
@@ -89232,10 +89230,10 @@
 case OP_BitOr:                  /* same as TK_BITOR, in1, in2, out3 */
 case OP_ShiftLeft:              /* same as TK_LSHIFT, in1, in2, out3 */
 case OP_ShiftRight: {           /* same as TK_RSHIFT, in1, in2, out3 */
-  i64 iA = 0;
-  u64 uA = 0;
-  i64 iB = 0;
-  u8 op = 0;
+  i64 iA;
+  u64 uA;
+  i64 iB;
+  u8 op;
 
   pIn1 = &aMem[pOp->p1];
   pIn2 = &aMem[pOp->p2];
@@ -89477,10 +89475,10 @@
 case OP_Le:               /* same as TK_LE, jump, in1, in3 */
 case OP_Gt:               /* same as TK_GT, jump, in1, in3 */
 case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
-  int res = 0, res2 = 0;      /* Result of the comparison of pIn1 against pIn3 */
-  char affinity = 0;      /* Affinity to use for comparison */
-  u16 flags1 = 0;         /* Copy of initial value of pIn1->flags */
-  u16 flags3 = 0;         /* Copy of initial value of pIn3->flags */
+  int res, res2;      /* Result of the comparison of pIn1 against pIn3 */
+  char affinity;      /* Affinity to use for comparison */
+  u16 flags1;         /* Copy of initial value of pIn1->flags */
+  u16 flags3;         /* Copy of initial value of pIn3->flags */
 
   pIn1 = &aMem[pOp->p1];
   pIn3 = &aMem[pOp->p3];
@@ -89679,15 +89677,15 @@
 ** and strings are less than blobs.
 */
 case OP_Compare: {
-  int n = 0;
-  int i = 0;
-  int p1 = 0;
-  int p2 = 0;
-  const KeyInfo *pKeyInfo = NULL;
-  u32 idx = 0;
-  CollSeq *pColl = NULL;    /* Collating sequence to use on this term */
-  int bRev = 0;          /* True for DESCENDING sort order */
-  u32 *aPermute = NULL;     /* The permutation */
+  int n;
+  int i;
+  int p1;
+  int p2;
+  const KeyInfo *pKeyInfo;
+  u32 idx;
+  CollSeq *pColl;    /* Collating sequence to use on this term */
+  int bRev;          /* True for DESCENDING sort order */
+  u32 *aPermute;     /* The permutation */
 
   if( (pOp->p5 & OPFLAG_PERMUTE)==0 ){
     aPermute = 0;
@@ -89777,8 +89775,8 @@
 */
 case OP_And:              /* same as TK_AND, in1, in2, out3 */
 case OP_Or: {             /* same as TK_OR, in1, in2, out3 */
-  int v1 = 0;    /* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */
-  int v2 = 0;    /* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */
+  int v1;    /* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */
+  int v2;    /* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */
 
   v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);
   v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);
@@ -89882,7 +89880,7 @@
 ** triggers.
 */
 case OP_Once: {             /* jump */
-  u32 iAddr = 0;                /* Address of this instruction */
+  u32 iAddr;                /* Address of this instruction */
   assert( p->aOp[0].opcode==OP_Init );
   if( p->pFrame ){
     iAddr = (int)(pOp - p->aOp);
@@ -89909,7 +89907,7 @@
 ** in P1 is NULL then take the jump if and only if P3 is non-zero.
 */
 case OP_If:  {               /* jump, in1 */
-  int c = 0;
+  int c;
   c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);
   VdbeBranchTaken(c!=0, 2);
   if( c ) goto jump_to_p2;
@@ -89923,7 +89921,7 @@
 ** in P1 is NULL then take the jump if and only if P3 is non-zero.
 */
 case OP_IfNot: {            /* jump, in1 */
-  int c = 0;
+  int c;
   c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);
   VdbeBranchTaken(c!=0, 2);
   if( c ) goto jump_to_p2;
@@ -89952,7 +89950,7 @@
 ** SQLITE_BLOB, SQLITE_NULL, or SQLITE_TEXT.
 */
 case OP_IsNullOrType: {      /* jump, in1 */
-  int doTheJump = 0;
+  int doTheJump;
   pIn1 = &aMem[pOp->p1];
   doTheJump = (pIn1->flags & MEM_Null)!=0 || sqlite3_value_type(pIn1)==pOp->p3;
   VdbeBranchTaken( doTheJump, 2);
@@ -90069,20 +90067,20 @@
 ** skipped for length() and all content loading can be skipped for typeof().
 */
 case OP_Column: {
-  u32 p2 = 0;            /* column number to retrieve */
-  VdbeCursor *pC = NULL;    /* The VDBE cursor */
-  BtCursor *pCrsr = NULL;   /* The BTree cursor */
-  u32 *aOffset = NULL;      /* aOffset[i] is offset to start of data for i-th column */
-  int len = 0;           /* The length of the serialized data for the column */
-  int i = 0;             /* Loop counter */
-  Mem *pDest = NULL;        /* Where to write the extracted value */
+  u32 p2;            /* column number to retrieve */
+  VdbeCursor *pC;    /* The VDBE cursor */
+  BtCursor *pCrsr;   /* The BTree cursor */
+  u32 *aOffset;      /* aOffset[i] is offset to start of data for i-th column */
+  int len;           /* The length of the serialized data for the column */
+  int i;             /* Loop counter */
+  Mem *pDest;        /* Where to write the extracted value */
   Mem sMem;          /* For storing the record being decoded */
-  const u8 *zData = NULL;   /* Part of the record being decoded */
-  const u8 *zHdr = NULL;    /* Next unparsed byte of the header */
-  const u8 *zEndHdr = NULL; /* Pointer to first byte after the header */
-  u64 offset64 = 0;      /* 64-bit offset */
-  u32 t = 0;             /* A type code from the record header */
-  Mem *pReg = NULL;         /* PseudoTable input register */
+  const u8 *zData;   /* Part of the record being decoded */
+  const u8 *zHdr;    /* Next unparsed byte of the header */
+  const u8 *zEndHdr; /* Pointer to first byte after the header */
+  u64 offset64;      /* 64-bit offset */
+  u32 t;             /* A type code from the record header */
+  Mem *pReg;         /* PseudoTable input register */
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -90364,9 +90362,9 @@
 ** If any precondition is false, an assertion fault occurs.
 */
 case OP_TypeCheck: {
-  Table *pTab = NULL;
-  Column *aCol = NULL;
-  int i = 0;
+  Table *pTab;
+  Column *aCol;
+  int i;
 
   assert( pOp->p4type==P4_TABLE );
   pTab = pOp->p4.pTab;
@@ -90451,7 +90449,7 @@
 ** memory cell in the range.
 */
 case OP_Affinity: {
-  const char *zAffinity = NULL;   /* The affinity to be applied */
+  const char *zAffinity;   /* The affinity to be applied */
 
   zAffinity = pOp->p4.z;
   assert( zAffinity!=0 );
@@ -90516,21 +90514,21 @@
 **     only used inside an assert() and does not affect the end result.
 */
 case OP_MakeRecord: {
-  Mem *pRec = NULL;             /* The new record */
-  u64 nData = 0;             /* Number of bytes of data space */
-  int nHdr = 0;              /* Number of bytes of header space */
-  i64 nByte = 0;             /* Data space required for this record */
-  i64 nZero = 0;             /* Number of zero bytes at the end of the record */
-  int nVarint = 0;           /* Number of bytes in a varint */
-  u32 serial_type = 0;       /* Type field */
-  Mem *pData0 = NULL;           /* First field to be combined into the record */
-  Mem *pLast = NULL;            /* Last field of the record */
-  int nField = 0;            /* Number of fields in the record */
-  char *zAffinity = NULL;       /* The affinity string for the record */
-  int file_format = 0;       /* File format to use for encoding */
-  u32 len = 0;               /* Length of a field */
-  u8 *zHdr = NULL;              /* Where to write next byte of the header */
-  u8 *zPayload = NULL;          /* Where to write next byte of the payload */
+  Mem *pRec;             /* The new record */
+  u64 nData;             /* Number of bytes of data space */
+  int nHdr;              /* Number of bytes of header space */
+  i64 nByte;             /* Data space required for this record */
+  i64 nZero;             /* Number of zero bytes at the end of the record */
+  int nVarint;           /* Number of bytes in a varint */
+  u32 serial_type;       /* Type field */
+  Mem *pData0;           /* First field to be combined into the record */
+  Mem *pLast;            /* Last field of the record */
+  int nField;            /* Number of fields in the record */
+  char *zAffinity;       /* The affinity string for the record */
+  int file_format;       /* File format to use for encoding */
+  u32 len;               /* Length of a field */
+  u8 *zHdr;              /* Where to write next byte of the header */
+  u8 *zPayload;          /* Where to write next byte of the payload */
 
   /* Assuming the record contains N fields, the record format looks
   ** like this:
@@ -90643,7 +90641,7 @@
     }else if( pRec->flags & (MEM_Int|MEM_IntReal) ){
       /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */
       i64 i = pRec->u.i;
-      u64 uu = 0;
+      u64 uu;
       testcase( pRec->flags & MEM_Int );
       testcase( pRec->flags & MEM_IntReal );
       if( i<0 ){
@@ -90794,8 +90792,8 @@
 ** is returned based on the current cursor position.
 */
 case OP_Count: {         /* out2 */
-  i64 nEntry = 0;
-  BtCursor *pCrsr = NULL;
+  i64 nEntry;
+  BtCursor *pCrsr;
 
   assert( p->apCsr[pOp->p1]->eCurType==CURTYPE_BTREE );
   pCrsr = p->apCsr[pOp->p1]->uc.pCursor;
@@ -90820,14 +90818,14 @@
 ** To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).
 */
 case OP_Savepoint: {
-  int p1 = 0;                         /* Value of P1 operand */
-  char *zName = NULL;                    /* Name of savepoint */
-  int nName = 0;
-  Savepoint *pNew = NULL;
-  Savepoint *pSavepoint = NULL;
-  Savepoint *pTmp = NULL;
-  int iSavepoint = 0;
-  int ii = 0;
+  int p1;                         /* Value of P1 operand */
+  char *zName;                    /* Name of savepoint */
+  int nName;
+  Savepoint *pNew;
+  Savepoint *pSavepoint;
+  Savepoint *pTmp;
+  int iSavepoint;
+  int ii;
 
   p1 = pOp->p1;
   zName = pOp->p4.z;
@@ -90932,7 +90930,7 @@
           db->isTransactionSavepoint = 0;
         }
       }else{
-        int isSchemaChange = 0;
+        int isSchemaChange;
         iSavepoint = db->nSavepoint - iSavepoint - 1;
         if( p1==SAVEPOINT_ROLLBACK ){
           isSchemaChange = (db->mDbFlags & DBFLAG_SchemaChange)!=0;
@@ -91007,8 +91005,8 @@
 ** This instruction causes the VM to halt.
 */
 case OP_AutoCommit: {
-  int desiredAutoCommit = 0;
-  int iRollback = 0;
+  int desiredAutoCommit;
+  int iRollback;
 
   desiredAutoCommit = pOp->p1;
   iRollback = pOp->p2;
@@ -91096,7 +91094,7 @@
 ** statement and rerun it from the beginning.
 */
 case OP_Transaction: {
-  Btree *pBt = NULL;
+  Btree *pBt;
   int iMeta = 0;
 
   assert( p->bIsReader );
@@ -91203,9 +91201,9 @@
 ** executing this instruction.
 */
 case OP_ReadCookie: {               /* out2 */
-  int iMeta = 0;
-  int iDb = 0;
-  int iCookie = 0;
+  int iMeta;
+  int iDb;
+  int iCookie;
 
   assert( p->bIsReader );
   iDb = pOp->p1;
@@ -91237,7 +91235,7 @@
 ** from the database schema version, resulting in a schema reset.
 */
 case OP_SetCookie: {
-  Db *pDb = NULL;
+  Db *pDb;
 
   sqlite3VdbeIncrWriteCounter(p, 0);
   assert( pOp->p2<SQLITE_N_BTREE_META );
@@ -91353,14 +91351,14 @@
 ** See also: OP_OpenRead, OP_ReopenIdx
 */
 case OP_ReopenIdx: {
-  int nField = 0;
-  KeyInfo *pKeyInfo = NULL;
-  u32 p2 = 0;
-  int iDb = 0;
-  int wrFlag = 0;
-  Btree *pX = NULL;
-  VdbeCursor *pCur = NULL;
-  Db *pDb = NULL;
+  int nField;
+  KeyInfo *pKeyInfo;
+  u32 p2;
+  int iDb;
+  int wrFlag;
+  Btree *pX;
+  VdbeCursor *pCur;
+  Db *pDb;
 
   assert( pOp->p5==0 || pOp->p5==OPFLAG_SEEKEQ );
   assert( pOp->p4type==P4_KEYINFO );
@@ -91468,8 +91466,8 @@
 ** Duplicate ephemeral cursors are used for self-joins of materialized views.
 */
 case OP_OpenDup: {
-  VdbeCursor *pOrig = NULL;    /* The original cursor to be duplicated */
-  VdbeCursor *pCx = NULL;      /* The new cursor */
+  VdbeCursor *pOrig;    /* The original cursor to be duplicated */
+  VdbeCursor *pCx;      /* The new cursor */
 
   pOrig = p->apCsr[pOp->p2];
   assert( pOrig );
@@ -91531,8 +91529,8 @@
 */
 case OP_OpenAutoindex:
 case OP_OpenEphemeral: {
-  VdbeCursor *pCx = NULL;
-  KeyInfo *pKeyInfo = NULL;
+  VdbeCursor *pCx;
+  KeyInfo *pKeyInfo;
 
   static const int vfsFlags =
       SQLITE_OPEN_READWRITE |
@@ -91616,7 +91614,7 @@
 ** key is sufficient to produce the required results.
 */
 case OP_SorterOpen: {
-  VdbeCursor *pCx = NULL;
+  VdbeCursor *pCx;
 
   assert( pOp->p1>=0 );
   assert( pOp->p2>=0 );
@@ -91638,7 +91636,7 @@
 ** the sequence value.
 */
 case OP_SequenceTest: {
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( isSorter(pC) );
@@ -91665,7 +91663,7 @@
 ** the pseudo-table.
 */
 case OP_OpenPseudo: {
-  VdbeCursor *pCx = NULL;
+  VdbeCursor *pCx;
 
   assert( pOp->p1>=0 );
   assert( pOp->p3>=0 );
@@ -91809,13 +91807,13 @@
 case OP_SeekLE:         /* jump, in3, group */
 case OP_SeekGE:         /* jump, in3, group */
 case OP_SeekGT: {       /* jump, in3, group */
-  int res = 0;           /* Comparison result */
-  int oc = 0;            /* Opcode */
-  VdbeCursor *pC = NULL;    /* The cursor to seek */
+  int res;           /* Comparison result */
+  int oc;            /* Opcode */
+  VdbeCursor *pC;    /* The cursor to seek */
   UnpackedRecord r;  /* The key to seek for */
-  int nField = 0;        /* Number of columns or fields in the key */
-  i64 iKey = 0;          /* The rowid we are to seek to */
-  int eqOnly = 0;        /* Only interested in == results */
+  int nField;        /* Number of columns or fields in the key */
+  i64 iKey;          /* The rowid we are to seek to */
+  int eqOnly;        /* Only interested in == results */
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   assert( pOp->p2!=0 );
@@ -91837,7 +91835,7 @@
   pC->deferredMoveto = 0;
   pC->cacheStatus = CACHE_STALE;
   if( pC->isTable ){
-    u16 flags3 = 0, newType = 0;
+    u16 flags3, newType;
     /* The OPFLAG_SEEKEQ/BTREE_SEEK_EQ flag is only set on index cursors */
     assert( sqlite3BtreeCursorHasHint(pC->uc.pCursor, BTREE_SEEK_EQ)==0
               || CORRUPT_DB );
@@ -91857,7 +91855,7 @@
     /* If the P3 value could not be converted into an integer without
     ** loss of information, then special processing is required... */
     if( (newType & (MEM_Int|MEM_IntReal))==0 ){
-      int c = 0;
+      int c;
       if( (newType & MEM_Real)==0 ){
         if( (newType & MEM_Null) || oc>=OP_SeekGE ){
           VdbeBranchTaken(1,2);
@@ -92047,9 +92045,9 @@
 ** </ol>
 */
 case OP_SeekScan: {
-  VdbeCursor *pC = NULL;
-  int res = 0;
-  int nStep = 0;
+  VdbeCursor *pC;
+  int res;
+  int nStep;
   UnpackedRecord r;
 
   assert( pOp[1].opcode==OP_SeekGE );
@@ -92156,7 +92154,7 @@
 ** P1 must be a valid b-tree cursor.
 */
 case OP_SeekHit: {
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
@@ -92284,7 +92282,7 @@
 ** See also: NotFound, Found, NotExists
 */
 case OP_IfNoHope: {     /* jump, in3 */
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
@@ -92300,13 +92298,13 @@
 case OP_NoConflict:     /* jump, in3 */
 case OP_NotFound:       /* jump, in3 */
 case OP_Found: {        /* jump, in3 */
-  int alreadyExists = 0;
-  int takeJump = 0;
-  int ii = 0;
-  VdbeCursor *pC = NULL;
-  int res = 0;
-  UnpackedRecord *pFree = NULL;
-  UnpackedRecord *pIdxKey = NULL;
+  int alreadyExists;
+  int takeJump;
+  int ii;
+  VdbeCursor *pC;
+  int res;
+  UnpackedRecord *pFree;
+  UnpackedRecord *pIdxKey;
   UnpackedRecord r;
 
 #ifdef SQLITE_TEST
@@ -92428,10 +92426,10 @@
 ** See also: Found, NotFound, NoConflict, SeekRowid
 */
 case OP_SeekRowid: {        /* jump, in3 */
-  VdbeCursor *pC = NULL;
-  BtCursor *pCrsr = NULL;
-  int res = 0;
-  u64 iKey = 0;
+  VdbeCursor *pC;
+  BtCursor *pCrsr;
+  int res;
+  u64 iKey;
 
   pIn3 = &aMem[pOp->p3];
   testcase( pIn3->flags & MEM_Int );
@@ -92522,13 +92520,13 @@
 ** AUTOINCREMENT feature.
 */
 case OP_NewRowid: {           /* out2 */
-  i64 v = 0;                 /* The new rowid */
-  VdbeCursor *pC = NULL;        /* Cursor of table to get the new rowid */
-  int res = 0;               /* Result of an sqlite3BtreeLast() */
-  int cnt = 0;               /* Counter to limit the number of searches */
+  i64 v;                 /* The new rowid */
+  VdbeCursor *pC;        /* Cursor of table to get the new rowid */
+  int res;               /* Result of an sqlite3BtreeLast() */
+  int cnt;               /* Counter to limit the number of searches */
 #ifndef SQLITE_OMIT_AUTOINCREMENT
-  Mem *pMem = NULL;             /* Register holding largest rowid for AUTOINCREMENT */
-  VdbeFrame *pFrame = NULL;     /* Root frame of VDBE */
+  Mem *pMem;             /* Register holding largest rowid for AUTOINCREMENT */
+  VdbeFrame *pFrame;     /* Root frame of VDBE */
 #endif
 
   v = 0;
@@ -92681,12 +92679,12 @@
 ** for indices is OP_IdxInsert.
 */
 case OP_Insert: {
-  Mem *pData = NULL;       /* MEM cell holding data for the record to be inserted */
-  Mem *pKey = NULL;        /* MEM cell holding key  for the record */
-  VdbeCursor *pC = NULL;   /* Cursor to table into which insert is written */
-  int seekResult = 0;   /* Result of prior seek or 0 if no USESEEKRESULT flag */
-  const char *zDb = NULL;  /* database name - used by the update hook */
-  Table *pTab = NULL;      /* Table structure - used by update and pre-update hooks */
+  Mem *pData;       /* MEM cell holding data for the record to be inserted */
+  Mem *pKey;        /* MEM cell holding key  for the record */
+  VdbeCursor *pC;   /* Cursor to table into which insert is written */
+  int seekResult;   /* Result of prior seek or 0 if no USESEEKRESULT flag */
+  const char *zDb;  /* database name - used by the update hook */
+  Table *pTab;      /* Table structure - used by update and pre-update hooks */
   BtreePayload x;   /* Payload to be inserted */
 
   pData = &aMem[pOp->p2];
@@ -92775,9 +92773,9 @@
 ** with the OPFLAG_PREFORMAT flag set to complete the insert operation.
 */
 case OP_RowCell: {
-  VdbeCursor *pDest = NULL;              /* Cursor to write to */
-  VdbeCursor *pSrc = NULL;               /* Cursor to read from */
-  i64 iKey = 0;                       /* Rowid value to insert with */
+  VdbeCursor *pDest;              /* Cursor to write to */
+  VdbeCursor *pSrc;               /* Cursor to read from */
+  i64 iKey;                       /* Rowid value to insert with */
   assert( pOp[1].opcode==OP_Insert || pOp[1].opcode==OP_IdxInsert );
   assert( pOp[1].opcode==OP_Insert    || pOp->p3==0 );
   assert( pOp[1].opcode==OP_IdxInsert || pOp->p3>0 );
@@ -92826,10 +92824,10 @@
 ** be set to by the update.
 */
 case OP_Delete: {
-  VdbeCursor *pC = NULL;
-  const char *zDb = NULL;
-  Table *pTab = NULL;
-  int opflags = 0;
+  VdbeCursor *pC;
+  const char *zDb;
+  Table *pTab;
+  int opflags;
 
   opflags = pOp->p2;
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
@@ -92954,9 +92952,9 @@
 ** each other.  Jump to P2 if they are different.
 */
 case OP_SorterCompare: {
-  VdbeCursor *pC = NULL;
-  int res = 0;
-  int nKeyCol = 0;
+  VdbeCursor *pC;
+  int res;
+  int nKeyCol;
 
   pC = p->apCsr[pOp->p1];
   assert( isSorter(pC) );
@@ -92984,7 +92982,7 @@
 ** us from having to issue a separate NullRow instruction to clear that cache.
 */
 case OP_SorterData: {
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
 
   pOut = &aMem[pOp->p2];
   pC = p->apCsr[pOp->p1];
@@ -93026,9 +93024,9 @@
 ** by any use of another cursor pointing to the same table.
 */
 case OP_RowData: {
-  VdbeCursor *pC = NULL;
-  BtCursor *pCrsr = NULL;
-  u32 n = 0;
+  VdbeCursor *pC;
+  BtCursor *pCrsr;
+  u32 n;
 
   pOut = out2Prerelease(p, pOp);
 
@@ -93076,10 +93074,10 @@
 ** one opcode now works for both table types.
 */
 case OP_Rowid: {                 /* out2 */
-  VdbeCursor *pC = NULL;
-  i64 v = 0;
-  sqlite3_vtab *pVtab = NULL;
-  const sqlite3_module *pModule = NULL;
+  VdbeCursor *pC;
+  i64 v;
+  sqlite3_vtab *pVtab;
+  const sqlite3_module *pModule;
 
   pOut = out2Prerelease(p, pOp);
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
@@ -93127,7 +93125,7 @@
 ** content held by the pseudo-cursor to be reparsed.
 */
 case OP_NullRow: {
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -93168,9 +93166,9 @@
 */
 case OP_SeekEnd:
 case OP_Last: {        /* jump */
-  VdbeCursor *pC = NULL;
-  BtCursor *pCrsr = NULL;
-  int res = 0;
+  VdbeCursor *pC;
+  BtCursor *pCrsr;
+  int res;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -93207,10 +93205,10 @@
 ** estimate is less than approximately 2**(0.1*P3).
 */
 case OP_IfSmaller: {        /* jump */
-  VdbeCursor *pC = NULL;
-  BtCursor *pCrsr = NULL;
-  int res = 0;
-  i64 sz = 0;
+  VdbeCursor *pC;
+  BtCursor *pCrsr;
+  int res;
+  i64 sz;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -93273,9 +93271,9 @@
 ** configured to use Next, not Prev.
 */
 case OP_Rewind: {        /* jump */
-  VdbeCursor *pC = NULL;
-  BtCursor *pCrsr = NULL;
-  int res = 0;
+  VdbeCursor *pC;
+  BtCursor *pCrsr;
+  int res;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   assert( pOp->p5==0 );
@@ -93365,7 +93363,7 @@
 ** record, or jumps to P2 if there are no more sorted records.
 */
 case OP_SorterNext: {  /* jump */
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
 
   pC = p->apCsr[pOp->p1];
   assert( isSorter(pC) );
@@ -93441,7 +93439,7 @@
 ** for tables is OP_Insert.
 */
 case OP_IdxInsert: {        /* in2 */
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
   BtreePayload x;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
@@ -93478,7 +93476,7 @@
 ** into the sorter P1.  Data for the entry is nil.
 */
 case OP_SorterInsert: {     /* in2 */
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -93511,9 +93509,9 @@
 ** this (self-correcting and non-critical) error if in writable_schema mode.
 */
 case OP_IdxDelete: {
-  VdbeCursor *pC = NULL;
-  BtCursor *pCrsr = NULL;
-  int res = 0;
+  VdbeCursor *pC;
+  BtCursor *pCrsr;
+  int res;
   UnpackedRecord r;
 
   assert( pOp->p3>0 );
@@ -93574,9 +93572,9 @@
 */
 case OP_DeferredSeek:
 case OP_IdxRowid: {           /* out2 */
-  VdbeCursor *pC = NULL;             /* The P1 index cursor */
-  VdbeCursor *pTabCur = NULL;        /* The P2 table cursor (OP_DeferredSeek only) */
-  i64 rowid = 0;                  /* Rowid that P1 current points to */
+  VdbeCursor *pC;             /* The P1 index cursor */
+  VdbeCursor *pTabCur;        /* The P2 table cursor (OP_DeferredSeek only) */
+  i64 rowid;                  /* Rowid that P1 current points to */
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -93635,7 +93633,7 @@
 ** already occurred, this instruction is a no-op.
 */
 case OP_FinishSeek: {
-  VdbeCursor *pC = NULL;             /* The P1 index cursor */
+  VdbeCursor *pC;             /* The P1 index cursor */
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -93694,8 +93692,8 @@
 case OP_IdxGT:          /* jump */
 case OP_IdxLT:          /* jump */
 case OP_IdxGE:  {       /* jump */
-  VdbeCursor *pC = NULL;
-  int res = 0;
+  VdbeCursor *pC;
+  int res;
   UnpackedRecord r;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
@@ -93729,7 +93727,7 @@
   /* Inlined version of sqlite3VdbeIdxKeyCompare() */
   {
     i64 nCellKey = 0;
-    BtCursor *pCur = NULL;
+    BtCursor *pCur;
     Mem m;
 
     assert( pC->eCurType==CURTYPE_BTREE );
@@ -93792,8 +93790,8 @@
 ** See also: Clear
 */
 case OP_Destroy: {     /* out2 */
-  int iMoved = 0;
-  int iDb = 0;
+  int iMoved;
+  int iDb;
 
   sqlite3VdbeIncrWriteCounter(p, 0);
   assert( p->readOnly==0 );
@@ -93842,7 +93840,7 @@
 ** See also: Destroy
 */
 case OP_Clear: {
-  i64 nChange = 0;
+  i64 nChange;
 
   sqlite3VdbeIncrWriteCounter(p, 0);
   nChange = 0;
@@ -93870,7 +93868,7 @@
 ** opened with OP_OpenEphemeral or OP_SorterOpen.
 */
 case OP_ResetSorter: {
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -93896,8 +93894,8 @@
 ** The root page number of the new b-tree is stored in register P2.
 */
 case OP_CreateBtree: {          /* out2 */
-  Pgno pgno = 0;
-  Db *pDb = NULL;
+  Pgno pgno;
+  Db *pDb;
 
   sqlite3VdbeIncrWriteCounter(p, 0);
   pOut = out2Prerelease(p, pOp);
@@ -93937,9 +93935,9 @@
 ** then runs the new virtual machine.  It is thus a re-entrant opcode.
 */
 case OP_ParseSchema: {
-  int iDb = 0;
-  const char *zSchema = NULL;
-  char *zSql = NULL;
+  int iDb;
+  const char *zSchema;
+  char *zSql;
   InitData initData;
 
   /* Any prepared statement that invokes this opcode will hold mutexes
@@ -94086,11 +94084,11 @@
 ** This opcode is used to implement the integrity_check pragma.
 */
 case OP_IntegrityCk: {
-  int nRoot = 0;      /* Number of tables to check.  (Number of root pages.) */
-  Pgno *aRoot = NULL;    /* Array of rootpage numbers for tables to be checked */
-  int nErr = 0;       /* Number of errors reported */
-  char *z = NULL;        /* Text of the error report */
-  Mem *pnErr = NULL;     /* Register keeping track of errors remaining */
+  int nRoot;      /* Number of tables to check.  (Number of root pages.) */
+  Pgno *aRoot;    /* Array of rootpage numbers for tables to be checked */
+  int nErr;       /* Number of errors reported */
+  char *z;        /* Text of the error report */
+  Mem *pnErr;     /* Register keeping track of errors remaining */
 
   assert( p->bIsReader );
   nRoot = pOp->p2;
@@ -94150,7 +94148,7 @@
 ** unchanged and jump to instruction P2.
 */
 case OP_RowSetRead: {       /* jump, in1, out3 */
-  i64 val = 0;
+  i64 val;
 
   pIn1 = &aMem[pOp->p1];
   assert( (pIn1->flags & MEM_Blob)==0 || sqlite3VdbeMemIsRowSet(pIn1) );
@@ -94193,8 +94191,8 @@
 ** inserted as part of some other set).
 */
 case OP_RowSetTest: {                     /* jump, in1, in3 */
-  int iSet = 0;
-  int exists = 0;
+  int iSet;
+  int exists;
 
   pIn1 = &aMem[pOp->p1];
   pIn3 = &aMem[pOp->p3];
@@ -94240,14 +94238,14 @@
 ** If P5 is non-zero, then recursive program invocation is enabled.
 */
 case OP_Program: {        /* jump */
-  int nMem = 0;               /* Number of memory registers for sub-program */
-  int nByte = 0;              /* Bytes of runtime space required for sub-program */
-  Mem *pRt = NULL;               /* Register to allocate runtime space */
-  Mem *pMem = NULL;              /* Used to iterate through memory cells */
-  Mem *pEnd = NULL;              /* Last memory cell in new array */
-  VdbeFrame *pFrame = NULL;      /* New vdbe frame to execute in */
-  SubProgram *pProgram = NULL;   /* Sub-program to execute */
-  void *t = NULL;                /* Token identifying trigger */
+  int nMem;               /* Number of memory registers for sub-program */
+  int nByte;              /* Bytes of runtime space required for sub-program */
+  Mem *pRt;               /* Register to allocate runtime space */
+  Mem *pMem;              /* Used to iterate through memory cells */
+  Mem *pEnd;              /* Last memory cell in new array */
+  VdbeFrame *pFrame;      /* New vdbe frame to execute in */
+  SubProgram *pProgram;   /* Sub-program to execute */
+  void *t;                /* Token identifying trigger */
 
   pProgram = pOp->p4.pProgram;
   pRt = &aMem[pOp->p3];
@@ -94384,8 +94382,8 @@
 ** calling OP_Program instruction.
 */
 case OP_Param: {           /* out2 */
-  VdbeFrame *pFrame = NULL;
-  Mem *pIn = NULL;
+  VdbeFrame *pFrame;
+  Mem *pIn;
   pOut = out2Prerelease(p, pOp);
   pFrame = p->pFrame;
   pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];
@@ -94452,7 +94450,7 @@
 ** an integer.
 */
 case OP_MemMax: {        /* in2 */
-  VdbeFrame *pFrame = NULL;
+  VdbeFrame *pFrame;
   if( p->pFrame ){
     for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);
     pIn1 = &pFrame->aMem[pOp->p1];
@@ -94510,7 +94508,7 @@
 ** Otherwise, r[P2] is set to the sum of r[P1] and r[P3].
 */
 case OP_OffsetLimit: {    /* in1, out2, in3 */
-  i64 x = 0;
+  i64 x;
   pIn1 = &aMem[pOp->p1];
   pIn3 = &aMem[pOp->p3];
   pOut = out2Prerelease(p, pOp);
@@ -94608,8 +94606,8 @@
 */
 case OP_AggInverse:
 case OP_AggStep: {
-  int n = 0;
-  sqlite3_context *pCtx = NULL;
+  int n;
+  sqlite3_context *pCtx;
 
   assert( pOp->p4type==P4_FUNCDEF );
   n = pOp->p5;
@@ -94639,9 +94637,9 @@
   /* no break */ deliberate_fall_through
 }
 case OP_AggStep1: {
-  int i = 0;
-  sqlite3_context *pCtx = NULL;
-  Mem *pMem = NULL;
+  int i;
+  sqlite3_context *pCtx;
+  Mem *pMem;
 
   assert( pOp->p4type==P4_FUNCCTX );
   pCtx = pOp->p4.pCtx;
@@ -94734,7 +94732,7 @@
 */
 case OP_AggValue:
 case OP_AggFinal: {
-  Mem *pMem = NULL;
+  Mem *pMem;
   assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );
   assert( pOp->p3==0 || pOp->opcode==OP_AggValue );
   pMem = &aMem[pOp->p1];
@@ -94775,9 +94773,9 @@
 ** mem[P3+2] are initialized to -1.
 */
 case OP_Checkpoint: {
-  int i = 0;                          /* Loop counter */
+  int i;                          /* Loop counter */
   int aRes[3];                    /* Results */
-  Mem *pMem = NULL;                      /* Write results here */
+  Mem *pMem;                      /* Write results here */
 
   assert( p->readOnly==0 );
   aRes[0] = 0;
@@ -94813,12 +94811,12 @@
 ** Write a string containing the final journal-mode to register P2.
 */
 case OP_JournalMode: {    /* out2 */
-  Btree *pBt = NULL;                     /* Btree to change journal mode of */
-  Pager *pPager = NULL;                  /* Pager associated with pBt */
-  int eNew = 0;                       /* New journal mode */
-  int eOld = 0;                       /* The old journal mode */
+  Btree *pBt;                     /* Btree to change journal mode of */
+  Pager *pPager;                  /* Pager associated with pBt */
+  int eNew;                       /* New journal mode */
+  int eOld;                       /* The old journal mode */
 #ifndef SQLITE_OMIT_WAL
-  const char *zFilename = NULL;          /* Name of database file for pPager */
+  const char *zFilename;          /* Name of database file for pPager */
 #endif
 
   pOut = out2Prerelease(p, pOp);
@@ -94933,7 +94931,7 @@
 ** P2. Otherwise, fall through to the next instruction.
 */
 case OP_IncrVacuum: {        /* jump */
-  Btree *pBt = NULL;
+  Btree *pBt;
 
   assert( pOp->p1>=0 && pOp->p1<db->nDb );
   assert( DbMaskTest(p->btreeMask, pOp->p1) );
@@ -94982,7 +94980,7 @@
 ** written by an other cursor.
 */
 case OP_CursorLock: {
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
@@ -94997,7 +94995,7 @@
 ** written by other cursors.
 */
 case OP_CursorUnlock: {
-  VdbeCursor *pC = NULL;
+  VdbeCursor *pC;
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
@@ -95053,7 +95051,7 @@
 ** code will be set to SQLITE_LOCKED.
 */
 case OP_VBegin: {
-  VTable *pVTab = NULL;
+  VTable *pVTab;
   pVTab = pOp->p4.pVtab;
   rc = sqlite3VtabBegin(db, pVTab);
   if( pVTab ) sqlite3VtabImportErrmsg(p, pVTab->pVtab);
@@ -95070,7 +95068,7 @@
 */
 case OP_VCreate: {
   Mem sMem;          /* For storing the record being decoded */
-  const char *zTab = NULL;  /* Name of the virtual table */
+  const char *zTab;  /* Name of the virtual table */
 
   memset(&sMem, 0, sizeof(sMem));
   sMem.db = db;
@@ -95115,10 +95113,10 @@
 ** table and stores that cursor in P1.
 */
 case OP_VOpen: {
-  VdbeCursor *pCur = NULL;
-  sqlite3_vtab_cursor *pVCur = NULL;
-  sqlite3_vtab *pVtab = NULL;
-  const sqlite3_module *pModule = NULL;
+  VdbeCursor *pCur;
+  sqlite3_vtab_cursor *pVCur;
+  sqlite3_vtab *pVtab;
+  const sqlite3_module *pModule;
 
   assert( p->bIsReader );
   pCur = 0;
@@ -95162,8 +95160,8 @@
 ** sqlite3_vtab_in_first() and sqlite3_vtab_in_next().
 */
 case OP_VInitIn: {        /* out2 */
-  VdbeCursor *pC = NULL;         /* The cursor containing the RHS values */
-  ValueList *pRhs = NULL;        /* New ValueList object to put in reg[P2] */
+  VdbeCursor *pC;         /* The cursor containing the RHS values */
+  ValueList *pRhs;        /* New ValueList object to put in reg[P2] */
 
   pC = p->apCsr[pOp->p1];
   pRhs = sqlite3_malloc64( sizeof(*pRhs) );
@@ -95199,17 +95197,17 @@
 ** A jump is made to P2 if the result set after filtering would be empty.
 */
 case OP_VFilter: {   /* jump */
-  int nArg = 0;
-  int iQuery = 0;
-  const sqlite3_module *pModule = NULL;
-  Mem *pQuery = NULL;
-  Mem *pArgc = NULL;
-  sqlite3_vtab_cursor *pVCur = NULL;
-  sqlite3_vtab *pVtab = NULL;
-  VdbeCursor *pCur = NULL;
-  int res = 0;
-  int i = 0;
-  Mem **apArg = NULL;
+  int nArg;
+  int iQuery;
+  const sqlite3_module *pModule;
+  Mem *pQuery;
+  Mem *pArgc;
+  sqlite3_vtab_cursor *pVCur;
+  sqlite3_vtab *pVtab;
+  VdbeCursor *pCur;
+  int res;
+  int i;
+  Mem **apArg;
 
   pQuery = &aMem[pOp->p3];
   pArgc = &pQuery[1];
@@ -95259,9 +95257,9 @@
 ** unused by OP_VColumn.
 */
 case OP_VColumn: {
-  sqlite3_vtab *pVtab = NULL;
-  const sqlite3_module *pModule = NULL;
-  Mem *pDest = NULL;
+  sqlite3_vtab *pVtab;
+  const sqlite3_module *pModule;
+  Mem *pDest;
   sqlite3_context sContext;
 
   VdbeCursor *pCur = p->apCsr[pOp->p1];
@@ -95313,10 +95311,10 @@
 ** the end of its result set, then fall through to the next instruction.
 */
 case OP_VNext: {   /* jump */
-  sqlite3_vtab *pVtab = NULL;
-  const sqlite3_module *pModule = NULL;
-  int res = 0;
-  VdbeCursor *pCur = NULL;
+  sqlite3_vtab *pVtab;
+  const sqlite3_module *pModule;
+  int res;
+  VdbeCursor *pCur;
 
   pCur = p->apCsr[pOp->p1];
   assert( pCur!=0 );
@@ -95355,9 +95353,9 @@
 ** in register P1 is passed as the zName argument to the xRename method.
 */
 case OP_VRename: {
-  sqlite3_vtab *pVtab = NULL;
-  Mem *pName = NULL;
-  int isLegacy = 0;
+  sqlite3_vtab *pVtab;
+  Mem *pName;
+  int isLegacy;
 
   isLegacy = (db->flags & SQLITE_LegacyAlter);
   db->flags |= SQLITE_LegacyAlter;
@@ -95411,13 +95409,13 @@
 ** apply in the case of a constraint failure on an insert or update.
 */
 case OP_VUpdate: {
-  sqlite3_vtab *pVtab = NULL;
-  const sqlite3_module *pModule = NULL;
-  int nArg = 0;
-  int i = 0;
+  sqlite3_vtab *pVtab;
+  const sqlite3_module *pModule;
+  int nArg;
+  int i;
   sqlite_int64 rowid = 0;
-  Mem **apArg = NULL;
-  Mem *pX = NULL;
+  Mem **apArg;
+  Mem *pX;
 
   assert( pOp->p2==1        || pOp->p5==OE_Fail   || pOp->p5==OE_Rollback
        || pOp->p5==OE_Abort || pOp->p5==OE_Ignore || pOp->p5==OE_Replace
@@ -95489,8 +95487,8 @@
 ** Store the maximum page count after the change in register P2.
 */
 case OP_MaxPgcnt: {            /* out2 */
-  unsigned int newMax = 0;
-  Btree *pBt = NULL;
+  unsigned int newMax;
+  Btree *pBt;
 
   pOut = out2Prerelease(p, pOp);
   pBt = db->aDb[pOp->p1].pBt;
@@ -95552,8 +95550,8 @@
 */
 case OP_PureFunc:              /* group */
 case OP_Function: {            /* group */
-  int i = 0;
-  sqlite3_context *pCtx = NULL;
+  int i;
+  sqlite3_context *pCtx;
 
   assert( pOp->p4type==P4_FUNCCTX );
   pCtx = pOp->p4.pCtx;
@@ -95610,7 +95608,7 @@
 ** add that hash to the bloom filter contained in r[P1].
 */
 case OP_FilterAdd: {
-  u64 h = 0;
+  u64 h;
 
   assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );
   pIn1 = &aMem[pOp->p1];
@@ -95646,7 +95644,7 @@
 ** false positive - if the jump is taken when it should fall through.
 */
 case OP_Filter: {          /* jump */
-  u64 h = 0;
+  u64 h;
 
   assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );
   pIn1 = &aMem[pOp->p1];
@@ -95701,9 +95699,9 @@
 */
 case OP_Trace:
 case OP_Init: {          /* jump */
-  int i = 0;
+  int i;
 #ifndef SQLITE_OMIT_TRACE
-  char *zTrace = NULL;
+  char *zTrace;
 #endif
 
   /* If the P4 argument is not NULL, then it must be an SQL comment string.
@@ -96064,7 +96062,7 @@
 ** immediately return SQLITE_ABORT.
 */
 static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){
-  int rc = 0;                         /* Error code */
+  int rc;                         /* Error code */
   char *zErr = 0;                 /* Error message */
   Vdbe *v = (Vdbe *)p->pStmt;
 
@@ -96087,7 +96085,7 @@
   }
   if( rc==SQLITE_ROW ){
     VdbeCursor *pC = v->apCsr[0];
-    u32 type = 0;
+    u32 type;
     assert( pC!=0 );
     assert( pC->eCurType==CURTYPE_BTREE );
     type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;
@@ -96141,10 +96139,10 @@
   sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */
 ){
   int nAttempt = 0;
-  int iCol = 0;               /* Index of zColumn in row-record */
+  int iCol;               /* Index of zColumn in row-record */
   int rc = SQLITE_OK;
   char *zErr = 0;
-  Table *pTab = NULL;
+  Table *pTab;
   Incrblob *pBlob = 0;
   Parse sParse;
 
@@ -96218,17 +96216,17 @@
     */
     if( wrFlag ){
       const char *zFault = 0;
-      Index *pIdx = NULL;
+      Index *pIdx;
 #ifndef SQLITE_OMIT_FOREIGN_KEY
       if( db->flags&SQLITE_ForeignKeys ){
         /* Check that the column is not part of an FK child key definition. It
         ** is not necessary to check if it is part of a parent key, as parent
         ** key columns must be indexed. The check below will pick up this
         ** case.  */
-        FKey *pFKey = NULL;
+        FKey *pFKey;
         assert( IsOrdinaryTable(pTab) );
         for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
-          int j = 0;
+          int j;
           for(j=0; j<pFKey->nCol; j++){
             if( pFKey->aCol[j].iFrom==iCol ){
               zFault = "foreign key";
@@ -96238,7 +96236,7 @@
       }
 #endif
       for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-        int j = 0;
+        int j;
         for(j=0; j<pIdx->nKeyCol; j++){
           /* FIXME: Be smarter about indexes that use expressions */
           if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==XN_EXPR ){
@@ -96286,7 +96284,7 @@
       };
       Vdbe *v = (Vdbe *)pBlob->pStmt;
       int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
-      VdbeOp *aOp = NULL;
+      VdbeOp *aOp;
 
       sqlite3VdbeAddOp4Int(v, OP_Transaction, iDb, wrFlag,
                            pTab->pSchema->schema_cookie,
@@ -96368,8 +96366,8 @@
 */
 SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){
   Incrblob *p = (Incrblob *)pBlob;
-  int rc = 0;
-  sqlite3 *db = NULL;
+  int rc;
+  sqlite3 *db;
 
   if( p ){
     sqlite3_stmt *pStmt = p->pStmt;
@@ -96394,10 +96392,10 @@
   int iOffset,
   int (*xCall)(BtCursor*, u32, u32, void*)
 ){
-  int rc = 0;
+  int rc;
   Incrblob *p = (Incrblob *)pBlob;
-  Vdbe *v = NULL;
-  sqlite3 *db = NULL;
+  Vdbe *v;
+  sqlite3 *db;
 
   if( p==0 ) return SQLITE_MISUSE_BKPT;
   db = p->db;
@@ -96495,9 +96493,9 @@
 ** immediately return SQLITE_ABORT.
 */
 SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
-  int rc = 0;
+  int rc;
   Incrblob *p = (Incrblob *)pBlob;
-  sqlite3 *db = NULL;
+  sqlite3 *db;
 
   if( p==0 ) return SQLITE_MISUSE_BKPT;
   db = p->db;
@@ -96509,7 +96507,7 @@
     */
     rc = SQLITE_ABORT;
   }else{
-    char *zErr = NULL;
+    char *zErr;
     ((Vdbe*)p->pStmt)->rc = SQLITE_OK;
     rc = blobSeekToRow(p, iRow, &zErr);
     if( rc!=SQLITE_OK ){
@@ -97019,8 +97017,8 @@
   int nByte,                      /* Bytes of data to read */
   u8 **ppOut                      /* OUT: Pointer to buffer containing data */
 ){
-  int iBuf = 0;                       /* Offset within buffer to read from */
-  int nAvail = 0;                     /* Bytes of data available in buffer */
+  int iBuf;                       /* Offset within buffer to read from */
+  int nAvail;                     /* Bytes of data available in buffer */
 
   if( p->aMap ){
     *ppOut = &p->aMap[p->iReadOff];
@@ -97035,8 +97033,8 @@
   ** than p->nBuffer bytes remaining in the PMA, read all remaining data.  */
   iBuf = p->iReadOff % p->nBuffer;
   if( iBuf==0 ){
-    int nRead = 0;                    /* Bytes to read from disk */
-    int rc = 0;                       /* sqlite3OsRead() return code */
+    int nRead;                    /* Bytes to read from disk */
+    int rc;                       /* sqlite3OsRead() return code */
 
     /* Determine how many bytes of data to read. */
     if( (p->iEof - p->iReadOff) > (i64)p->nBuffer ){
@@ -97063,11 +97061,11 @@
     /* The requested data is not all available in the in-memory buffer.
     ** In this case, allocate space at p->aAlloc[] to copy the requested
     ** range into. Then return a copy of pointer p->aAlloc to the caller.  */
-    int nRem = 0;                     /* Bytes remaining to copy */
+    int nRem;                     /* Bytes remaining to copy */
 
     /* Extend the p->aAlloc[] allocation if required. */
     if( p->nAlloc<nByte ){
-      u8 *aNew = NULL;
+      u8 *aNew;
       sqlite3_int64 nNew = MAX(128, 2*(sqlite3_int64)p->nAlloc);
       while( nByte>nNew ) nNew = nNew*2;
       aNew = sqlite3Realloc(p->aAlloc, nNew);
@@ -97085,9 +97083,9 @@
     /* The following loop copies up to p->nBuffer bytes per iteration into
     ** the p->aAlloc[] buffer.  */
     while( nRem>0 ){
-      int rc = 0;                     /* vdbePmaReadBlob() return code */
-      int nCopy = 0;                  /* Number of bytes to copy */
-      u8 *aNext = NULL;                  /* Pointer to buffer to copy data from */
+      int rc;                     /* vdbePmaReadBlob() return code */
+      int nCopy;                  /* Number of bytes to copy */
+      u8 *aNext;                  /* Pointer to buffer to copy data from */
 
       nCopy = nRem;
       if( nRem>p->nBuffer ) nCopy = p->nBuffer;
@@ -97109,7 +97107,7 @@
 ** the value read.
 */
 static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){
-  int iBuf = 0;
+  int iBuf;
 
   if( p->aMap ){
     p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);
@@ -97118,7 +97116,7 @@
     if( iBuf && (p->nBuffer-iBuf)>=9 ){
       p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);
     }else{
-      u8 aVarint[16], *a = NULL;
+      u8 aVarint[16], *a;
       int i = 0, rc;
       do{
         rc = vdbePmaReadBlob(p, 1, &a);
@@ -97259,7 +97257,7 @@
   PmaReader *pReadr,              /* PmaReader to populate */
   i64 *pnByte                     /* IN/OUT: Increment this value by PMA size */
 ){
-  int rc = 0;
+  int rc;
 
   assert( pFile->iEof>iStart );
   assert( pReadr->aAlloc==0 && pReadr->nAlloc==0 );
@@ -97342,9 +97340,9 @@
   const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */
   const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */
 
-  int n1 = 0;
-  int n2 = 0;
-  int res = 0;
+  int n1;
+  int n2;
+  int res;
 
   getVarint32NR(&p1[1], n1);
   getVarint32NR(&p2[1], n2);
@@ -97385,7 +97383,7 @@
   const int s2 = p2[1];                 /* Right hand serial type */
   const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */
   const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */
-  int res = 0;                              /* Return value */
+  int res;                              /* Return value */
 
   assert( (s1>0 && s1<7) || s1==8 || s1==9 );
   assert( (s2>0 && s2<7) || s2==8 || s2==9 );
@@ -97394,7 +97392,7 @@
     /* The two values have the same sign. Compare using memcmp(). */
     static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };
     const u8 n = aLen[s1];
-    int i = 0;
+    int i;
     res = 0;
     for(i=0; i<n; i++){
       if( (res = v1[i] - v2[i])!=0 ){
@@ -97461,17 +97459,17 @@
   int nField,                     /* Number of key fields in each record */
   VdbeCursor *pCsr                /* Cursor that holds the new sorter */
 ){
-  int pgsz = 0;                       /* Page size of main database */
-  int i = 0;                          /* Used to iterate through aTask[] */
-  VdbeSorter *pSorter = NULL;            /* The new sorter */
-  KeyInfo *pKeyInfo = NULL;              /* Copy of pCsr->pKeyInfo with db==0 */
-  int szKeyInfo = 0;                  /* Size of pCsr->pKeyInfo in bytes */
-  int sz = 0;                         /* Size of pSorter in bytes */
+  int pgsz;                       /* Page size of main database */
+  int i;                          /* Used to iterate through aTask[] */
+  VdbeSorter *pSorter;            /* The new sorter */
+  KeyInfo *pKeyInfo;              /* Copy of pCsr->pKeyInfo with db==0 */
+  int szKeyInfo;                  /* Size of pCsr->pKeyInfo in bytes */
+  int sz;                         /* Size of pSorter in bytes */
   int rc = SQLITE_OK;
 #if SQLITE_MAX_WORKER_THREADS==0
 # define nWorker 0
 #else
-  int nWorker = 0;
+  int nWorker;
 #endif
 
   /* Initialize the upper limit on the number of worker threads */
@@ -97522,7 +97520,7 @@
     }
 
     if( !sqlite3TempInMemory(db) ){
-      i64 mxCache = 0;                /* Cache size in bytes*/
+      i64 mxCache;                /* Cache size in bytes*/
       u32 szPma = sqlite3GlobalConfig.szPma;
       pSorter->mnPmaSize = szPma * pgsz;
 
@@ -97563,8 +97561,8 @@
 ** Free the list of sorted records starting at pRecord.
 */
 static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){
-  SorterRecord *p = NULL;
-  SorterRecord *pNext = NULL;
+  SorterRecord *p;
+  SorterRecord *pNext;
   for(p=pRecord; p; p=pNext){
     pNext = p->u.pNext;
     sqlite3DbFree(db, p);
@@ -97677,7 +97675,7 @@
 */
 static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){
   int rc = rcin;
-  int i = 0;
+  int i;
 
   /* This function is always called by the main user thread.
   **
@@ -97707,8 +97705,8 @@
 */
 static MergeEngine *vdbeMergeEngineNew(int nReader){
   int N = 2;                      /* Smallest power of two >= nReader */
-  int nByte = 0;                      /* Total bytes of space to allocate */
-  MergeEngine *pNew = NULL;              /* Pointer to allocated object to return */
+  int nByte;                      /* Total bytes of space to allocate */
+  MergeEngine *pNew;              /* Pointer to allocated object to return */
 
   assert( nReader<=SORTER_MAX_MERGE_COUNT );
 
@@ -97729,7 +97727,7 @@
 ** Free the MergeEngine object passed as the only argument.
 */
 static void vdbeMergeEngineFree(MergeEngine *pMerger){
-  int i = 0;
+  int i;
   if( pMerger ){
     for(i=0; i<pMerger->nTree; i++){
       vdbePmaReaderClear(&pMerger->aReadr[i]);
@@ -97760,7 +97758,7 @@
 ** Reset a sorting cursor back to its original empty state.
 */
 SQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){
-  int i = 0;
+  int i;
   (void)vdbeSorterJoinAll(pSorter, SQLITE_OK);
   assert( pSorter->bUseThreads || pSorter->pReader==0 );
 #if SQLITE_MAX_WORKER_THREADS>0
@@ -97793,7 +97791,7 @@
 ** Free any cursor components allocated by sqlite3VdbeSorterXXX routines.
 */
 SQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr){
-  VdbeSorter *pSorter = NULL;
+  VdbeSorter *pSorter;
   assert( pCsr->eCurType==CURTYPE_SORTER );
   pSorter = pCsr->uc.pSorter;
   if( pSorter ){
@@ -97838,7 +97836,7 @@
   i64 nExtend,                    /* Attempt to extend file to this size */
   sqlite3_file **ppFd
 ){
-  int rc = 0;
+  int rc;
   if( sqlite3FaultSim(202) ) return SQLITE_IOERR_ACCESS;
   rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,
       SQLITE_OPEN_TEMP_JOURNAL |
@@ -97885,7 +97883,7 @@
 
   assert( p1!=0 && p2!=0 );
   for(;;){
-    int res = 0;
+    int res;
     res = pTask->xCompare(
         pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal
     );
@@ -97931,9 +97929,9 @@
 ** an error occurs.
 */
 static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){
-  int i = 0;
-  SorterRecord *p = NULL;
-  int rc = 0;
+  int i;
+  SorterRecord *p;
+  int rc;
   SorterRecord *aSlot[64];
 
   rc = vdbeSortAllocUnpacked(pTask);
@@ -97944,7 +97942,7 @@
   memset(aSlot, 0, sizeof(aSlot));
 
   while( p ){
-    SorterRecord *pNext = NULL;
+    SorterRecord *pNext;
     if( pList->aMemory ){
       if( (u8*)p==pList->aMemory ){
         pNext = 0;
@@ -98037,7 +98035,7 @@
 ** last byte written to the file.
 */
 static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof){
-  int rc = 0;
+  int rc;
   if( p->eFWErr==0 && ALWAYS(p->aBuffer) && p->iBufEnd>p->iBufStart ){
     p->eFWErr = sqlite3OsWrite(p->pFd,
         &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,
@@ -98056,7 +98054,7 @@
 ** SQLITE_OK if successful, or an SQLite error code if an error occurs.
 */
 static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){
-  int nByte = 0;
+  int nByte;
   u8 aByte[10];
   nByte = sqlite3PutVarint(aByte, iVal);
   vdbePmaWriteBlob(p, aByte, nByte);
@@ -98110,7 +98108,7 @@
   }
 
   if( rc==SQLITE_OK ){
-    SorterRecord *p = NULL;
+    SorterRecord *p;
     SorterRecord *pNext = 0;
 
     vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,
@@ -98144,7 +98142,7 @@
   MergeEngine *pMerger,      /* The merge engine to advance to the next row */
   int *pbEof                 /* Set TRUE at EOF.  Set false for more content */
 ){
-  int rc = 0;
+  int rc;
   int iPrev = pMerger->aTree[1];/* Index of PmaReader to advance */
   SortSubtask *pTask = pMerger->pTask;
 
@@ -98153,9 +98151,9 @@
 
   /* Update contents of aTree[] */
   if( rc==SQLITE_OK ){
-    int i = 0;                      /* Index of aTree[] to recalculate */
-    PmaReader *pReadr1 = NULL;         /* First PmaReader to compare */
-    PmaReader *pReadr2 = NULL;         /* Second PmaReader to compare */
+    int i;                      /* Index of aTree[] to recalculate */
+    PmaReader *pReadr1;         /* First PmaReader to compare */
+    PmaReader *pReadr2;         /* Second PmaReader to compare */
     int bCached = 0;
 
     /* Find the first two PmaReaders to compare. The one that was just
@@ -98165,7 +98163,7 @@
 
     for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){
       /* Compare pReadr1 and pReadr2. Store the result in variable iRes. */
-      int iRes = 0;
+      int iRes;
       if( pReadr1->pFd==0 ){
         iRes = +1;
       }else if( pReadr2->pFd==0 ){
@@ -98213,7 +98211,7 @@
 */
 static void *vdbeSorterFlushThread(void *pCtx){
   SortSubtask *pTask = (SortSubtask*)pCtx;
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
   assert( pTask->bDone==0 );
   rc = vdbeSorterListToPMA(pTask, &pTask->list);
   pTask->bDone = 1;
@@ -98231,7 +98229,7 @@
   return vdbeSorterListToPMA(&pSorter->aTask[0], &pSorter->list);
 #else
   int rc = SQLITE_OK;
-  int i = 0;
+  int i;
   SortSubtask *pTask = 0;    /* Thread context used to create new PMA */
   int nWorker = (pSorter->nTask-1);
 
@@ -98262,8 +98260,8 @@
       rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);
     }else{
       /* Launch a background thread for this operation */
-      u8 *aMem = NULL;
-      void *pCtx = NULL;
+      u8 *aMem;
+      void *pCtx;
 
       assert( pTask!=0 );
       assert( pTask->pThread==0 && pTask->bDone==0 );
@@ -98299,13 +98297,13 @@
   const VdbeCursor *pCsr,         /* Sorter cursor */
   Mem *pVal                       /* Memory cell containing record */
 ){
-  VdbeSorter *pSorter = NULL;
+  VdbeSorter *pSorter;
   int rc = SQLITE_OK;             /* Return Code */
-  SorterRecord *pNew = NULL;             /* New list element */
-  int bFlush = 0;                     /* True to flush contents of memory to PMA */
-  int nReq = 0;                       /* Bytes of memory required */
-  int nPMA = 0;                       /* Bytes of PMA space required */
-  int t = 0;                          /* serial type of first record field */
+  SorterRecord *pNew;             /* New list element */
+  int bFlush;                     /* True to flush contents of memory to PMA */
+  int nReq;                       /* Bytes of memory required */
+  int nPMA;                       /* Bytes of PMA space required */
+  int t;                          /* serial type of first record field */
 
   assert( pCsr->eCurType==CURTYPE_SORTER );
   pSorter = pCsr->uc.pSorter;
@@ -98364,7 +98362,7 @@
     int nMin = pSorter->iMemory + nReq;
 
     if( nMin>pSorter->nMemory ){
-      u8 *aNew = NULL;
+      u8 *aNew;
       sqlite3_int64 nNew = 2 * (sqlite3_int64)pSorter->nMemory;
       int iListOff = -1;
       if( pSorter->list.pList ){
@@ -98409,7 +98407,7 @@
 */
 static int vdbeIncrPopulate(IncrMerger *pIncr){
   int rc = SQLITE_OK;
-  int rc2 = 0;
+  int rc2;
   i64 iStart = pIncr->iStartOff;
   SorterFile *pOut = &pIncr->aFile[1];
   SortSubtask *pTask = pIncr->pTask;
@@ -98421,7 +98419,7 @@
 
   vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);
   while( rc==SQLITE_OK ){
-    int dummy = 0;
+    int dummy;
     PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];
     int nKey = pReader->nKey;
     i64 iEof = writer.iWriteOff + writer.iBufEnd;
@@ -98564,11 +98562,11 @@
   MergeEngine *pMerger,  /* Merge engine containing PmaReaders to compare */
   int iOut               /* Store the result in pMerger->aTree[iOut] */
 ){
-  int i1 = 0;
-  int i2 = 0;
-  int iRes = 0;
-  PmaReader *p1 = NULL;
-  PmaReader *p2 = NULL;
+  int i1;
+  int i2;
+  int iRes;
+  PmaReader *p1;
+  PmaReader *p2;
 
   assert( iOut<pMerger->nTree && iOut>0 );
 
@@ -98590,7 +98588,7 @@
   }else{
     SortSubtask *pTask = pMerger->pTask;
     int bCached = 0;
-    int res = 0;
+    int res;
     assert( pTask->pUnpacked!=0 );  /* from vdbeSortSubtaskMain() */
     res = pTask->xCompare(
         pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey
@@ -98648,8 +98646,8 @@
   int eMode                       /* One of the INCRINIT_XXX constants */
 ){
   int rc = SQLITE_OK;             /* Return code */
-  int i = 0;                          /* For looping over PmaReader objects */
-  int nTree = 0;                      /* Number of subtrees to merge */
+  int i;                          /* For looping over PmaReader objects */
+  int nTree;                      /* Number of subtrees to merge */
 
   /* Failure to allocate the merge would have been detected prior to
   ** invoking this routine */
@@ -98842,9 +98840,9 @@
   i64 *piOffset,                  /* IN/OUT: Readr offset in pTask->file */
   MergeEngine **ppOut             /* OUT: New merge-engine */
 ){
-  MergeEngine *pNew = NULL;              /* Merge engine to return */
+  MergeEngine *pNew;              /* Merge engine to return */
   i64 iOff = *piOffset;
-  int i = 0;
+  int i;
   int rc = SQLITE_OK;
 
   *ppOut = pNew = vdbeMergeEngineNew(nPMA);
@@ -98902,9 +98900,9 @@
 ){
   int rc = SQLITE_OK;
   int nDiv = 1;
-  int i = 0;
+  int i;
   MergeEngine *p = pRoot;
-  IncrMerger *pIncr = NULL;
+  IncrMerger *pIncr;
 
   rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);
 
@@ -98955,7 +98953,7 @@
 ){
   MergeEngine *pMain = 0;
   int rc = SQLITE_OK;
-  int iTask = 0;
+  int iTask;
 
 #if SQLITE_MAX_WORKER_THREADS>0
   /* If the sorter uses more than one task, then create the top-level
@@ -98979,13 +98977,13 @@
       if( pTask->nPMA<=SORTER_MAX_MERGE_COUNT ){
         rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);
       }else{
-        int i = 0;
+        int i;
         int iSeq = 0;
         pRoot = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);
         if( pRoot==0 ) rc = SQLITE_NOMEM_BKPT;
         for(i=0; i<pTask->nPMA && rc==SQLITE_OK; i += SORTER_MAX_MERGE_COUNT){
           MergeEngine *pMerger = 0; /* New level-0 PMA merger */
-          int nReader = 0;              /* Number of level-0 PMAs to merge */
+          int nReader;              /* Number of level-0 PMAs to merge */
 
           nReader = MIN(pTask->nPMA - i, SORTER_MAX_MERGE_COUNT);
           rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);
@@ -99029,12 +99027,12 @@
 ** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
 */
 static int vdbeSorterSetupMerge(VdbeSorter *pSorter){
-  int rc = 0;                         /* Return code */
+  int rc;                         /* Return code */
   SortSubtask *pTask0 = &pSorter->aTask[0];
   MergeEngine *pMain = 0;
 #if SQLITE_MAX_WORKER_THREADS
   sqlite3 *db = pTask0->pSorter->db;
-  int i = 0;
+  int i;
   SorterCompare xCompare = vdbeSorterGetCompare(pSorter);
   for(i=0; i<pSorter->nTask; i++){
     pSorter->aTask[i].xCompare = xCompare;
@@ -99046,7 +99044,7 @@
 #if SQLITE_MAX_WORKER_THREADS
     assert( pSorter->bUseThreads==0 || pSorter->nTask>1 );
     if( pSorter->bUseThreads ){
-      int iTask = 0;
+      int iTask;
       PmaReader *pReadr = 0;
       SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];
       rc = vdbeSortAllocUnpacked(pLast);
@@ -99060,7 +99058,7 @@
         if( rc==SQLITE_OK ){
           vdbeIncrMergerSetThreads(pReadr->pIncr);
           for(iTask=0; iTask<(pSorter->nTask-1); iTask++){
-            IncrMerger *pIncr = NULL;
+            IncrMerger *pIncr;
             if( (pIncr = pMain->aReadr[iTask].pIncr) ){
               vdbeIncrMergerSetThreads(pIncr);
               assert( pIncr->pTask!=pLast );
@@ -99111,7 +99109,7 @@
 ** in sorted order.
 */
 SQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){
-  VdbeSorter *pSorter = NULL;
+  VdbeSorter *pSorter;
   int rc = SQLITE_OK;             /* Return code */
 
   assert( pCsr->eCurType==CURTYPE_SORTER );
@@ -99163,8 +99161,8 @@
 **    otherwise     some kind of error.
 */
 SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr){
-  VdbeSorter *pSorter = NULL;
-  int rc = 0;                         /* Return code */
+  VdbeSorter *pSorter;
+  int rc;                         /* Return code */
 
   assert( pCsr->eCurType==CURTYPE_SORTER );
   pSorter = pCsr->uc.pSorter;
@@ -99204,9 +99202,9 @@
   const VdbeSorter *pSorter,      /* Sorter object */
   int *pnKey                      /* OUT: Size of current key in bytes */
 ){
-  void *pKey = NULL;
+  void *pKey;
   if( pSorter->bUsePMA ){
-    PmaReader *pReader = NULL;
+    PmaReader *pReader;
 #if SQLITE_MAX_WORKER_THREADS>0
     if( pSorter->bUseThreads ){
       pReader = pSorter->pReader;
@@ -99228,8 +99226,8 @@
 ** Copy the current sorter key into the memory cell pOut.
 */
 SQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut){
-  VdbeSorter *pSorter = NULL;
-  void *pKey = NULL; int nKey = 0;           /* Sorter key to copy into pOut */
+  VdbeSorter *pSorter;
+  void *pKey; int nKey;           /* Sorter key to copy into pOut */
 
   assert( pCsr->eCurType==CURTYPE_SORTER );
   pSorter = pCsr->uc.pSorter;
@@ -99266,11 +99264,11 @@
   int nKeyCol,                    /* Compare this many columns */
   int *pRes                       /* OUT: Result of comparison */
 ){
-  VdbeSorter *pSorter = NULL;
-  UnpackedRecord *r2 = NULL;
-  KeyInfo *pKeyInfo = NULL;
-  int i = 0;
-  void *pKey = NULL; int nKey = 0;           /* Sorter key to compare pVal with */
+  VdbeSorter *pSorter;
+  UnpackedRecord *r2;
+  KeyInfo *pKeyInfo;
+  int i;
+  void *pKey; int nKey;           /* Sorter key to compare pVal with */
 
   assert( pCsr->eCurType==CURTYPE_SORTER );
   pSorter = pCsr->uc.pSorter;
@@ -99819,8 +99817,8 @@
   MemJournal *p = (MemJournal *)pJfd;
   u8 *zOut = zBuf;
   int nRead = iAmt;
-  int iChunkOffset = 0;
-  FileChunk *pChunk = NULL;
+  int iChunkOffset;
+  FileChunk *pChunk;
 
   if( (iAmt+iOfst)>p->endpoint.iOffset ){
     return SQLITE_IOERR_SHORT_READ;
@@ -99858,8 +99856,8 @@
 ** Free the list of FileChunk structures headed at MemJournal.pFirst.
 */
 static void memjrnlFreeChunks(FileChunk *pFirst){
-  FileChunk *pIter = NULL;
-  FileChunk *pNext = NULL;
+  FileChunk *pIter;
+  FileChunk *pNext;
   for(pIter=pFirst; pIter; pIter=pNext){
     pNext = pIter->pNext;
     sqlite3_free(pIter);
@@ -99870,7 +99868,7 @@
 ** Flush the contents of memory to a real file on disk.
 */
 static int memjrnlCreateFile(MemJournal *p){
-  int rc = 0;
+  int rc;
   sqlite3_file *pReal = (sqlite3_file*)p;
   MemJournal copy = *p;
 
@@ -99879,7 +99877,7 @@
   if( rc==SQLITE_OK ){
     int nChunk = copy.nChunkSize;
     i64 iOff = 0;
-    FileChunk *pIter = NULL;
+    FileChunk *pIter;
     for(pIter=copy.pFirst; pIter; pIter=pIter->pNext){
       if( iOff + nChunk > copy.endpoint.iOffset ){
         nChunk = copy.endpoint.iOffset - iOff;
@@ -100191,9 +100189,9 @@
 ** as the second argument.
 */
 static int walkWindowList(Walker *pWalker, Window *pList, int bOneOnly){
-  Window *pWin = NULL;
+  Window *pWin;
   for(pWin=pList; pWin; pWin=pWin->pNextWin){
-    int rc = 0;
+    int rc;
     rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);
     if( rc ) return WRC_Abort;
     rc = sqlite3WalkExprList(pWalker, pWin->pPartition);
@@ -100230,7 +100228,7 @@
 ** and WRC_Continue to continue.
 */
 static SQLITE_NOINLINE int walkExpr(Walker *pWalker, Expr *pExpr){
-  int rc = 0;
+  int rc;
   testcase( ExprHasProperty(pExpr, EP_TokenOnly) );
   testcase( ExprHasProperty(pExpr, EP_Reduced) );
   while(1){
@@ -100270,8 +100268,8 @@
 ** an abort request is seen.
 */
 SQLITE_PRIVATE int sqlite3WalkExprList(Walker *pWalker, ExprList *p){
-  int i = 0;
-  struct ExprList_item *pItem = NULL;
+  int i;
+  struct ExprList_item *pItem;
   if( p ){
     for(i=p->nExpr, pItem=p->a; i>0; i--, pItem++){
       if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) return WRC_Abort;
@@ -100305,7 +100303,7 @@
   if( sqlite3WalkExpr(pWalker, p->pLimit) ) return WRC_Abort;
 #if !defined(SQLITE_OMIT_WINDOWFUNC)
   if( p->pWinDefn ){
-    Parse *pParse = NULL;
+    Parse *pParse;
     if( pWalker->xSelectCallback2==sqlite3WalkWinDefnDummyCallback
      || ((pParse = pWalker->pParse)!=0 && IN_RENAME_OBJECT)
 #ifndef SQLITE_OMIT_CTE
@@ -100330,9 +100328,9 @@
 ** WRC_Abort or WRC_Continue;
 */
 SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
-  SrcList *pSrc = NULL;
-  int i = 0;
-  SrcItem *pItem = NULL;
+  SrcList *pSrc;
+  int i;
+  SrcItem *pItem;
 
   pSrc = p->pSrc;
   if( ALWAYS(pSrc) ){
@@ -100368,7 +100366,7 @@
 ** is a no-op returning WRC_Continue.
 */
 SQLITE_PRIVATE int sqlite3WalkSelect(Walker *pWalker, Select *p){
-  int rc = 0;
+  int rc;
   if( p==0 ) return WRC_Continue;
   if( pWalker->xSelectCallback==0 ) return WRC_Continue;
   do{
@@ -100500,9 +100498,9 @@
   Expr *pExpr,           /* Transform this into an alias to the result set */
   int nSubquery          /* Number of subqueries that the label is moving */
 ){
-  Expr *pOrig = NULL;           /* The iCol-th column of the result set */
-  Expr *pDup = NULL;            /* Copy of pOrig */
-  sqlite3 *db = NULL;           /* The database connection */
+  Expr *pOrig;           /* The iCol-th column of the result set */
+  Expr *pDup;            /* Copy of pOrig */
+  sqlite3 *db;           /* The database connection */
 
   assert( iCol>=0 && iCol<pEList->nExpr );
   pOrig = pEList->a[iCol].pExpr;
@@ -100552,7 +100550,7 @@
 */
 static int nameInUsingClause(IdList *pUsing, const char *zCol){
   if( pUsing ){
-    int k = 0;
+    int k;
     for(k=0; k<pUsing->nId; k++){
       if( sqlite3StrICmp(pUsing->a[k].zName, zCol)==0 ) return 1;
     }
@@ -100573,8 +100571,8 @@
   const char *zTab,
   const char *zDb
 ){
-  int n = 0;
-  const char *zSpan = NULL;
+  int n;
+  const char *zSpan;
   if( pItem->eEName!=ENAME_TAB ) return 0;
   zSpan = pItem->zEName;
   for(n=0; ALWAYS(zSpan[n]) && zSpan[n]!='.'; n++){}
@@ -100615,8 +100613,8 @@
 ** return the appropriate colUsed mask.
 */
 SQLITE_PRIVATE Bitmask sqlite3ExprColUsed(Expr *pExpr){
-  int n = 0;
-  Table *pExTab = NULL;
+  int n;
+  Table *pExTab;
 
   n = pExpr->iColumn;
   assert( ExprUseYTab(pExpr) );
@@ -100671,18 +100669,18 @@
   NameContext *pNC,    /* The name context used to resolve the name */
   Expr *pExpr          /* Make this EXPR node point to the selected column */
 ){
-  int i = 0, j = 0;                         /* Loop counters */
+  int i, j;                         /* Loop counters */
   int cnt = 0;                      /* Number of matching column names */
   int cntTab = 0;                   /* Number of matching table names */
   int nSubquery = 0;                /* How many levels of subquery */
   sqlite3 *db = pParse->db;         /* The database connection */
-  SrcItem *pItem = NULL;                   /* Use for looping over pSrcList items */
+  SrcItem *pItem;                   /* Use for looping over pSrcList items */
   SrcItem *pMatch = 0;              /* The matching pSrcList item */
   NameContext *pTopNC = pNC;        /* First namecontext in the list */
   Schema *pSchema = 0;              /* Schema of the expression */
   int eNewExprOp = TK_COLUMN;       /* New value for pExpr->op on success */
   Table *pTab = 0;                  /* Table hold the row */
-  Column *pCol = NULL;                     /* A column of pTab */
+  Column *pCol;                     /* A column of pTab */
 
   assert( pNC );     /* the name context cannot be NULL. */
   assert( zCol );    /* The Z in X.Y.Z cannot be NULL */
@@ -100725,12 +100723,12 @@
   /* Start at the inner-most context and move outward until a match is found */
   assert( pNC && cnt==0 );
   do{
-    ExprList *pEList = NULL;
+    ExprList *pEList;
     SrcList *pSrcList = pNC->pSrcList;
 
     if( pSrcList ){
       for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){
-        u8 hCol = 0;
+        u8 hCol;
         pTab = pItem->pTab;
         assert( pTab!=0 && pTab->zName!=0 );
         assert( pTab->nCol>0 || pParse->nErr );
@@ -100840,7 +100838,7 @@
 #endif /* SQLITE_OMIT_UPSERT */
 
       if( pTab ){
-        int iCol = 0;
+        int iCol;
         u8 hCol = sqlite3StrIHash(zCol);
         pSchema = pTab->pSchema;
         cntTab++;
@@ -100951,7 +100949,7 @@
         if( pEList->a[j].eEName==ENAME_NAME
          && sqlite3_stricmp(zAs, zCol)==0
         ){
-          Expr *pOrig = NULL;
+          Expr *pOrig;
           assert( pExpr->pLeft==0 && pExpr->pRight==0 );
           assert( ExprUseXList(pExpr)==0 || pExpr->x.pList==0 );
           assert( ExprUseXSelect(pExpr)==0 || pExpr->x.pSelect==0 );
@@ -101039,7 +101037,7 @@
   ** more matches.  Either way, we have an error.
   */
   if( cnt!=1 ){
-    const char *zErr = NULL;
+    const char *zErr;
     zErr = cnt==0 ? "no such column" : "ambiguous column name";
     if( zDb ){
       sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
@@ -101113,7 +101111,7 @@
   Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);
   if( p ){
     SrcItem *pItem = &pSrc->a[iSrc];
-    Table *pTab = NULL;
+    Table *pTab;
     assert( ExprUseYTab(p) );
     pTab = p->y.pTab = pItem->pTab;
     p->iTable = pItem->iCursor;
@@ -101203,8 +101201,8 @@
 ** to TK_AGG_FUNCTION.
 */
 static int resolveExprStep(Walker *pWalker, Expr *pExpr){
-  NameContext *pNC = NULL;
-  Parse *pParse = NULL;
+  NameContext *pNC;
+  Parse *pParse;
 
   pNC = pWalker->u.pNC;
   assert( pNC!=0 );
@@ -101229,7 +101227,7 @@
     */
     case TK_ROW: {
       SrcList *pSrcList = pNC->pSrcList;
-      SrcItem *pItem = NULL;
+      SrcItem *pItem;
       assert( pSrcList && pSrcList->nSrc>=1 );
       pItem = pSrcList->a;
       pExpr->op = TK_COLUMN;
@@ -101258,8 +101256,8 @@
     case TK_NOTNULL:
     case TK_ISNULL: {
       int anRef[8];
-      NameContext *p = NULL;
-      int i = 0;
+      NameContext *p;
+      int i;
       for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){
         anRef[i] = p->nRef;
       }
@@ -101294,10 +101292,10 @@
     */
     case TK_ID:
     case TK_DOT: {
-      const char *zColumn = NULL;
-      const char *zTable = NULL;
-      const char *zDb = NULL;
-      Expr *pRight = NULL;
+      const char *zColumn;
+      const char *zTable;
+      const char *zDb;
+      Expr *pRight;
 
       if( pExpr->op==TK_ID ){
         zDb = 0;
@@ -101340,8 +101338,8 @@
       int no_such_func = 0;       /* True if no such function exists */
       int wrong_num_args = 0;     /* True if wrong number of arguments */
       int is_agg = 0;             /* True if is an aggregate function */
-      const char *zId = NULL;            /* The function name. */
-      FuncDef *pDef = NULL;              /* Information about the function */
+      const char *zId;            /* The function name. */
+      FuncDef *pDef;              /* Information about the function */
       u8 enc = ENC(pParse->db);   /* The database encoding */
       int savedAllowFlags = (pNC->ncFlags & (NC_AllowAgg | NC_AllowWin));
 #ifndef SQLITE_OMIT_WINDOWFUNC
@@ -101451,7 +101449,7 @@
            || (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !pWin)
            || (is_agg && pWin && (pNC->ncFlags & NC_AllowWin)==0)
         ){
-          const char *zType = NULL;
+          const char *zType;
           if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || pWin ){
             zType = "window";
           }else{
@@ -101523,7 +101521,7 @@
         }else
 #endif /* SQLITE_OMIT_WINDOWFUNC */
         {
-          NameContext *pNC2 = NULL;          /* For looping up thru outer contexts */
+          NameContext *pNC2;          /* For looping up thru outer contexts */
           pExpr->op = TK_AGG_FUNCTION;
           pExpr->op2 = 0;
 #ifndef SQLITE_OMIT_WINDOWFUNC
@@ -101614,7 +101612,7 @@
     case TK_LE:
     case TK_GT:
     case TK_GE: {
-      int nLeft = 0, nRight = 0;
+      int nLeft, nRight;
       if( pParse->db->mallocFailed ) break;
       assert( pExpr->pLeft!=0 );
       nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
@@ -101665,12 +101663,12 @@
   ExprList *pEList,  /* List of expressions to scan */
   Expr *pE           /* Expression we are trying to match */
 ){
-  int i = 0;             /* Loop counter */
+  int i;             /* Loop counter */
 
   UNUSED_PARAMETER(pParse);
 
   if( pE->op==TK_ID ){
-    const char *zCol = NULL;
+    const char *zCol;
     assert( !ExprHasProperty(pE, EP_IntValue) );
     zCol = pE->u.zToken;
     for(i=0; i<pEList->nExpr; i++){
@@ -101707,12 +101705,12 @@
   Select *pSelect,   /* The SELECT statement with the ORDER BY clause */
   Expr *pE           /* The specific ORDER BY term */
 ){
-  int i = 0;             /* Loop counter */
-  ExprList *pEList = NULL;  /* The columns of the result set */
+  int i;             /* Loop counter */
+  ExprList *pEList;  /* The columns of the result set */
   NameContext nc;    /* Name context for resolving pE */
-  sqlite3 *db = NULL;       /* Database connection */
-  int rc = 0;            /* Return code from subprocedures */
-  u8 savedSuppErr = 0;   /* Saved value of db->suppressErr */
+  sqlite3 *db;       /* Database connection */
+  int rc;            /* Return code from subprocedures */
+  u8 savedSuppErr;   /* Saved value of db->suppressErr */
 
   assert( sqlite3ExprIsInteger(pE, &i)==0 );
   pEList = pSelect->pEList;
@@ -101781,10 +101779,10 @@
   Parse *pParse,        /* Parsing context.  Leave error messages here */
   Select *pSelect       /* The SELECT statement containing the ORDER BY */
 ){
-  int i = 0;
-  ExprList *pOrderBy = NULL;
-  ExprList *pEList = NULL;
-  sqlite3 *db = NULL;
+  int i;
+  ExprList *pOrderBy;
+  ExprList *pEList;
+  sqlite3 *db;
   int moreToDo = 1;
 
   pOrderBy = pSelect->pOrderBy;
@@ -101803,13 +101801,13 @@
     pSelect = pSelect->pPrior;
   }
   while( pSelect && moreToDo ){
-    struct ExprList_item *pItem = NULL;
+    struct ExprList_item *pItem;
     moreToDo = 0;
     pEList = pSelect->pEList;
     assert( pEList!=0 );
     for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
       int iCol = -1;
-      Expr *pE = NULL, *pDup = NULL;
+      Expr *pE, *pDup;
       if( pItem->done ) continue;
       pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
       if( NEVER(pE==0) ) continue;
@@ -101896,10 +101894,10 @@
   ExprList *pOrderBy,   /* The ORDER BY or GROUP BY clause to be processed */
   const char *zType     /* "ORDER" or "GROUP" */
 ){
-  int i = 0;
+  int i;
   sqlite3 *db = pParse->db;
-  ExprList *pEList = NULL;
-  struct ExprList_item *pItem = NULL;
+  ExprList *pEList;
+  struct ExprList_item *pItem;
 
   if( pOrderBy==0 || pParse->db->mallocFailed || IN_RENAME_OBJECT ) return 0;
   if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){
@@ -101974,11 +101972,11 @@
   ExprList *pOrderBy,   /* An ORDER BY or GROUP BY clause to resolve */
   const char *zType     /* Either "ORDER" or "GROUP", as appropriate */
 ){
-  int i = 0, j = 0;                      /* Loop counters */
-  int iCol = 0;                      /* Column number */
-  struct ExprList_item *pItem = NULL;   /* A term of the ORDER BY clause */
-  Parse *pParse = NULL;                 /* Parsing context */
-  int nResult = 0;                   /* Number of terms in the result set */
+  int i, j;                      /* Loop counters */
+  int iCol;                      /* Column number */
+  struct ExprList_item *pItem;   /* A term of the ORDER BY clause */
+  Parse *pParse;                 /* Parsing context */
+  int nResult;                   /* Number of terms in the result set */
 
   assert( pOrderBy!=0 );
   nResult = pSelect->pEList->nExpr;
@@ -102032,15 +102030,15 @@
 ** Resolve names in the SELECT statement p and all of its descendants.
 */
 static int resolveSelectStep(Walker *pWalker, Select *p){
-  NameContext *pOuterNC = NULL;  /* Context that contains this SELECT */
+  NameContext *pOuterNC;  /* Context that contains this SELECT */
   NameContext sNC;        /* Name context of this SELECT */
-  int isCompound = 0;         /* True if p is a compound select */
-  int nCompound = 0;          /* Number of compound terms processed so far */
-  Parse *pParse = NULL;          /* Parsing context */
-  int i = 0;                  /* Loop counter */
-  ExprList *pGroupBy = NULL;     /* The GROUP BY clause */
-  Select *pLeftmost = NULL;      /* Left-most of SELECT of a compound */
-  sqlite3 *db = NULL;            /* Database connection */
+  int isCompound;         /* True if p is a compound select */
+  int nCompound;          /* Number of compound terms processed so far */
+  Parse *pParse;          /* Parsing context */
+  int i;                  /* Loop counter */
+  ExprList *pGroupBy;     /* The GROUP BY clause */
+  Select *pLeftmost;      /* Left-most of SELECT of a compound */
+  sqlite3 *db;            /* Database connection */
 
 
   assert( p!=0 );
@@ -102181,7 +102179,7 @@
 
 #ifndef SQLITE_OMIT_WINDOWFUNC
     if( IN_RENAME_OBJECT ){
-      Window *pWin = NULL;
+      Window *pWin;
       for(pWin=p->pWinDefn; pWin; pWin=pWin->pNextWin){
         if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)
          || sqlite3ResolveExprListNames(&sNC, pWin->pPartition)
@@ -102234,7 +102232,7 @@
     ** the GROUP BY clause does not contain aggregate functions.
     */
     if( pGroupBy ){
-      struct ExprList_item *pItem = NULL;
+      struct ExprList_item *pItem;
 
       if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){
         return WRC_Abort;
@@ -102323,7 +102321,7 @@
   NameContext *pNC,       /* Namespace to resolve expressions in. */
   Expr *pExpr             /* The expression to be analyzed. */
 ){
-  int savedHasAgg = 0;
+  int savedHasAgg;
   Walker w;
 
   if( pExpr==0 ) return SQLITE_OK;
@@ -102362,7 +102360,7 @@
   NameContext *pNC,       /* Namespace to resolve expressions in. */
   ExprList *pList         /* The expression list to be analyzed. */
 ){
-  int i = 0;
+  int i;
   int savedHasAgg = 0;
   Walker w;
   if( pList==0 ) return WRC_Continue;
@@ -102457,7 +102455,7 @@
 ){
   SrcList sSrc;                   /* Fake SrcList for pParse->pNewTable */
   NameContext sNC;                /* Name context for pParse->pNewTable */
-  int rc = 0;
+  int rc;
 
   assert( type==0 || pTab!=0 );
   assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr
@@ -102530,7 +102528,7 @@
 ** SELECT * FROM t1 WHERE (select a from t1);
 */
 SQLITE_PRIVATE char sqlite3ExprAffinity(const Expr *pExpr){
-  int op = 0;
+  int op;
   while( ExprHasProperty(pExpr, EP_Skip|EP_IfNullRow) ){
     assert( pExpr->op==TK_COLLATE
          || pExpr->op==TK_IF_NULL_ROW
@@ -102697,7 +102695,7 @@
         assert( ExprUseXList(p) );
         assert( p->x.pList==0 || p->pRight==0 );
         if( p->x.pList!=0 && !db->mallocFailed ){
-          int i = 0;
+          int i;
           for(i=0; ALWAYS(i<p->x.pList->nExpr); i++){
             if( ExprHasProperty(p->x.pList->a[i].pExpr, EP_Collate) ){
               pNext = p->x.pList->a[i].pExpr;
@@ -102771,7 +102769,7 @@
 ** be applied to both operands prior to doing the comparison.
 */
 static char comparisonAffinity(const Expr *pExpr){
-  char aff = 0;
+  char aff;
   assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||
           pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||
           pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );
@@ -102835,7 +102833,7 @@
   const Expr *pLeft,
   const Expr *pRight
 ){
-  CollSeq *pColl = NULL;
+  CollSeq *pColl;
   assert( pLeft );
   if( pLeft->flags & EP_Collate ){
     pColl = sqlite3ExprCollSeq(pParse, pLeft);
@@ -102879,9 +102877,9 @@
   int jumpIfNull,   /* If true, jump if either operand is NULL */
   int isCommuted    /* The comparison has been commuted */
 ){
-  int p5 = 0;
-  int addr = 0;
-  CollSeq *p4 = NULL;
+  int p5;
+  int addr;
+  CollSeq *p4;
 
   if( pParse->nErr ) return 0;
   if( isCommuted ){
@@ -102986,7 +102984,7 @@
   int iField,          /* Which column of the vector to return */
   int nField           /* Total number of columns in the vector */
 ){
-  Expr *pRet = NULL;
+  Expr *pRet;
   if( pVector->op==TK_SELECT ){
     assert( ExprUseXSelect(pVector) );
     /* The TK_SELECT_COLUMN Expr node:
@@ -103013,7 +103011,7 @@
     }
   }else{
     if( pVector->op==TK_VECTOR ){
-      Expr **ppVector = NULL;
+      Expr **ppVector;
       assert( ExprUseXList(pVector) );
       ppVector = &pVector->x.pList->a[iField].pExpr;
       pVector = *ppVector;
@@ -103113,7 +103111,7 @@
   Expr *pLeft = pExpr->pLeft;
   Expr *pRight = pExpr->pRight;
   int nLeft = sqlite3ExprVectorSize(pLeft);
-  int i = 0;
+  int i;
   int regLeft = 0;
   int regRight = 0;
   u8 opx = op;
@@ -103148,7 +103146,7 @@
   for(i=0; 1 /*Loop exits by "break"*/; i++){
     int regFree1 = 0, regFree2 = 0;
     Expr *pL = 0, *pR = 0;
-    int r1 = 0, r2 = 0;
+    int r1, r2;
     assert( i>=0 && i<nLeft );
     if( addrCmp ) sqlite3VdbeJumpHere(v, addrCmp);
     r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);
@@ -103227,14 +103225,14 @@
 }
 static void heightOfExprList(const ExprList *p, int *pnHeight){
   if( p ){
-    int i = 0;
+    int i;
     for(i=0; i<p->nExpr; i++){
       heightOfExpr(p->a[i].pExpr, pnHeight);
     }
   }
 }
 static void heightOfSelect(const Select *pSelect, int *pnHeight){
-  const Select *p = NULL;
+  const Select *p;
   for(p=pSelect; p; p=p->pPrior){
     heightOfExpr(p->pWhere, pnHeight);
     heightOfExpr(p->pHaving, pnHeight);
@@ -103330,7 +103328,7 @@
   const Token *pToken,    /* Token argument.  Might be NULL */
   int dequote             /* True to dequote */
 ){
-  Expr *pNew = NULL;
+  Expr *pNew;
   int nExtra = 0;
   int iValue = 0;
 
@@ -103425,7 +103423,7 @@
   Expr *pLeft,            /* Left operand */
   Expr *pRight            /* Right operand */
 ){
-  Expr *p = NULL;
+  Expr *p;
   p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));
   if( p ){
     memset(p, 0, sizeof(Expr));
@@ -103475,13 +103473,13 @@
 ** of vectors on the RHS. e.g. "... IN ((1,2), (3,4), (5,6))".
 */
 SQLITE_PRIVATE Select *sqlite3ExprListToValues(Parse *pParse, int nElem, ExprList *pEList){
-  int ii = 0;
+  int ii;
   Select *pRet = 0;
   assert( nElem>1 );
   for(ii=0; ii<pEList->nExpr; ii++){
-    Select *pSel = NULL;
+    Select *pSel;
     Expr *pExpr = pEList->a[ii].pExpr;
-    int nExprElem = 0;
+    int nExprElem;
     if( pExpr->op==TK_VECTOR ){
       assert( ExprUseXList(pExpr) );
       nExprElem = pExpr->x.pList->nExpr;
@@ -103548,7 +103546,7 @@
   const Token *pToken,  /* Name of the function */
   int eDistinct         /* SF_Distinct or SF_ALL or 0 */
 ){
-  Expr *pNew = NULL;
+  Expr *pNew;
   sqlite3 *db = pParse->db;
   assert( pToken );
   pNew = sqlite3ExprAlloc(db, TK_FUNCTION, pToken, 1);
@@ -103623,8 +103621,8 @@
 */
 SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n){
   sqlite3 *db = pParse->db;
-  const char *z = NULL;
-  ynVar x = 0;
+  const char *z;
+  ynVar x;
 
   if( pExpr==0 ) return;
   assert( !ExprHasProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) );
@@ -103641,8 +103639,8 @@
     if( z[0]=='?' ){
       /* Wildcard of the form "?nnn".  Convert "nnn" to an integer and
       ** use it as the variable number */
-      i64 i = 0;
-      int bOk = 0;
+      i64 i;
+      int bOk;
       if( n==2 ){ /*OPTIMIZATION-IF-TRUE*/
         i = z[1]-'0';  /* The common case of ?N for a single digit N */
         bOk = 1;
@@ -103810,7 +103808,7 @@
 ** to enforce this constraint.
 */
 static int dupedExprStructSize(const Expr *p, int flags){
-  int nSize = 0;
+  int nSize;
   assert( flags==EXPRDUP_REDUCE || flags==0 ); /* Only one flag value allowed */
   assert( EXPR_FULLSIZE<=0xfff );
   assert( (0xfff & (EP_Reduced|EP_TokenOnly))==0 );
@@ -103881,9 +103879,9 @@
 ** portion of the buffer copied into by this function.
 */
 static Expr *exprDup(sqlite3 *db, const Expr *p, int dupFlags, u8 **pzBuffer){
-  Expr *pNew = NULL;           /* Value to return */
-  u8 *zAlloc = NULL;           /* Memory space from which to build Expr object */
-  u32 staticFlag = 0;       /* EP_Static if space not obtained from malloc */
+  Expr *pNew;           /* Value to return */
+  u8 *zAlloc;           /* Memory space from which to build Expr object */
+  u32 staticFlag;       /* EP_Static if space not obtained from malloc */
 
   assert( db!=0 );
   assert( p );
@@ -103909,7 +103907,7 @@
     */
     const unsigned nStructSize = dupedExprStructSize(p, dupFlags);
     const int nNewSize = nStructSize & 0xfff;
-    int nToken = 0;
+    int nToken;
     if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){
       nToken = sqlite3Strlen30(p->u.zToken) + 1;
     }else{
@@ -103996,7 +103994,7 @@
     sqlite3_int64 nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte-1);
     pRet = sqlite3DbMallocZero(db, nByte);
     if( pRet ){
-      int i = 0;
+      int i;
       pRet->nCte = p->nCte;
       for(i=0; i<p->nCte; i++){
         pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);
@@ -104066,10 +104064,10 @@
   return p ? exprDup(db, p, flags, 0) : 0;
 }
 SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, const ExprList *p, int flags){
-  ExprList *pNew = NULL;
-  struct ExprList_item *pItem = NULL;
-  const struct ExprList_item *pOldItem = NULL;
-  int i = 0;
+  ExprList *pNew;
+  struct ExprList_item *pItem;
+  const struct ExprList_item *pOldItem;
+  int i;
   Expr *pPriorSelectColOld = 0;
   Expr *pPriorSelectColNew = 0;
   assert( db!=0 );
@@ -104082,7 +104080,7 @@
   pOldItem = p->a;
   for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){
     Expr *pOldExpr = pOldItem->pExpr;
-    Expr *pNewExpr = NULL;
+    Expr *pNewExpr;
     pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);
     if( pOldExpr
      && pOldExpr->op==TK_SELECT_COLUMN
@@ -104121,9 +104119,9 @@
 #if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) \
  || !defined(SQLITE_OMIT_SUBQUERY)
 SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, const SrcList *p, int flags){
-  SrcList *pNew = NULL;
-  int i = 0;
-  int nByte = 0;
+  SrcList *pNew;
+  int i;
+  int nByte;
   assert( db!=0 );
   if( p==0 ) return 0;
   nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);
@@ -104133,7 +104131,7 @@
   for(i=0; i<p->nSrc; i++){
     SrcItem *pNewItem = &pNew->a[i];
     const SrcItem *pOldItem = &p->a[i];
-    Table *pTab = NULL;
+    Table *pTab;
     pNewItem->pSchema = pOldItem->pSchema;
     pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);
     pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
@@ -104165,8 +104163,8 @@
   return pNew;
 }
 SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, const IdList *p){
-  IdList *pNew = NULL;
-  int i = 0;
+  IdList *pNew;
+  int i;
   assert( db!=0 );
   if( p==0 ) return 0;
   pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );
@@ -104192,7 +104190,7 @@
   Select *pRet = 0;
   Select *pNext = 0;
   Select **pp = &pRet;
-  const Select *p = NULL;
+  const Select *p;
 
   assert( db!=0 );
   for(p=pDup; p; p=p->pPrior){
@@ -104264,8 +104262,8 @@
   sqlite3 *db,            /* Database handle.  Used for memory allocation */
   Expr *pExpr             /* Expression to be appended. Might be NULL */
 ){
-  struct ExprList_item *pItem = NULL;
-  ExprList *pList = NULL;
+  struct ExprList_item *pItem;
+  ExprList *pList;
 
   pList = sqlite3DbMallocRawNN(db, sizeof(ExprList)+sizeof(pList->a[0])*4 );
   if( pList==0 ){
@@ -104284,8 +104282,8 @@
   ExprList *pList,        /* List to which to append. Might be NULL */
   Expr *pExpr             /* Expression to be appended. Might be NULL */
 ){
-  struct ExprList_item *pItem = NULL;
-  ExprList *pNew = NULL;
+  struct ExprList_item *pItem;
+  ExprList *pNew;
   pList->nAlloc *= 2;
   pNew = sqlite3DbRealloc(db, pList,
        sizeof(*pList)+(pList->nAlloc-1)*sizeof(pList->a[0]));
@@ -104306,7 +104304,7 @@
   ExprList *pList,        /* List to which to append. Might be NULL */
   Expr *pExpr             /* Expression to be appended. Might be NULL */
 ){
-  struct ExprList_item *pItem = NULL;
+  struct ExprList_item *pItem;
   if( pList==0 ){
     return sqlite3ExprListAppendNew(pParse->db,pExpr);
   }
@@ -104337,8 +104335,8 @@
   Expr *pExpr            /* Vector expression to be appended. Might be NULL */
 ){
   sqlite3 *db = pParse->db;
-  int n = 0;
-  int i = 0;
+  int n;
+  int i;
   int iFirst = pList ? pList->nExpr : 0;
   /* pColumns can only be NULL due to an OOM but an OOM will cause an
   ** exit prior to this routine being invoked */
@@ -104393,7 +104391,7 @@
 ** Set the sort order for the last element on the given ExprList.
 */
 SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){
-  struct ExprList_item *pItem = NULL;
+  struct ExprList_item *pItem;
   if( p==0 ) return;
   assert( p->nExpr>0 );
 
@@ -104439,7 +104437,7 @@
   assert( pList!=0 || pParse->db->mallocFailed!=0 );
   assert( pParse->eParseMode!=PARSE_MODE_UNMAP || dequote==0 );
   if( pList ){
-    struct ExprList_item *pItem = NULL;
+    struct ExprList_item *pItem;
     assert( pList->nExpr>0 );
     pItem = &pList->a[pList->nExpr-1];
     assert( pItem->zEName==0 );
@@ -104523,7 +104521,7 @@
 ** ExprList.
 */
 SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList *pList){
-  int i = 0;
+  int i;
   u32 m = 0;
   assert( pList!=0 );
   for(i=0; i<pList->nExpr; i++){
@@ -104568,7 +104566,7 @@
 ** the conversion happened, and zero if the expression is unaltered.
 */
 SQLITE_PRIVATE int sqlite3ExprIdToTrueFalse(Expr *pExpr){
-  u32 v = 0;
+  u32 v;
   assert( pExpr->op==TK_ID || pExpr->op==TK_STRING );
   if( !ExprHasProperty(pExpr, EP_Quoted|EP_IntValue)
    && (v = sqlite3IsTrueOrFalse(pExpr->u.zToken))!=0
@@ -104809,7 +104807,7 @@
 */
 static int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){
   ExprList *pGroupBy = pWalker->u.pGroupBy;
-  int i = 0;
+  int i;
 
   /* Check if pExpr is identical to any GROUP BY term. If so, consider
   ** it constant.  */
@@ -104959,7 +104957,7 @@
 ** TRUE.
 */
 SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr *p){
-  u8 op = 0;
+  u8 op;
   assert( p!=0 );
   while( p->op==TK_UPLUS || p->op==TK_UMINUS ){
     p = p->pLeft;
@@ -104996,7 +104994,7 @@
 ** answer.
 */
 SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){
-  u8 op = 0;
+  u8 op;
   int unaryMinus = 0;
   if( aff==SQLITE_AFF_BLOB ) return 1;
   while( p->op==TK_UPLUS || p->op==TK_UMINUS ){
@@ -105047,11 +105045,11 @@
 */
 #ifndef SQLITE_OMIT_SUBQUERY
 static Select *isCandidateForInOpt(const Expr *pX){
-  Select *p = NULL;
-  SrcList *pSrc = NULL;
-  ExprList *pEList = NULL;
-  Table *pTab = NULL;
-  int i = 0;
+  Select *p;
+  SrcList *pSrc;
+  ExprList *pEList;
+  Table *pTab;
+  int i;
   if( !ExprUseXSelect(pX) ) return 0;                 /* Not a subquery */
   if( ExprHasProperty(pX, EP_VarSelect)  ) return 0;  /* Correlated subq */
   p = pX->x.pSelect;
@@ -105092,7 +105090,7 @@
 ** to be set to NULL if iCur contains one or more NULL values.
 */
 static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){
-  int addr1 = 0;
+  int addr1;
   sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);
   addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);
   sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);
@@ -105109,8 +105107,8 @@
 ** right-hand side.  Return TRUE if that list is constant.
 */
 static int sqlite3InRhsIsConstant(Expr *pIn){
-  Expr *pLHS = NULL;
-  int res = 0;
+  Expr *pLHS;
+  int res;
   assert( !ExprHasProperty(pIn, EP_xIsSelect) );
   pLHS = pIn->pLeft;
   pIn->pLeft = 0;
@@ -105209,10 +105207,10 @@
   int *aiMap,                /* Mapping from Index fields to RHS fields */
   int *piTab                 /* OUT: index to use */
 ){
-  Select *p = NULL;                            /* SELECT to the right of IN operator */
+  Select *p;                            /* SELECT to the right of IN operator */
   int eType = 0;                        /* Type of RHS table. IN_INDEX_* */
   int iTab = pParse->nTab++;            /* Cursor of the RHS table */
-  int mustBeUnique = 0;                     /* True if RHS must be unique */
+  int mustBeUnique;                     /* True if RHS must be unique */
   Vdbe *v = sqlite3GetVdbe(pParse);     /* Virtual machine being coded */
 
   assert( pX->op==TK_IN );
@@ -105224,7 +105222,7 @@
   ** to NOT NULL constraints in the schema). If no NULL values are possible,
   ** set prRhsHasNull to 0 before continuing.  */
   if( prRhsHasNull && ExprUseXSelect(pX) ){
-    int i = 0;
+    int i;
     ExprList *pEList = pX->x.pSelect->pEList;
     for(i=0; i<pEList->nExpr; i++){
       if( sqlite3ExprCanBeNull(pEList->a[i].pExpr) ) break;
@@ -105239,8 +105237,8 @@
   ** ephemeral table.  */
   if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
     sqlite3 *db = pParse->db;              /* Database connection */
-    Table *pTab = NULL;                           /* Table <table>. */
-    int iDb = 0;                               /* Database idx for pTab */
+    Table *pTab;                           /* Table <table>. */
+    int iDb;                               /* Database idx for pTab */
     ExprList *pEList = p->pEList;
     int nExpr = pEList->nExpr;
 
@@ -105267,9 +105265,9 @@
             "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR",pTab->zName));
       sqlite3VdbeJumpHere(v, iAddr);
     }else{
-      Index *pIdx = NULL;                         /* Iterator variable */
+      Index *pIdx;                         /* Iterator variable */
       int affinity_ok = 1;
-      int i = 0;
+      int i;
 
       /* Check that the affinity that will be used to perform each
       ** comparison is the same as the affinity of each column in table
@@ -105300,8 +105298,8 @@
       if( affinity_ok ){
         /* Search for an existing index that will work for this IN operator */
         for(pIdx=pTab->pIndex; pIdx && eType==0; pIdx=pIdx->pNext){
-          Bitmask colUsed = 0;      /* Columns of the index used */
-          Bitmask mCol = 0;         /* Mask for the current column */
+          Bitmask colUsed;      /* Columns of the index used */
+          Bitmask mCol;         /* Mask for the current column */
           if( pIdx->nColumn<nExpr ) continue;
           if( pIdx->pPartIdxWhere!=0 ) continue;
           /* Maximum nColumn is BMS-2, not BMS-1, so that we can compute
@@ -105322,7 +105320,7 @@
             Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
             Expr *pRhs = pEList->a[i].pExpr;
             CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
-            int j = 0;
+            int j;
 
             assert( pReq!=0 || pRhs->iColumn==XN_ROWID || pParse->nErr );
             for(j=0; j<nExpr; j++){
@@ -105406,7 +105404,7 @@
   }
 
   if( aiMap && eType!=IN_INDEX_INDEX_ASC && eType!=IN_INDEX_INDEX_DESC ){
-    int i = 0, n = 0;
+    int i, n;
     n = sqlite3ExprVectorSize(pX->pLeft);
     for(i=0; i<n; i++) aiMap[i] = i;
   }
@@ -105428,12 +105426,12 @@
   Expr *pLeft = pExpr->pLeft;
   int nVal = sqlite3ExprVectorSize(pLeft);
   Select *pSelect = ExprUseXSelect(pExpr) ? pExpr->x.pSelect : 0;
-  char *zRet = NULL;
+  char *zRet;
 
   assert( pExpr->op==TK_IN );
   zRet = sqlite3DbMallocRaw(pParse->db, nVal+1);
   if( zRet ){
-    int i = 0;
+    int i;
     for(i=0; i<nVal; i++){
       Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);
       char a = sqlite3ExprAffinity(pA);
@@ -105515,11 +105513,11 @@
   int iTab                /* Use this cursor number */
 ){
   int addrOnce = 0;           /* Address of the OP_Once instruction at top */
-  int addr = 0;                   /* Address of OP_OpenEphemeral instruction */
-  Expr *pLeft = NULL;                /* the LHS of the IN operator */
+  int addr;                   /* Address of OP_OpenEphemeral instruction */
+  Expr *pLeft;                /* the LHS of the IN operator */
   KeyInfo *pKeyInfo = 0;      /* Key information */
-  int nVal = 0;                   /* Size of vector pLeft */
-  Vdbe *v = NULL;                    /* The prepared statement under construction */
+  int nVal;                   /* Size of vector pLeft */
+  Vdbe *v;                    /* The prepared statement under construction */
 
   v = pParse->pVdbe;
   assert( v!=0 );
@@ -105598,10 +105596,10 @@
     /* If the LHS and RHS of the IN operator do not match, that
     ** error will have been caught long before we reach this point. */
     if( ALWAYS(pEList->nExpr==nVal) ){
-      Select *pCopy = NULL;
+      Select *pCopy;
       SelectDest dest;
-      int i = 0;
-      int rc = 0;
+      int i;
+      int rc;
       sqlite3SelectDestInit(&dest, SRT_Set, iTab);
       dest.zAffSdst = exprINAffinity(pParse, pExpr);
       pSelect->iLimit = 0;
@@ -105634,11 +105632,11 @@
     ** that columns affinity when building index keys. If <expr> is not
     ** a column, use numeric affinity.
     */
-    char affinity = 0;            /* Affinity of the LHS of the IN */
-    int i = 0;
+    char affinity;            /* Affinity of the LHS of the IN */
+    int i;
     ExprList *pList = pExpr->x.pList;
-    struct ExprList_item *pItem = NULL;
-    int r1 = 0, r2 = 0;
+    struct ExprList_item *pItem;
+    int r1, r2;
     affinity = sqlite3ExprAffinity(pLeft);
     if( affinity<=SQLITE_AFF_NONE ){
       affinity = SQLITE_AFF_BLOB;
@@ -105707,10 +105705,10 @@
 SQLITE_PRIVATE int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){
   int addrOnce = 0;           /* Address of OP_Once at top of subroutine */
   int rReg = 0;               /* Register storing resulting */
-  Select *pSel = NULL;               /* SELECT statement to encode */
+  Select *pSel;               /* SELECT statement to encode */
   SelectDest dest;            /* How to deal with SELECT result */
-  int nReg = 0;                   /* Registers to allocate */
-  Expr *pLimit = NULL;               /* New limit expression */
+  int nReg;                   /* Registers to allocate */
+  Expr *pLimit;               /* New limit expression */
 
   Vdbe *v = pParse->pVdbe;
   assert( v!=0 );
@@ -105874,21 +105872,21 @@
   int destIfNull        /* Jump here if the results are unknown due to NULLs */
 ){
   int rRhsHasNull = 0;  /* Register that is true if RHS contains NULL values */
-  int eType = 0;            /* Type of the RHS */
-  int rLhs = 0;             /* Register(s) holding the LHS values */
-  int rLhsOrig = 0;         /* LHS values prior to reordering by aiMap[] */
-  Vdbe *v = NULL;              /* Statement under construction */
+  int eType;            /* Type of the RHS */
+  int rLhs;             /* Register(s) holding the LHS values */
+  int rLhsOrig;         /* LHS values prior to reordering by aiMap[] */
+  Vdbe *v;              /* Statement under construction */
   int *aiMap = 0;       /* Map from vector field to index column */
   char *zAff = 0;       /* Affinity string for comparisons */
-  int nVector = 0;          /* Size of vectors for this IN operator */
-  int iDummy = 0;           /* Dummy parameter to exprCodeVector() */
-  Expr *pLeft = NULL;          /* The LHS of the IN operator */
-  int i = 0;                /* loop counter */
-  int destStep2 = 0;        /* Where to jump when NULLs seen in step 2 */
+  int nVector;          /* Size of vectors for this IN operator */
+  int iDummy;           /* Dummy parameter to exprCodeVector() */
+  Expr *pLeft;          /* The LHS of the IN operator */
+  int i;                /* loop counter */
+  int destStep2;        /* Where to jump when NULLs seen in step 2 */
   int destStep6 = 0;    /* Start of code for Step 6 */
-  int addrTruthOp = 0;      /* Address of opcode that determines the IN is true */
-  int destNotNull = 0;      /* Jump here if a comparison is not true in step 6 */
-  int addrTop = 0;          /* Top of the step-6 loop */
+  int addrTruthOp;      /* Address of opcode that determines the IN is true */
+  int destNotNull;      /* Jump here if a comparison is not true in step 6 */
+  int addrTop;          /* Top of the step-6 loop */
   int iTab = 0;         /* Index to use */
   u8 okConstFactor = pParse->okConstFactor;
 
@@ -105962,12 +105960,12 @@
   ** This is step (1) in the in-operator.md optimized algorithm.
   */
   if( eType==IN_INDEX_NOOP ){
-    ExprList *pList = NULL;
-    CollSeq *pColl = NULL;
+    ExprList *pList;
+    CollSeq *pColl;
     int labelOk = sqlite3VdbeMakeLabel(pParse);
-    int r2 = 0, regToFree = 0;
+    int r2, regToFree;
     int regCkNull = 0;
-    int ii = 0;
+    int ii;
     assert( ExprUseXList(pExpr) );
     pList = pExpr->x.pList;
     pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
@@ -106082,8 +106080,8 @@
     destNotNull = destIfFalse;
   }
   for(i=0; i<nVector; i++){
-    Expr *p = NULL;
-    CollSeq *pColl = NULL;
+    Expr *p;
+    CollSeq *pColl;
     int r3 = sqlite3GetTempReg(pParse);
     p = sqlite3VectorFieldSubexpr(pLeft, i);
     pColl = sqlite3ExprCollSeq(pParse, p);
@@ -106127,7 +106125,7 @@
 */
 static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){
   if( ALWAYS(z!=0) ){
-    double value = 0;
+    double value;
     sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);
     assert( !sqlite3IsNaN(value) ); /* The new AtoF never returns NaN */
     if( negateFlag ) value = -value;
@@ -106151,8 +106149,8 @@
     if( negFlag ) i = -i;
     sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);
   }else{
-    int c = 0;
-    i64 value = 0;
+    int c;
+    i64 value;
     const char *z = pExpr->u.zToken;
     assert( z!=0 );
     c = sqlite3DecOrHexToI64(z, &value);
@@ -106212,7 +106210,7 @@
   Column *pCol,      /* The generated column */
   int regOut         /* Put the result in this register */
 ){
-  int iAddr = 0;
+  int iAddr;
   Vdbe *v = pParse->pVdbe;
   assert( v!=0 );
   assert( pParse->iSelfTab!=0 );
@@ -106239,7 +106237,7 @@
   int iCol,       /* Index of the column to extract */
   int regOut      /* Extract the value into this register */
 ){
-  Column *pCol = NULL;
+  Column *pCol;
   assert( v!=0 );
   if( pTab==0 ){
     sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);
@@ -106248,8 +106246,8 @@
   if( iCol<0 || iCol==pTab->iPKey ){
     sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);
   }else{
-    int op = 0;
-    int x = 0;
+    int op;
+    int x;
     if( IsVirtual(pTab) ){
       op = OP_VColumn;
       x = iCol;
@@ -106340,7 +106338,7 @@
 ** to 0.
 */
 static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){
-  int iResult = 0;
+  int iResult;
   int nResult = sqlite3ExprVectorSize(p);
   if( nResult==1 ){
     iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);
@@ -106353,7 +106351,7 @@
       iResult = sqlite3CodeSubselect(pParse, p);
 #endif
     }else{
-      int i = 0;
+      int i;
       iResult = pParse->nMem+1;
       pParse->nMem += nResult;
       assert( ExprUseXList(p) );
@@ -106385,7 +106383,7 @@
   int iFuncId,          /* Function ID.  One of the INTFUNC_... values */
   int target            /* Store function result in this register */
 ){
-  int nFarg = 0;
+  int nFarg;
   Vdbe *v = pParse->pVdbe;
   assert( v!=0 );
   assert( pFarg!=0 );
@@ -106398,7 +106396,7 @@
       ** arguments past the first non-NULL argument.
       */
       int endCoalesce = sqlite3VdbeMakeLabel(pParse);
-      int i = 0;
+      int i;
       assert( nFarg>=2 );
       sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
       for(i=1; i<nFarg; i++){
@@ -106452,7 +106450,7 @@
 
     case INLINEFUNC_implies_nonnull_row: {
       /* REsult of sqlite3ExprImpliesNonNullRow() */
-      Expr *pA1 = NULL;
+      Expr *pA1;
       assert( nFarg==2 );
       pA1 = pFarg->a[1].pExpr;
       if( pA1->op==TK_COLUMN ){
@@ -106471,7 +106469,7 @@
       ** the SQLite type logic.
       */
       const char *azAff[] = { "blob", "text", "numeric", "integer", "real" };
-      char aff = 0;
+      char aff;
       assert( nFarg==1 );
       aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);
       sqlite3VdbeLoadString(v, target,
@@ -106497,11 +106495,11 @@
 */
 SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){
   Vdbe *v = pParse->pVdbe;  /* The VM under construction */
-  int op = 0;                   /* The opcode being coded */
+  int op;                   /* The opcode being coded */
   int inReg = target;       /* Results stored in register inReg */
   int regFree1 = 0;         /* If non-zero free this temporary register */
   int regFree2 = 0;         /* If non-zero free this temporary register */
-  int r1 = 0, r2 = 0;               /* Various register numbers */
+  int r1, r2;               /* Various register numbers */
   Expr tempX;               /* Temporary expression node */
   int p5 = 0;
 
@@ -106518,7 +106516,7 @@
   switch( op ){
     case TK_AGG_COLUMN: {
       AggInfo *pAggInfo = pExpr->pAggInfo;
-      struct AggInfo_col *pCol = NULL;
+      struct AggInfo_col *pCol;
       assert( pAggInfo!=0 );
       assert( pExpr->iAgg>=0 && pExpr->iAgg<pAggInfo->nColumn );
       pCol = &pAggInfo->aCol[pExpr->iAgg];
@@ -106545,7 +106543,7 @@
     }
     case TK_COLUMN: {
       int iTab = pExpr->iTable;
-      int iReg = 0;
+      int iReg;
       if( ExprHasProperty(pExpr, EP_FixedCol) ){
         /* This COLUMN expression is really a constant due to WHERE clause
         ** constraints, and that constant is coded by the pExpr->pLeft
@@ -106553,7 +106551,7 @@
         ** datatype by applying the Affinity of the table column to the
         ** constant.
         */
-        int aff = 0;
+        int aff;
         iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);
         assert( ExprUseYTab(pExpr) );
         if( pExpr->y.pTab ){
@@ -106578,9 +106576,9 @@
           ** 0-(pParse->iSelfTab).  The rowid (if any) is in a register
           ** immediately prior to the first column.
           */
-          Column *pCol = NULL;
-          Table *pTab = NULL;
-          int iSrc = 0;
+          Column *pCol;
+          Table *pTab;
+          int iSrc;
           int iCol = pExpr->iColumn;
           assert( ExprUseYTab(pExpr) );
           pTab = pExpr->y.pTab;
@@ -106661,9 +106659,9 @@
     }
 #ifndef SQLITE_OMIT_BLOB_LITERAL
     case TK_BLOB: {
-      int n = 0;
-      const char *z = NULL;
-      char *zBlob = NULL;
+      int n;
+      const char *z;
+      char *zBlob;
       assert( !ExprHasProperty(pExpr, EP_IntValue) );
       assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );
       assert( pExpr->u.zToken[1]=='\'' );
@@ -106806,8 +106804,8 @@
       break;
     }
     case TK_TRUTH: {
-      int isTrue = 0;    /* IS TRUE or IS NOT TRUE */
-      int bNormal = 0;   /* IS TRUE or IS FALSE */
+      int isTrue;    /* IS TRUE or IS NOT TRUE */
+      int bNormal;   /* IS TRUE or IS FALSE */
       r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
       testcase( regFree1==0 );
       isTrue = sqlite3ExprTruthValue(pExpr->pRight);
@@ -106819,7 +106817,7 @@
     }
     case TK_ISNULL:
     case TK_NOTNULL: {
-      int addr = 0;
+      int addr;
       assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );
       assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );
       sqlite3VdbeAddOp2(v, OP_Integer, 1, target);
@@ -106846,12 +106844,12 @@
       break;
     }
     case TK_FUNCTION: {
-      ExprList *pFarg = NULL;       /* List of function arguments */
-      int nFarg = 0;             /* Number of function arguments */
-      FuncDef *pDef = NULL;         /* The function definition object */
-      const char *zId = NULL;       /* The function name */
+      ExprList *pFarg;       /* List of function arguments */
+      int nFarg;             /* Number of function arguments */
+      FuncDef *pDef;         /* The function definition object */
+      const char *zId;       /* The function name */
       u32 constMask = 0;     /* Mask of function arguments that are constant */
-      int i = 0;                 /* Loop counter */
+      int i;                 /* Loop counter */
       sqlite3 *db = pParse->db;  /* The database connection */
       u8 enc = ENC(db);      /* The text encoding used by this database */
       CollSeq *pColl = 0;    /* A collating sequence */
@@ -106915,7 +106913,7 @@
         ** loading.
         */
         if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){
-          u8 exprOp = 0;
+          u8 exprOp;
           assert( nFarg==1 );
           assert( pFarg->a[0].pExpr!=0 );
           exprOp = pFarg->a[0].pExpr->op;
@@ -106982,7 +106980,7 @@
 #ifndef SQLITE_OMIT_SUBQUERY
     case TK_EXISTS:
     case TK_SELECT: {
-      int nCol = 0;
+      int nCol;
       testcase( op==TK_EXISTS );
       testcase( op==TK_SELECT );
       if( pParse->db->mallocFailed ){
@@ -106998,7 +106996,7 @@
       break;
     }
     case TK_SELECT_COLUMN: {
-      int n = 0;
+      int n;
       if( pExpr->pLeft->iTable==0 ){
         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);
       }
@@ -107072,9 +107070,9 @@
       **   p1==1   ->    old.a         p1==4   ->    new.a
       **   p1==2   ->    old.b         p1==5   ->    new.b
       */
-      Table *pTab = NULL;
-      int iCol = 0;
-      int p1 = 0;
+      Table *pTab;
+      int iCol;
+      int p1;
 
       assert( ExprUseYTab(pExpr) );
       pTab = pExpr->y.pTab;
@@ -107118,7 +107116,7 @@
     ** on a LEFT JOIN NULL row.
     */
     case TK_IF_NULL_ROW: {
-      int addrINR = 0;
+      int addrINR;
       u8 okConstFactor = pParse->okConstFactor;
       addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);
       /* Temporarily disable factoring of constant expressions, since
@@ -107155,14 +107153,14 @@
     ** no ELSE term, NULL.
     */
     case TK_CASE: {
-      int endLabel = 0;                     /* GOTO label for end of CASE stmt */
-      int nextCase = 0;                     /* GOTO label for next WHEN clause */
-      int nExpr = 0;                        /* 2x number of WHEN terms */
-      int i = 0;                            /* Loop counter */
-      ExprList *pEList = NULL;                 /* List of WHEN terms */
-      struct ExprList_item *aListelem = NULL;  /* Array of WHEN terms */
+      int endLabel;                     /* GOTO label for end of CASE stmt */
+      int nextCase;                     /* GOTO label for next WHEN clause */
+      int nExpr;                        /* 2x number of WHEN terms */
+      int i;                            /* Loop counter */
+      ExprList *pEList;                 /* List of WHEN terms */
+      struct ExprList_item *aListelem;  /* Array of WHEN terms */
       Expr opCompare;                   /* The X==Ei expression */
-      Expr *pX = NULL;                         /* The X expression */
+      Expr *pX;                         /* The X expression */
       Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */
       Expr *pDel = 0;
       sqlite3 *db = pParse->db;
@@ -107274,12 +107272,12 @@
   Expr *pExpr,      /* The expression to code when the VDBE initializes */
   int regDest       /* Store the value in this register */
 ){
-  ExprList *p = NULL;
+  ExprList *p;
   assert( ConstFactorOk(pParse) );
   p = pParse->pConstExpr;
   if( regDest<0 && p ){
-    struct ExprList_item *pItem = NULL;
-    int i = 0;
+    struct ExprList_item *pItem;
+    int i;
     for(pItem=p->a, i=p->nExpr; i>0; pItem++, i--){
       if( pItem->reusable && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0 ){
         return pItem->u.iConstExprReg;
@@ -107289,7 +107287,7 @@
   pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);
   if( pExpr!=0 && ExprHasProperty(pExpr, EP_HasFunc) ){
     Vdbe *v = pParse->pVdbe;
-    int addr = 0;
+    int addr;
     assert( v );
     addr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
     pParse->okConstFactor = 0;
@@ -107327,7 +107325,7 @@
 ** VDBE program, in order to factor it out of the evaluation loop.
 */
 SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){
-  int r2 = 0;
+  int r2;
   pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
   if( ConstFactorOk(pParse)
    && ALWAYS(pExpr!=0)
@@ -107355,7 +107353,7 @@
 ** in register target.
 */
 SQLITE_PRIVATE void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){
-  int inReg = 0;
+  int inReg;
 
   assert( pExpr==0 || !ExprHasVVAProperty(pExpr,EP_Immutable) );
   assert( target>0 && target<=pParse->nMem );
@@ -107363,7 +107361,7 @@
   if( pParse->pVdbe==0 ) return;
   inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
   if( inReg!=target ){
-    u8 op = 0;
+    u8 op;
     if( ALWAYS(pExpr) && ExprHasProperty(pExpr,EP_Subquery) ){
       op = OP_Copy;
     }else{
@@ -107426,8 +107424,8 @@
   int srcReg,        /* Source registers if SQLITE_ECEL_REF */
   u8 flags           /* SQLITE_ECEL_* flags */
 ){
-  struct ExprList_item *pItem = NULL;
-  int i = 0, j = 0, n = 0;
+  struct ExprList_item *pItem;
+  int i, j, n;
   u8 copyOp = (flags & SQLITE_ECEL_DUP) ? OP_Copy : OP_SCopy;
   Vdbe *v = pParse->pVdbe;
   assert( pList!=0 );
@@ -107457,7 +107455,7 @@
     }else{
       int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);
       if( inReg!=target+i ){
-        VdbeOp *pOp = NULL;
+        VdbeOp *pOp;
         if( copyOp==OP_Copy
          && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==OP_Copy
          && pOp->p1+pOp->p3+1==inReg
@@ -107571,7 +107569,7 @@
   int op = 0;
   int regFree1 = 0;
   int regFree2 = 0;
-  int r1 = 0, r2 = 0;
+  int r1, r2;
 
   assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );
   if( NEVER(v==0) )     return;  /* Existence of VDBE checked by caller */
@@ -107604,8 +107602,8 @@
       break;
     }
     case TK_TRUTH: {
-      int isNot = 0;      /* IS NOT TRUE or IS NOT FALSE */
-      int isTrue = 0;     /* IS TRUE or IS NOT TRUE */
+      int isNot;      /* IS NOT TRUE or IS NOT FALSE */
+      int isTrue;     /* IS TRUE or IS NOT TRUE */
       testcase( jumpIfNull==0 );
       isNot = pExpr->op2==TK_ISNOT;
       isTrue = sqlite3ExprTruthValue(pExpr->pRight);
@@ -107713,7 +107711,7 @@
   int op = 0;
   int regFree1 = 0;
   int regFree2 = 0;
-  int r1 = 0, r2 = 0;
+  int r1, r2;
 
   assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );
   if( NEVER(v==0) ) return; /* Existence of VDBE checked by caller */
@@ -107777,8 +107775,8 @@
       break;
     }
     case TK_TRUTH: {
-      int isNot = 0;   /* IS NOT TRUE or IS NOT FALSE */
-      int isTrue = 0;  /* IS TRUE or IS NOT TRUE */
+      int isNot;   /* IS NOT TRUE or IS NOT FALSE */
+      int isTrue;  /* IS TRUE or IS NOT TRUE */
       testcase( jumpIfNull==0 );
       isNot = pExpr->op2==TK_ISNOT;
       isTrue = sqlite3ExprTruthValue(pExpr->pRight);
@@ -107908,8 +107906,8 @@
   const Expr *pExpr
 ){
   int res = 0;
-  int iVar = 0;
-  sqlite3_value *pL = NULL, *pR = 0;
+  int iVar;
+  sqlite3_value *pL, *pR = 0;
 
   sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, SQLITE_AFF_BLOB, &pR);
   if( pR ){
@@ -107964,7 +107962,7 @@
   const Expr *pB,
   int iTab
 ){
-  u32 combinedFlags = 0;
+  u32 combinedFlags;
   if( pA==0 || pB==0 ){
     return pB==pA ? 0 : 2;
   }
@@ -108055,12 +108053,12 @@
 ** always differs from a non-NULL pointer.
 */
 SQLITE_PRIVATE int sqlite3ExprListCompare(const ExprList *pA, const ExprList *pB, int iTab){
-  int i = 0;
+  int i;
   if( pA==0 && pB==0 ) return 0;
   if( pA==0 || pB==0 ) return 1;
   if( pA->nExpr!=pB->nExpr ) return 1;
   for(i=0; i<pA->nExpr; i++){
-    int res = 0;
+    int res;
     Expr *pExprA = pA->a[i].pExpr;
     Expr *pExprB = pB->a[i].pExpr;
     if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
@@ -108105,7 +108103,7 @@
       return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
     }
     case TK_BETWEEN: {
-      ExprList *pList = NULL;
+      ExprList *pList;
       assert( ExprUseXList(p) );
       pList = p->x.pList;
       assert( pList!=0 );
@@ -108421,8 +108419,8 @@
 static int selectRefEnter(Walker *pWalker, Select *pSelect){
   struct RefSrcList *p = pWalker->u.pRefSrcList;
   SrcList *pSrc = pSelect->pSrc;
-  i64 i = 0, j = 0;
-  int *piNew = NULL;
+  i64 i, j;
+  int *piNew;
   if( pSrc->nSrc==0 ) return WRC_Continue;
   j = p->nExclude;
   p->nExclude += pSrc->nSrc;
@@ -108459,7 +108457,7 @@
   if( pExpr->op==TK_COLUMN
    || pExpr->op==TK_AGG_COLUMN
   ){
-    int i = 0;
+    int i;
     struct RefSrcList *p = pWalker->u.pRefSrcList;
     SrcList *pSrc = p->pRef;
     int nSrc = pSrc ? pSrc->nSrc : 0;
@@ -108582,7 +108580,7 @@
 ** the new element.  Return a negative number if malloc fails.
 */
 static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){
-  int i = 0;
+  int i;
   pInfo->aCol = sqlite3ArrayAllocate(
        db,
        pInfo->aCol,
@@ -108598,7 +108596,7 @@
 ** the new element.  Return a negative number if malloc fails.
 */
 static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){
-  int i = 0;
+  int i;
   pInfo->aFunc = sqlite3ArrayAllocate(
        db,
        pInfo->aFunc,
@@ -108615,7 +108613,7 @@
 ** for additional information.
 */
 static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
-  int i = 0;
+  int i;
   NameContext *pNC = pWalker->u.pNC;
   Parse *pParse = pNC->pParse;
   SrcList *pSrcList = pNC->pSrcList;
@@ -108632,7 +108630,7 @@
       if( ALWAYS(pSrcList!=0) ){
         SrcItem *pItem = pSrcList->a;
         for(i=0; i<pSrcList->nSrc; i++, pItem++){
-          struct AggInfo_col *pCol = NULL;
+          struct AggInfo_col *pCol;
           assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
           if( pExpr->iTable==pItem->iCursor ){
             /* If we reach this point, it means that pExpr refers to a table
@@ -108641,7 +108639,7 @@
             ** Make an entry for the column in pAggInfo->aCol[] if there
             ** is not an entry there already.
             */
-            int k = 0;
+            int k;
             pCol = pAggInfo->aCol;
             for(k=0; k<pAggInfo->nColumn; k++, pCol++){
               if( pCol->iTable==pExpr->iTable &&
@@ -108661,7 +108659,7 @@
               pCol->iSorterColumn = -1;
               pCol->pCExpr = pExpr;
               if( pAggInfo->pGroupBy ){
-                int j = 0, n = 0;
+                int j, n;
                 ExprList *pGB = pAggInfo->pGroupBy;
                 struct ExprList_item *pTerm = pGB->a;
                 n = pGB->nExpr;
@@ -108771,8 +108769,8 @@
 ** If an error is found, the analysis is cut short.
 */
 SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){
-  struct ExprList_item *pItem = NULL;
-  int i = 0;
+  struct ExprList_item *pItem;
+  int i;
   if( pList ){
     for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){
       sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
@@ -108807,7 +108805,7 @@
 ** Allocate or deallocate a block of nReg consecutive registers.
 */
 SQLITE_PRIVATE int sqlite3GetTempRange(Parse *pParse, int nReg){
-  int i = 0, n = 0;
+  int i, n;
   if( nReg==1 ) return sqlite3GetTempReg(pParse);
   i = pParse->iRangeReg;
   n = pParse->nRangeReg;
@@ -108998,14 +108996,14 @@
   SrcList *pSrc,            /* The table to rename. */
   Token *pName              /* The new table name. */
 ){
-  int iDb = 0;                  /* Database that contains the table */
-  char *zDb = NULL;                /* Name of database iDb */
-  Table *pTab = NULL;              /* Table being renamed */
+  int iDb;                  /* Database that contains the table */
+  char *zDb;                /* Name of database iDb */
+  Table *pTab;              /* Table being renamed */
   char *zName = 0;          /* NULL-terminated version of pName */
   sqlite3 *db = pParse->db; /* Database connection */
-  int nTabName = 0;             /* Number of UTF-8 characters in zTabName */
-  const char *zTabName = NULL;     /* Original name of the table */
-  Vdbe *v = NULL;
+  int nTabName;             /* Number of UTF-8 characters in zTabName */
+  const char *zTabName;     /* Original name of the table */
+  Vdbe *v;
   VTable *pVTab = 0;        /* Non-zero if this is a v-tab with an xRename() */
 
   if( NEVER(db->mallocFailed) ) goto exit_rename_table;
@@ -109183,17 +109181,17 @@
 ** the new column during parsing.
 */
 SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){
-  Table *pNew = NULL;              /* Copy of pParse->pNewTable */
-  Table *pTab = NULL;              /* Table being altered */
-  int iDb = 0;                  /* Database number */
-  const char *zDb = NULL;          /* Database name */
-  const char *zTab = NULL;         /* Table name */
-  char *zCol = NULL;               /* Null-terminated column definition */
-  Column *pCol = NULL;             /* The new column */
-  Expr *pDflt = NULL;              /* Default value for the new column */
-  sqlite3 *db = NULL;              /* The database connection; */
-  Vdbe *v = NULL;                  /* The prepared statement under construction */
-  int r1 = 0;                   /* Temporary registers */
+  Table *pNew;              /* Copy of pParse->pNewTable */
+  Table *pTab;              /* Table being altered */
+  int iDb;                  /* Database number */
+  const char *zDb;          /* Database name */
+  const char *zTab;         /* Table name */
+  char *zCol;               /* Null-terminated column definition */
+  Column *pCol;             /* The new column */
+  Expr *pDflt;              /* Default value for the new column */
+  sqlite3 *db;              /* The database connection; */
+  Vdbe *v;                  /* The prepared statement under construction */
+  int r1;                   /* Temporary registers */
 
   db = pParse->db;
   assert( db->pParse==pParse );
@@ -109257,7 +109255,7 @@
     */
     if( pDflt ){
       sqlite3_value *pVal = 0;
-      int rc = 0;
+      int rc;
       rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);
       assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );
       if( rc!=SQLITE_OK ){
@@ -109348,11 +109346,11 @@
 ** coding the "ALTER TABLE ... ADD" statement.
 */
 SQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){
-  Table *pNew = NULL;
-  Table *pTab = NULL;
-  int iDb = 0;
-  int i = 0;
-  int nAlloc = 0;
+  Table *pNew;
+  Table *pTab;
+  int iDb;
+  int i;
+  int nAlloc;
   sqlite3 *db = pParse->db;
 
   /* Look up the table being altered. */
@@ -109467,13 +109465,13 @@
   Token *pNew                     /* New column name */
 ){
   sqlite3 *db = pParse->db;       /* Database connection */
-  Table *pTab = NULL;                    /* Table being updated */
-  int iCol = 0;                       /* Index of column being renamed */
+  Table *pTab;                    /* Table being updated */
+  int iCol;                       /* Index of column being renamed */
   char *zOld = 0;                 /* Old column name */
   char *zNew = 0;                 /* New column name */
-  const char *zDb = NULL;                /* Name of schema containing the table */
-  int iSchema = 0;                    /* Index of the schema */
-  int bQuote = 0;                     /* True to quote the new name */
+  const char *zDb;                /* Name of schema containing the table */
+  int iSchema;                    /* Index of the schema */
+  int bQuote;                     /* True to quote the new name */
 
   /* Locate the table to be altered */
   pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
@@ -109643,7 +109641,7 @@
   const void *pPtr,
   const Token *pToken
 ){
-  RenameToken *pNew = NULL;
+  RenameToken *pNew;
   assert( pPtr || pParse->db->mallocFailed );
   renameTokenCheckAll(pParse, pPtr);
   if( ALWAYS(pParse->eParseMode!=PARSE_MODE_UNMAP) ){
@@ -109665,7 +109663,7 @@
 ** to parse tree element pTo.
 */
 SQLITE_PRIVATE void sqlite3RenameTokenRemap(Parse *pParse, const void *pTo, const void *pFrom){
-  RenameToken *p = NULL;
+  RenameToken *p;
   renameTokenCheckAll(pParse, pTo);
   for(p=pParse->pRename; p; p=p->pNext){
     if( p->p==pFrom ){
@@ -109695,7 +109693,7 @@
   With *pWith = pSelect->pWith;
   if( pWith ){
     Parse *pParse = pWalker->pParse;
-    int i = 0;
+    int i;
     With *pCopy = 0;
     assert( pWith->nCte>0 );
     if( (pWith->a[0].pSelect->selFlags & SF_Expanded)==0 ){
@@ -109731,7 +109729,7 @@
   const IdList *pIdList
 ){
   if( pIdList ){
-    int ii = 0;
+    int ii;
     for(ii=0; ii<pIdList->nId; ii++){
       sqlite3RenameTokenRemap(pParse, 0, (const void*)pIdList->a[ii].zName);
     }
@@ -109743,7 +109741,7 @@
 */
 static int renameUnmapSelectCb(Walker *pWalker, Select *p){
   Parse *pParse = pWalker->pParse;
-  int i = 0;
+  int i;
   if( pParse->nErr ) return WRC_Abort;
   testcase( p->selFlags & SF_View );
   testcase( p->selFlags & SF_CopyCte );
@@ -109792,7 +109790,7 @@
 */
 SQLITE_PRIVATE void sqlite3RenameExprlistUnmap(Parse *pParse, ExprList *pEList){
   if( pEList ){
-    int i = 0;
+    int i;
     Walker sWalker;
     memset(&sWalker, 0, sizeof(Walker));
     sWalker.pParse = pParse;
@@ -109810,8 +109808,8 @@
 ** Free the list of RenameToken objects given in the second argument
 */
 static void renameTokenFree(sqlite3 *db, RenameToken *pToken){
-  RenameToken *pNext = NULL;
-  RenameToken *p = NULL;
+  RenameToken *pNext;
+  RenameToken *p;
   for(p=pToken; p; p=pNext){
     pNext = p->pNext;
     sqlite3DbFree(db, p);
@@ -109832,7 +109830,7 @@
   struct RenameCtx *pCtx,
   const void *pPtr
 ){
-  RenameToken **pp = NULL;
+  RenameToken **pp;
   if( NEVER(pPtr==0) ){
     return 0;
   }
@@ -109903,8 +109901,8 @@
 */
 static RenameToken *renameColumnTokenNext(RenameCtx *pCtx){
   RenameToken *pBest = pCtx->pList;
-  RenameToken *pToken = NULL;
-  RenameToken **pp = NULL;
+  RenameToken *pToken;
+  RenameToken **pp;
 
   for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){
     if( pToken->t.z>pBest->t.z ) pBest = pToken;
@@ -109931,7 +109929,7 @@
 ){
   const char *zT = (const char*)sqlite3_value_text(pType);
   const char *zN = (const char*)sqlite3_value_text(pObject);
-  char *zErr = NULL;
+  char *zErr;
 
   zErr = sqlite3MPrintf(pParse->db, "error in %s %s%s%s: %s",
       zT, zN, (zWhen[0] ? " " : ""), zWhen,
@@ -109954,7 +109952,7 @@
   const char *zOld
 ){
   if( pEList ){
-    int i = 0;
+    int i;
     for(i=0; i<pEList->nExpr; i++){
       const char *zName = pEList->a[i].zEName;
       if( ALWAYS(pEList->a[i].eEName==ENAME_NAME)
@@ -109979,7 +109977,7 @@
   const char *zOld
 ){
   if( pIdList ){
-    int i = 0;
+    int i;
     for(i=0; i<pIdList->nId; i++){
       const char *zName = pIdList->a[i].zName;
       if( 0==sqlite3_stricmp(zName, zOld) ){
@@ -110001,7 +109999,7 @@
   const char *zSql,               /* SQL to parse */
   int bTemp                       /* True if SQL is from temp schema */
 ){
-  int rc = 0;
+  int rc;
 
   sqlite3ParseObjectInit(p, db);
   if( zSql==0 ){
@@ -110059,7 +110057,7 @@
   sqlite3 *db = sqlite3_context_db_handle(pCtx);
   int rc = SQLITE_OK;
   char *zQuot = 0;
-  char *zOut = NULL;
+  char *zOut;
   i64 nQuot = 0;
   char *zBuf1 = 0;
   char *zBuf2 = 0;
@@ -110095,9 +110093,9 @@
     int nOut = nSql;
     memcpy(zOut, zSql, nSql);
     while( pRename->pList ){
-      int iOff = 0;                   /* Offset of token to replace in zOut */
-      u32 nReplace = 0;
-      const char *zReplace = NULL;
+      int iOff;                   /* Offset of token to replace in zOut */
+      u32 nReplace;
+      const char *zReplace;
       RenameToken *pBest = renameColumnTokenNext(pRename);
 
       if( zNew ){
@@ -110157,7 +110155,7 @@
 static int renameResolveTrigger(Parse *pParse){
   sqlite3 *db = pParse->db;
   Trigger *pNew = pParse->pNewTrigger;
-  TriggerStep *pStep = NULL;
+  TriggerStep *pStep;
   NameContext sNC;
   int rc = SQLITE_OK;
 
@@ -110187,7 +110185,7 @@
     if( rc==SQLITE_OK && pStep->zTarget ){
       SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);
       if( pSrc ){
-        int i = 0;
+        int i;
         for(i=0; i<pSrc->nSrc && rc==SQLITE_OK; i++){
           SrcItem *p = &pSrc->a[i];
           p->iCursor = pParse->nTab++;
@@ -110251,7 +110249,7 @@
 ** objects that are part of the trigger passed as the second argument.
 */
 static void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){
-  TriggerStep *pStep = NULL;
+  TriggerStep *pStep;
 
   /* Find tokens to edit in WHEN clause */
   sqlite3WalkExpr(pWalker, pTrigger->pWhen);
@@ -110269,7 +110267,7 @@
       sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);
     }
     if( pStep->pFrom ){
-      int i = 0;
+      int i;
       for(i=0; i<pStep->pFrom->nSrc; i++){
         sqlite3WalkSelect(pWalker, pStep->pFrom->a[i].pSelect);
       }
@@ -110283,7 +110281,7 @@
 */
 static void renameParseCleanup(Parse *pParse){
   sqlite3 *db = pParse->db;
-  Index *pIdx = NULL;
+  Index *pIdx;
   if( pParse->pVdbe ){
     sqlite3VdbeFinalize(pParse->pVdbe);
   }
@@ -110336,13 +110334,13 @@
   const char *zNew = (const char*)sqlite3_value_text(argv[6]);
   int bQuote = sqlite3_value_int(argv[7]);
   int bTemp = sqlite3_value_int(argv[8]);
-  const char *zOld = NULL;
-  int rc = 0;
+  const char *zOld;
+  int rc;
   Parse sParse;
   Walker sWalker;
-  Index *pIdx = NULL;
-  int i = 0;
-  Table *pTab = NULL;
+  Index *pIdx;
+  int i;
+  Table *pTab;
 #ifndef SQLITE_OMIT_AUTHORIZATION
   sqlite3_xauth xAuth = db->xAuth;
 #endif
@@ -110390,7 +110388,7 @@
     }else if( IsOrdinaryTable(sParse.pNewTable) ){
       /* A regular table */
       int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);
-      FKey *pFKey = NULL;
+      FKey *pFKey;
       sCtx.pTab = sParse.pNewTable;
       if( bFKOnly==0 ){
         if( iCol<sParse.pNewTable->nCol ){
@@ -110436,7 +110434,7 @@
     sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
   }else{
     /* A trigger */
-    TriggerStep *pStep = NULL;
+    TriggerStep *pStep;
     rc = renameResolveTrigger(&sParse);
     if( rc!=SQLITE_OK ) goto renameColumnFunc_done;
 
@@ -110504,7 +110502,7 @@
 ** Walker select callback used by "RENAME TABLE".
 */
 static int renameTableSelectCb(Walker *pWalker, Select *pSelect){
-  int i = 0;
+  int i;
   RenameCtx *p = pWalker->u.pRename;
   SrcList *pSrc = pSelect->pSrc;
   if( pSelect->selFlags & (SF_View|SF_CopyCte) ){
@@ -110562,7 +110560,7 @@
 
   if( zInput && zOld && zNew ){
     Parse sParse;
-    int rc = 0;
+    int rc;
     int bQuote = 1;
     RenameCtx sCtx;
     Walker sWalker;
@@ -110611,7 +110609,7 @@
           if( (isLegacy==0 || (db->flags & SQLITE_ForeignKeys))
            && !IsVirtual(pTab)
           ){
-            FKey *pFKey = NULL;
+            FKey *pFKey;
             assert( IsOrdinaryTable(pTab) );
             for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
               if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){
@@ -110644,7 +110642,7 @@
 #ifndef SQLITE_OMIT_TRIGGER
       else{
         Trigger *pTrigger = sParse.pNewTrigger;
-        TriggerStep *pStep = NULL;
+        TriggerStep *pStep;
         if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld)
             && sCtx.pTab->pSchema==pTrigger->pTabSchema
           ){
@@ -110742,7 +110740,7 @@
 
   UNUSED_PARAMETER(NotUsed);
   if( zDb && zInput ){
-    int rc = 0;
+    int rc;
     Parse sParse;
     rc = renameParseSql(&sParse, zDb, db, zInput, 0);
 
@@ -110769,7 +110767,7 @@
             sqlite3WalkSelect(&sWalker, pSelect);
           }
         }else{
-          int i = 0;
+          int i;
           sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);
 #ifndef SQLITE_OMIT_GENERATED_COLUMNS
           for(i=0; i<sParse.pNewTable->nCol; i++){
@@ -110858,7 +110856,7 @@
   UNUSED_PARAMETER(NotUsed);
 
   if( zDb && zInput ){
-    int rc = 0;
+    int rc;
     Parse sParse;
     int flags = db->flags;
     if( bNoDQS ) db->flags &= ~(SQLITE_DqsDML|SQLITE_DqsDDL);
@@ -110922,11 +110920,11 @@
   const char *zSql = (const char*)sqlite3_value_text(argv[1]);
   int iCol = sqlite3_value_int(argv[2]);
   const char *zDb = db->aDb[iSchema].zDbSName;
-  int rc = 0;
+  int rc;
   Parse sParse;
-  RenameToken *pCol = NULL;
-  Table *pTab = NULL;
-  const char *zEnd = NULL;
+  RenameToken *pCol;
+  Table *pTab;
+  const char *zEnd;
   char *zNew = 0;
 
 #ifndef SQLITE_OMIT_AUTHORIZATION
@@ -110946,7 +110944,7 @@
 
   pCol = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol].zCnName);
   if( iCol<pTab->nCol-1 ){
-    RenameToken *pEnd = NULL;
+    RenameToken *pEnd;
     pEnd = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol+1].zCnName);
     zEnd = (const char*)pEnd->t.z;
   }else{
@@ -110979,11 +110977,11 @@
 */
 SQLITE_PRIVATE void sqlite3AlterDropColumn(Parse *pParse, SrcList *pSrc, const Token *pName){
   sqlite3 *db = pParse->db;       /* Database handle */
-  Table *pTab = NULL;                    /* Table to modify */
-  int iDb = 0;                        /* Index of db containing pTab in aDb[] */
-  const char *zDb = NULL;                /* Database containing pTab ("main" etc.) */
+  Table *pTab;                    /* Table to modify */
+  int iDb;                        /* Index of db containing pTab in aDb[] */
+  const char *zDb;                /* Database containing pTab ("main" etc.) */
   char *zCol = 0;                 /* Name of column to drop */
-  int iCol = 0;                       /* Index of column zCol in pTab->aCol[] */
+  int iCol;                       /* Index of column zCol in pTab->aCol[] */
 
   /* Look up the table being altered. */
   assert( pParse->pNewTable==0 );
@@ -111050,13 +111048,13 @@
 
   /* Edit rows of table on disk */
   if( pParse->nErr==0 && (pTab->aCol[iCol].colFlags & COLFLAG_VIRTUAL)==0 ){
-    int i = 0;
-    int addr = 0;
-    int reg = 0;
-    int regRec = 0;
+    int i;
+    int addr;
+    int reg;
+    int regRec;
     Index *pPk = 0;
     int nField = 0;               /* Number of non-virtual columns after drop */
-    int iCur = 0;
+    int iCur;
     Vdbe *v = sqlite3GetVdbe(pParse);
     iCur = pParse->nTab++;
     sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenWrite);
@@ -111076,7 +111074,7 @@
     regRec = ++pParse->nMem;
     for(i=0; i<pTab->nCol; i++){
       if( i!=iCol && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){
-        int regOut = 0;
+        int regOut;
         if( pPk ){
           int iPos = sqlite3TableColumnToIndex(pPk, i);
           int iColPos = sqlite3TableColumnToIndex(pPk, iCol);
@@ -111317,9 +111315,9 @@
 #endif
     { "sqlite_stat3", 0 },
   };
-  int i = 0;
+  int i;
   sqlite3 *db = pParse->db;
-  Db *pDb = NULL;
+  Db *pDb;
   Vdbe *v = sqlite3GetVdbe(pParse);
   u32 aRoot[ArraySize(aTable)];
   u8 aCreateTbl[ArraySize(aTable)];
@@ -111339,7 +111337,7 @@
   */
   for(i=0; i<ArraySize(aTable); i++){
     const char *zTab = aTable[i].zName;
-    Table *pStat = NULL;
+    Table *pStat;
     aCreateTbl[i] = 0;
     if( (pStat = sqlite3FindTable(db, zTab, pDb->zDbSName))==0 ){
       if( i<nToOpen ){
@@ -111537,11 +111535,11 @@
   int argc,
   sqlite3_value **argv
 ){
-  StatAccum *p = NULL;
-  int nCol = 0;                       /* Number of columns in index being sampled */
-  int nKeyCol = 0;                    /* Number of key columns */
-  int nColUp = 0;                     /* nCol rounded up for alignment */
-  int n = 0;                          /* Bytes of space to allocate */
+  StatAccum *p;
+  int nCol;                       /* Number of columns in index being sampled */
+  int nKeyCol;                    /* Number of key columns */
+  int nColUp;                     /* nCol rounded up for alignment */
+  int n;                          /* Bytes of space to allocate */
   sqlite3 *db = sqlite3_context_db_handle(context);   /* Database connection */
 #ifdef SQLITE_ENABLE_STAT4
   /* Maximum number of samples.  0 if STAT4 data is not collected */
@@ -111838,7 +111836,7 @@
   int argc,
   sqlite3_value **argv
 ){
-  int i = 0;
+  int i;
 
   /* The three function arguments */
   StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);
@@ -111987,7 +111985,7 @@
     **        I = (K+D-1)/D
     */
     sqlite3_str sStat;   /* Text of the constructed "stat" line */
-    int i = 0;               /* Loop counter */
+    int i;               /* Loop counter */
 
     sqlite3StrAccumInit(&sStat, 0, 0, 0, (p->nKeyCol+1)*100);
     sqlite3_str_appendf(&sStat, "%llu",
@@ -112104,13 +112102,13 @@
   int iTab         /* Next available cursor */
 ){
   sqlite3 *db = pParse->db;    /* Database handle */
-  Index *pIdx = NULL;                 /* An index to being analyzed */
-  int iIdxCur = 0;                 /* Cursor open on index being analyzed */
-  int iTabCur = 0;                 /* Table cursor */
-  Vdbe *v = NULL;                     /* The virtual machine being built up */
-  int i = 0;                       /* Loop counter */
+  Index *pIdx;                 /* An index to being analyzed */
+  int iIdxCur;                 /* Cursor open on index being analyzed */
+  int iTabCur;                 /* Table cursor */
+  Vdbe *v;                     /* The virtual machine being built up */
+  int i;                       /* Loop counter */
   int jZeroRows = -1;          /* Jump from here if number of rows is zero */
-  int iDb = 0;                     /* Index of database containing pTab */
+  int iDb;                     /* Index of database containing pTab */
   u8 needTableCnt = 1;         /* True to count the table */
   int regNewRowid = iMem++;    /* Rowid for the inserted record */
   int regStat = iMem++;        /* Register to hold StatAccum object */
@@ -112174,11 +112172,11 @@
   sqlite3VdbeLoadString(v, regTabname, pTab->zName);
 
   for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-    int nCol = 0;                     /* Number of columns in pIdx. "N" */
-    int addrRewind = 0;               /* Address of "OP_Rewind iIdxCur" */
-    int addrNextRow = 0;              /* Address of "next_row:" */
-    const char *zIdxName = NULL;         /* Name of the index */
-    int nColTest = 0;                 /* Number of columns to test for changes */
+    int nCol;                     /* Number of columns in pIdx. "N" */
+    int addrRewind;               /* Address of "OP_Rewind iIdxCur" */
+    int addrNextRow;              /* Address of "next_row:" */
+    const char *zIdxName;         /* Name of the index */
+    int nColTest;                 /* Number of columns to test for changes */
 
     if( pOnlyIdx && pOnlyIdx!=pIdx ) continue;
     if( pIdx->pPartIdxWhere==0 ) needTableCnt = 0;
@@ -112280,7 +112278,7 @@
 
     if( nColTest>0 ){
       int endDistinctTest = sqlite3VdbeMakeLabel(pParse);
-      int *aGotoChng = NULL;               /* Array of jump instruction addresses */
+      int *aGotoChng;               /* Array of jump instruction addresses */
       aGotoChng = sqlite3DbMallocRawNN(db, sizeof(int)*nColTest);
       if( aGotoChng==0 ) continue;
 
@@ -112366,7 +112364,7 @@
       sqlite3VdbeAddFunctionCall(pParse, 1, regStat, regTemp, 2+IsStat4,
                                  &statPushFuncdef, 0);
       if( db->nAnalysisLimit ){
-        int j1 = 0, j2 = 0, j3 = 0;
+        int j1, j2, j3;
         j1 = sqlite3VdbeAddOp1(v, OP_IsNull, regTemp); VdbeCoverage(v);
         j2 = sqlite3VdbeAddOp1(v, OP_If, regTemp); VdbeCoverage(v);
         j3 = sqlite3VdbeAddOp4Int(v, OP_SeekGT, iIdxCur, 0, regPrev, 1);
@@ -112470,10 +112468,10 @@
 static void analyzeDatabase(Parse *pParse, int iDb){
   sqlite3 *db = pParse->db;
   Schema *pSchema = db->aDb[iDb].pSchema;    /* Schema of database iDb */
-  HashElem *k = NULL;
-  int iStatCur = 0;
-  int iMem = 0;
-  int iTab = 0;
+  HashElem *k;
+  int iStatCur;
+  int iMem;
+  int iTab;
 
   sqlite3BeginWriteOperation(pParse, 0, iDb);
   iStatCur = pParse->nTab;
@@ -112495,8 +112493,8 @@
 ** in pTab that should be analyzed.
 */
 static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx){
-  int iDb = 0;
-  int iStatCur = 0;
+  int iDb;
+  int iStatCur;
 
   assert( pTab!=0 );
   assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );
@@ -112527,13 +112525,13 @@
 */
 SQLITE_PRIVATE void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){
   sqlite3 *db = pParse->db;
-  int iDb = 0;
-  int i = 0;
-  char *z = NULL, *zDb = NULL;
-  Table *pTab = NULL;
-  Index *pIdx = NULL;
-  Token *pTableName = NULL;
-  Vdbe *v = NULL;
+  int iDb;
+  int i;
+  char *z, *zDb;
+  Table *pTab;
+  Index *pIdx;
+  Token *pTableName;
+  Vdbe *v;
 
   /* Read the database schema. If an error occurs, leave an error message
   ** and code in pParse and return NULL. */
@@ -112596,9 +112594,9 @@
   Index *pIndex          /* Handle extra flags for this index, if not NULL */
 ){
   char *z = zIntArray;
-  int c = 0;
-  int i = 0;
-  tRowcnt v = 0;
+  int c;
+  int i;
+  tRowcnt v;
 
 #ifdef SQLITE_ENABLE_STAT4
   if( z==0 ) z = "";
@@ -112663,9 +112661,9 @@
 */
 static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){
   analysisInfo *pInfo = (analysisInfo*)pData;
-  Index *pIndex = NULL;
-  Table *pTable = NULL;
-  const char *z = NULL;
+  Index *pIndex;
+  Table *pTable;
+  const char *z;
 
   assert( argc==3 );
   UNUSED_PARAMETER2(NotUsed, argc);
@@ -112994,11 +112992,11 @@
 */
 SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3 *db, int iDb){
   analysisInfo sInfo;
-  HashElem *i = NULL;
-  char *zSql = NULL;
+  HashElem *i;
+  char *zSql;
   int rc = SQLITE_OK;
   Schema *pSchema = db->aDb[iDb].pSchema;
-  const Table *pStat1 = NULL;
+  const Table *pStat1;
 
   assert( iDb>=0 && iDb<db->nDb );
   assert( db->aDb[iDb].pBt!=0 );
@@ -113144,18 +113142,18 @@
   int NotUsed,
   sqlite3_value **argv
 ){
-  int i = 0;
+  int i;
   int rc = 0;
   sqlite3 *db = sqlite3_context_db_handle(context);
-  const char *zName = NULL;
-  const char *zFile = NULL;
+  const char *zName;
+  const char *zFile;
   char *zPath = 0;
   char *zErr = 0;
-  unsigned int flags = 0;
-  Db *aNew = NULL;                 /* New array of Db pointers */
-  Db *pNew = NULL;                 /* Db object for the newly attached database */
+  unsigned int flags;
+  Db *aNew;                 /* New array of Db pointers */
+  Db *pNew;                 /* Db object for the newly attached database */
   char *zErrDyn = 0;
-  sqlite3_vfs *pVfs = NULL;
+  sqlite3_vfs *pVfs;
 
   UNUSED_PARAMETER(NotUsed);
   zFile = (const char *)sqlite3_value_text(argv[0]);
@@ -113241,7 +113239,7 @@
     rc = SQLITE_ERROR;
     zErrDyn = sqlite3MPrintf(db, "database is already attached");
   }else if( rc==SQLITE_OK ){
-    Pager *pPager = NULL;
+    Pager *pPager;
     pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);
     if( !pNew->pSchema ){
       rc = SQLITE_NOMEM_BKPT;
@@ -113339,9 +113337,9 @@
 ){
   const char *zName = (const char *)sqlite3_value_text(argv[0]);
   sqlite3 *db = sqlite3_context_db_handle(context);
-  int i = 0;
+  int i;
   Db *pDb = 0;
-  HashElem *pEntry = NULL;
+  HashElem *pEntry;
   char zErr[128];
 
   UNUSED_PARAMETER(NotUsed);
@@ -113403,11 +113401,11 @@
   Expr *pDbname,       /* Name of the database to use internally */
   Expr *pKey           /* Database key for encryption extension */
 ){
-  int rc = 0;
+  int rc;
   NameContext sName;
-  Vdbe *v = NULL;
+  Vdbe *v;
   sqlite3* db = pParse->db;
-  int regArgs = 0;
+  int regArgs;
 
   if( pParse->nErr ) goto attach_end;
   memset(&sName, 0, sizeof(NameContext));
@@ -113423,7 +113421,7 @@
 
 #ifndef SQLITE_OMIT_AUTHORIZATION
   if( ALWAYS(pAuthArg) ){
-    char *zAuthArg = NULL;
+    char *zAuthArg;
     if( pAuthArg->op==TK_STRING ){
       assert( !ExprHasProperty(pAuthArg, EP_IntValue) );
       zAuthArg = pAuthArg->u.zToken;
@@ -113524,8 +113522,8 @@
 */
 static int fixSelectCb(Walker *p, Select *pSelect){
   DbFixer *pFix = p->u.pFix;
-  int i = 0;
-  SrcItem *pItem = NULL;
+  int i;
+  SrcItem *pItem;
   sqlite3 *db = pFix->pParse->db;
   int iDb = sqlite3FindDbName(db, pFix->zDb);
   SrcList *pList = pSelect->pSrc;
@@ -113646,7 +113644,7 @@
     }
 #ifndef SQLITE_OMIT_UPSERT
     {
-      Upsert *pUp = NULL;
+      Upsert *pUp;
       for(pUp=pStep->pUpsert; pUp; pUp=pUp->pNextUpsert){
         if( sqlite3WalkExprList(&pFix->w, pUp->pUpsertTarget)
          || sqlite3WalkExpr(&pFix->w, pUp->pUpsertTargetWhere)
@@ -113778,7 +113776,7 @@
 ){
   sqlite3 *db = pParse->db;          /* Database handle */
   char *zDb = db->aDb[iDb].zDbSName; /* Schema name of attached database */
-  int rc = 0;                            /* Auth callback return code */
+  int rc;                            /* Auth callback return code */
 
   if( db->init.busy ) return SQLITE_OK;
   rc = db->xAuth(db->pAuthArg, SQLITE_READ, zTab,zCol,zDb,pParse->zAuthContext
@@ -113813,10 +113811,10 @@
   SrcList *pTabList     /* All table that pExpr might refer to */
 ){
   Table *pTab = 0;      /* The table being read */
-  const char *zCol = NULL;     /* Name of the column of the table */
-  int iSrc = 0;             /* Index in pTabList->a[] of table being read */
-  int iDb = 0;              /* The index of the database the expression refers to */
-  int iCol = 0;             /* Index of column in table */
+  const char *zCol;     /* Name of the column of the table */
+  int iSrc;             /* Index in pTabList->a[] of table being read */
+  int iDb;              /* The index of the database the expression refers to */
+  int iCol;             /* Index of column in table */
 
   assert( pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER );
   assert( !IN_RENAME_OBJECT );
@@ -113871,7 +113869,7 @@
   const char *zArg3
 ){
   sqlite3 *db = pParse->db;
-  int rc = 0;
+  int rc;
 
   /* Don't do any authorization checks if the database is initialising
   ** or if the parser is being invoked from within sqlite3_declare_vtab.
@@ -113993,10 +113991,10 @@
   u8 isWriteLock,    /* True for a write lock */
   const char *zName  /* Name of the table to be locked */
 ){
-  Parse *pToplevel = NULL;
-  int i = 0;
-  int nBytes = 0;
-  TableLock *p = NULL;
+  Parse *pToplevel;
+  int i;
+  int nBytes;
+  TableLock *p;
   assert( iDb>=0 );
 
   pToplevel = sqlite3ParseToplevel(pParse);
@@ -114039,7 +114037,7 @@
 ** statement (configured by calls to sqlite3TableLock()).
 */
 static void codeTableLocks(Parse *pParse){
-  int i = 0;
+  int i;
   Vdbe *pVdbe = pParse->pVdbe;
   assert( pVdbe!=0 );
 
@@ -114078,8 +114076,8 @@
 ** no VDBE code was generated.
 */
 SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){
-  sqlite3 *db = NULL;
-  Vdbe *v = NULL;
+  sqlite3 *db;
+  Vdbe *v;
 
   assert( pParse->pToplevel==0 );
   db = pParse->db;
@@ -114108,9 +114106,9 @@
   if( v ){
     if( pParse->bReturning ){
       Returning *pReturning = pParse->u1.pReturning;
-      int addrRewind = 0;
-      int i = 0;
-      int reg = 0;
+      int addrRewind;
+      int i;
+      int reg;
 
       if( NEVER(pReturning->nRetCol==0) ){
         assert( CORRUPT_DB );
@@ -114151,11 +114149,11 @@
     if( db->mallocFailed==0
      && (DbMaskNonZero(pParse->cookieMask) || pParse->pConstExpr)
     ){
-      int iDb = 0, i = 0;
+      int iDb, i;
       assert( sqlite3VdbeGetOp(v, 0)->opcode==OP_Init );
       sqlite3VdbeJumpHere(v, 0);
       for(iDb=0; iDb<db->nDb; iDb++){
-        Schema *pSchema = NULL;
+        Schema *pSchema;
         if( DbMaskTest(pParse->cookieMask, iDb)==0 ) continue;
         sqlite3VdbeUsesBtree(v, iDb);
         pSchema = db->aDb[iDb].pSchema;
@@ -114250,7 +114248,7 @@
 */
 SQLITE_PRIVATE void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){
   va_list ap;
-  char *zSql = NULL;
+  char *zSql;
   sqlite3 *db = pParse->db;
   u32 savedDbFlags = db->mDbFlags;
   char saveBuf[PARSE_TAIL_SZ];
@@ -114305,7 +114303,7 @@
 */
 SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){
   Table *p = 0;
-  int i = 0;
+  int i;
 
   /* All mutexes are required for schema access.  Make sure we hold them. */
   assert( zDatabase!=0 || sqlite3BtreeHoldsAllMutexes(db) );
@@ -114387,7 +114385,7 @@
   const char *zName,     /* Name of the table we are looking for */
   const char *zDbase     /* Name of the database.  Might be NULL */
 ){
-  Table *p = NULL;
+  Table *p;
   sqlite3 *db = pParse->db;
 
   /* Read the database schema. If an error occurs, leave an error message
@@ -114449,7 +114447,7 @@
   u32 flags,
   SrcItem *p
 ){
-  const char *zDb = NULL;
+  const char *zDb;
   assert( p->pSchema==0 || p->zDatabase==0 );
   if( p->pSchema ){
     int iDb = sqlite3SchemaToIndex(pParse->db, p->pSchema);
@@ -114490,7 +114488,7 @@
 */
 SQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){
   Index *p = 0;
-  int i = 0;
+  int i;
   /* All mutexes are required for schema access.  Make sure we hold them. */
   assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );
   for(i=OMIT_TEMPDB; i<db->nDb; i++){
@@ -114529,8 +114527,8 @@
 ** with the index.
 */
 SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){
-  Index *pIndex = NULL;
-  Hash *pHash = NULL;
+  Index *pIndex;
+  Hash *pHash;
 
   assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
   pHash = &db->aDb[iDb].pSchema->idxHash;
@@ -114539,7 +114537,7 @@
     if( pIndex->pTable->pIndex==pIndex ){
       pIndex->pTable->pIndex = pIndex->pNext;
     }else{
-      Index *p = NULL;
+      Index *p;
       /* Justification of ALWAYS();  The index must be on the list of
       ** indices. */
       p = pIndex->pTable->pIndex;
@@ -114562,7 +114560,7 @@
 ** are never candidates for being collapsed.
 */
 SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3 *db){
-  int i = 0, j = 0;
+  int i, j;
   for(i=j=2; i<db->nDb; i++){
     struct Db *pDb = &db->aDb[i];
     if( pDb->pBt==0 ){
@@ -114589,7 +114587,7 @@
 ** Deferred resets may be run by calling with iDb<0.
 */
 SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3 *db, int iDb){
-  int i = 0;
+  int i;
   assert( iDb<db->nDb );
 
   if( iDb>=0 ){
@@ -114613,7 +114611,7 @@
 ** "main" and "temp") for a single database connection.
 */
 SQLITE_PRIVATE void sqlite3ResetAllSchemasOfConnection(sqlite3 *db){
-  int i = 0;
+  int i;
   sqlite3BtreeEnterAll(db);
   for(i=0; i<db->nDb; i++){
     Db *pDb = &db->aDb[i];
@@ -114651,7 +114649,7 @@
   Column *pCol,     /* The column to receive the new DEFAULT expression */
   Expr *pExpr       /* The new default expression */
 ){
-  ExprList *pList = NULL;
+  ExprList *pList;
   assert( IsOrdinaryTable(pTab) );
   pList = pTab->u.tab.pDfltList;
   if( pCol->iDflt==0
@@ -114687,9 +114685,9 @@
   Column *pCol,
   const char *zColl
 ){
-  i64 nColl = 0;
-  i64 n = 0;
-  char *zNew = NULL;
+  i64 nColl;
+  i64 n;
+  char *zNew;
   assert( zColl!=0 );
   n = sqlite3Strlen30(pCol->zCnName) + 1;
   if( pCol->colFlags & COLFLAG_HASTYPE ){
@@ -114708,7 +114706,7 @@
 ** Return the collating squence name for a column
 */
 SQLITE_PRIVATE const char *sqlite3ColumnColl(Column *pCol){
-  const char *z = NULL;
+  const char *z;
   if( (pCol->colFlags & COLFLAG_HASCOLL)==0 ) return 0;
   z = pCol->zCnName;
   while( *z ){ z++; }
@@ -114723,8 +114721,8 @@
 ** Table.aCol[] array).
 */
 SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){
-  int i = 0;
-  Column *pCol = NULL;
+  int i;
+  Column *pCol;
   assert( pTable!=0 );
   if( (pCol = pTable->aCol)!=0 ){
     for(i=0; i<pTable->nCol; i++, pCol++){
@@ -114761,7 +114759,7 @@
 ** used by the Table object.
 */
 static void SQLITE_NOINLINE deleteTable(sqlite3 *db, Table *pTable){
-  Index *pIndex = NULL, *pNext = NULL;
+  Index *pIndex, *pNext;
 
 #ifdef SQLITE_DEBUG
   /* Record the number of outstanding lookaside allocations in schema Tables
@@ -114830,8 +114828,8 @@
 ** table structure with all its indices and foreign keys.
 */
 SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){
-  Table *p = NULL;
-  Db *pDb = NULL;
+  Table *p;
+  Db *pDb;
 
   assert( db!=0 );
   assert( iDb>=0 && iDb<db->nDb );
@@ -114858,7 +114856,7 @@
 ** is \000 terminated and is persistent.
 */
 SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, const Token *pName){
-  char *zName = NULL;
+  char *zName;
   if( pName ){
     zName = sqlite3DbStrNDup(db, (const char*)pName->z, pName->n);
     sqlite3Dequote(zName);
@@ -114890,7 +114888,7 @@
 SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *db, const char *zName){
   int i = -1;         /* Database number */
   if( zName ){
-    Db *pDb = NULL;
+    Db *pDb;
     for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){
       if( 0==sqlite3_stricmp(pDb->zDbSName, zName) ) break;
       /* "main" is always an acceptable alias for the primary database
@@ -114908,8 +114906,8 @@
 ** does not exist.
 */
 SQLITE_PRIVATE int sqlite3FindDb(sqlite3 *db, Token *pName){
-  int i = 0;                               /* Database number */
-  char *zName = NULL;                         /* Name we are searching for */
+  int i;                               /* Database number */
+  char *zName;                         /* Name we are searching for */
   zName = sqlite3NameFromToken(db, pName);
   i = sqlite3FindDbName(db, zName);
   sqlite3DbFree(db, zName);
@@ -114938,7 +114936,7 @@
   Token *pName2,      /* The "yyy" in the name "xxx.yyy" */
   Token **pUnqual     /* Write the unqualified object name here */
 ){
-  int iDb = 0;                    /* Database holding the object */
+  int iDb;                    /* Database holding the object */
   sqlite3 *db = pParse->db;
 
   assert( pName2!=0 );
@@ -115026,7 +115024,7 @@
 ** Return the PRIMARY KEY index of a table
 */
 SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table *pTab){
-  Index *p = NULL;
+  Index *p;
   for(p=pTab->pIndex; p && !IsPrimaryKeyIndex(p); p=p->pNext){}
   return p;
 }
@@ -115038,7 +115036,7 @@
 ** if column iCol is not used in index pIdx.
 */
 SQLITE_PRIVATE i16 sqlite3TableColumnToIndex(Index *pIdx, i16 iCol){
-  int i = 0;
+  int i;
   for(i=0; i<pIdx->nColumn; i++){
     if( iCol==pIdx->aiColumn[i] ) return i;
   }
@@ -115059,7 +115057,7 @@
 */
 SQLITE_PRIVATE i16 sqlite3StorageColumnToTable(Table *pTab, i16 iCol){
   if( pTab->tabFlags & TF_HasVirtual ){
-    int i = 0;
+    int i;
     for(i=0; i<=iCol; i++){
       if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) iCol++;
     }
@@ -115106,8 +115104,8 @@
 ** is negative (indicating the ROWID column) then this routine return iCol.
 */
 SQLITE_PRIVATE i16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){
-  int i = 0;
-  i16 n = 0;
+  int i;
+  i16 n;
   assert( iCol<pTab->nCol );
   if( (pTab->tabFlags & TF_HasVirtual)==0 || iCol<0 ) return iCol;
   for(i=0, n=0; i<iCol; i++){
@@ -115165,12 +115163,12 @@
   int isVirtual,   /* True if this is a VIRTUAL table */
   int noErr        /* Do nothing if table already exists */
 ){
-  Table *pTable = NULL;
+  Table *pTable;
   char *zName = 0; /* The name of the new table */
   sqlite3 *db = pParse->db;
-  Vdbe *v = NULL;
-  int iDb = 0;         /* Database number to create the table in */
-  Token *pName = NULL;    /* Unqualified name of the table to create */
+  Vdbe *v;
+  int iDb;         /* Database number to create the table in */
+  Token *pName;    /* Unqualified name of the table to create */
 
   if( db->init.busy && db->init.newTnum==1 ){
     /* Special case:  Parsing the sqlite_schema or sqlite_temp_schema schema */
@@ -115278,9 +115276,9 @@
   ** now.
   */
   if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){
-    int addr1 = 0;
-    int fileFormat = 0;
-    int reg1 = 0, reg2 = 0, reg3 = 0;
+    int addr1;
+    int fileFormat;
+    int reg1, reg2, reg3;
     /* nullRow[] is an OP_Record encoding of a row containing 5 NULLs */
     static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };
     sqlite3BeginWriteOperation(pParse, 1, iDb);
@@ -115368,7 +115366,7 @@
 ** Clean up the data structures associated with the RETURNING clause.
 */
 static void sqlite3DeleteReturning(sqlite3 *db, Returning *pRet){
-  Hash *pHash = NULL;
+  Hash *pHash;
   pHash = &(db->aDb[1].pSchema->trigHash);
   sqlite3HashInsert(pHash, RETURNING_TRIGGER_NAME, 0);
   sqlite3ExprListDelete(db, pRet->pReturnEL);
@@ -115392,8 +115390,8 @@
 ** type on the first call to sqlite3TriggersExist().
 */
 SQLITE_PRIVATE void sqlite3AddReturning(Parse *pParse, ExprList *pList){
-  Returning *pRet = NULL;
-  Hash *pHash = NULL;
+  Returning *pRet;
+  Hash *pHash;
   sqlite3 *db = pParse->db;
   if( pParse->pNewTrigger ){
     sqlite3ErrorMsg(pParse, "cannot use RETURNING in a trigger");
@@ -115440,14 +115438,14 @@
 ** column.
 */
 SQLITE_PRIVATE void sqlite3AddColumn(Parse *pParse, Token sName, Token sType){
-  Table *p = NULL;
-  int i = 0;
-  char *z = NULL;
-  char *zType = NULL;
-  Column *pCol = NULL;
+  Table *p;
+  int i;
+  char *z;
+  char *zType;
+  Column *pCol;
   sqlite3 *db = pParse->db;
-  u8 hName = 0;
-  Column *aNew = NULL;
+  u8 hName;
+  Column *aNew;
   u8 eType = COLTYPE_CUSTOM;
   u8 szEst = 1;
   char affinity = SQLITE_AFF_BLOB;
@@ -115553,8 +115551,8 @@
 ** the column currently under construction.
 */
 SQLITE_PRIVATE void sqlite3AddNotNull(Parse *pParse, int onError){
-  Table *p = NULL;
-  Column *pCol = NULL;
+  Table *p;
+  Column *pCol;
   p = pParse->pNewTable;
   if( p==0 || NEVER(p->nCol<1) ) return;
   pCol = &p->aCol[p->nCol-1];
@@ -115564,7 +115562,7 @@
   /* Set the uniqNotNull flag on any UNIQUE or PK indexes already created
   ** on this column.  */
   if( pCol->colFlags & COLFLAG_UNIQUE ){
-    Index *pIdx = NULL;
+    Index *pIdx;
     for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
       assert( pIdx->nKeyCol==1 && pIdx->onError!=OE_None );
       if( pIdx->aiColumn[0]==p->nCol-1 ){
@@ -115682,8 +115680,8 @@
   const char *zStart,      /* Start of the default value text */
   const char *zEnd         /* First character past end of defaut value text */
 ){
-  Table *p = NULL;
-  Column *pCol = NULL;
+  Table *p;
+  Column *pCol;
   sqlite3 *db = pParse->db;
   p = pParse->pNewTable;
   if( p!=0 ){
@@ -115702,7 +115700,7 @@
       /* A copy of pExpr is used instead of the original, as pExpr contains
       ** tokens that point to volatile memory.
       */
-      Expr x, *pDfltExpr = NULL;
+      Expr x, *pDfltExpr;
       memset(&x, 0, sizeof(x));
       x.op = TK_SPAN;
       x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);
@@ -115786,7 +115784,7 @@
   Table *pTab = pParse->pNewTable;
   Column *pCol = 0;
   int iCol = -1, i;
-  int nTerm = 0;
+  int nTerm;
   if( pTab==0 ) goto primary_key_exit;
   if( pTab->tabFlags & TF_HasPrimaryKey ){
     sqlite3ErrorMsg(pParse,
@@ -115806,7 +115804,7 @@
       assert( pCExpr!=0 );
       sqlite3StringToId(pCExpr);
       if( pCExpr->op==TK_ID ){
-        const char *zCName = NULL;
+        const char *zCName;
         assert( !ExprHasProperty(pCExpr, EP_IntValue) );
         zCName = pCExpr->u.zToken;
         for(iCol=0; iCol<pTab->nCol; iCol++){
@@ -115888,10 +115886,10 @@
 ** to the CollSeq given.
 */
 SQLITE_PRIVATE void sqlite3AddCollateType(Parse *pParse, Token *pToken){
-  Table *p = NULL;
-  int i = 0;
-  char *zColl = NULL;              /* Dequoted name of collation sequence */
-  sqlite3 *db = NULL;
+  Table *p;
+  int i;
+  char *zColl;              /* Dequoted name of collation sequence */
+  sqlite3 *db;
 
   if( (p = pParse->pNewTable)==0 || IN_RENAME_OBJECT ) return;
   i = p->nCol-1;
@@ -115900,7 +115898,7 @@
   if( !zColl ) return;
 
   if( sqlite3LocateCollSeq(pParse, zColl) ){
-    Index *pIdx = NULL;
+    Index *pIdx;
     sqlite3ColumnSetColl(db, &p->aCol[i], zColl);
 
     /* If the column is declared as "<name> PRIMARY KEY COLLATE <type>",
@@ -115924,7 +115922,7 @@
 #ifndef SQLITE_OMIT_GENERATED_COLUMNS
   u8 eType = COLFLAG_VIRTUAL;
   Table *pTab = pParse->pNewTable;
-  Column *pCol = NULL;
+  Column *pCol;
   if( pTab==0 ){
     /* generated column in an CREATE TABLE IF NOT EXISTS that already exists */
     goto generated_done;
@@ -116005,7 +116003,7 @@
 ** really needed.
 */
 static int identLength(const char *z){
-  int n = 0;
+  int n;
   for(n=0; *z; n++, z++){
     if( *z=='"' ){ n++; }
   }
@@ -116027,7 +116025,7 @@
 */
 static void identPut(char *z, int *pIdx, char *zSignedIdent){
   unsigned char *zIdent = (unsigned char*)zSignedIdent;
-  int i = 0, j = 0, needQuote = 0;
+  int i, j, needQuote;
   i = *pIdx;
 
   for(j=0; zIdent[j]; j++){
@@ -116054,10 +116052,10 @@
 ** from sqliteMalloc() and must be freed by the calling function.
 */
 static char *createTableStmt(sqlite3 *db, Table *p){
-  int i = 0, k = 0, n = 0;
-  char *zStmt = NULL;
-  char *zSep = NULL, *zSep2 = NULL, *zEnd = NULL;
-  Column *pCol = NULL;
+  int i, k, n;
+  char *zStmt;
+  char *zSep, *zSep2, *zEnd;
+  Column *pCol;
   n = 0;
   for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){
     n += identLength(pCol->zCnName) + 5;
@@ -116090,8 +116088,8 @@
         /* SQLITE_AFF_INTEGER */ " INT",
         /* SQLITE_AFF_REAL    */ " REAL"
     };
-    int len = 0;
-    const char *zType = NULL;
+    int len;
+    const char *zType;
 
     sqlite3_snprintf(n-k, &zStmt[k], zSep);
     k += sqlite3Strlen30(&zStmt[k]);
@@ -116122,8 +116120,8 @@
 ** on success and SQLITE_NOMEM on an OOM error.
 */
 static int resizeIndexObject(sqlite3 *db, Index *pIdx, int N){
-  char *zExtra = NULL;
-  int nByte = 0;
+  char *zExtra;
+  int nByte;
   if( pIdx->nColumn>=N ) return SQLITE_OK;
   assert( pIdx->isResized==0 );
   nByte = (sizeof(char*) + sizeof(LogEst) + sizeof(i16) + 1)*N;
@@ -116150,8 +116148,8 @@
 */
 static void estimateTableWidth(Table *pTab){
   unsigned wTable = 0;
-  const Column *pTabCol = NULL;
-  int i = 0;
+  const Column *pTabCol;
+  int i;
   for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){
     wTable += pTabCol->szEst;
   }
@@ -116164,7 +116162,7 @@
 */
 static void estimateIndexWidth(Index *pIdx){
   unsigned wIndex = 0;
-  int i = 0;
+  int i;
   const Column *aCol = pIdx->pTable->aCol;
   for(i=0; i<pIdx->nColumn; i++){
     i16 x = pIdx->aiColumn[i];
@@ -116201,7 +116199,7 @@
 ** the column name must match.
 */
 static int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){
-  int i = 0, j = 0;
+  int i, j;
   assert( nKey<=pIdx->nColumn );
   assert( iCol<MAX(pPk->nColumn,pPk->nKeyCol) );
   assert( pPk->idxType==SQLITE_IDXTYPE_PRIMARYKEY );
@@ -116241,7 +116239,7 @@
 */
 static void recomputeColumnsNotIndexed(Index *pIdx){
   Bitmask m = 0;
-  int j = 0;
+  int j;
   Table *pTab = pIdx->pTable;
   for(j=pIdx->nColumn-1; j>=0; j--){
     int x = pIdx->aiColumn[j];
@@ -116280,11 +116278,11 @@
 ** For virtual tables, only (1) is performed.
 */
 static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
-  Index *pIdx = NULL;
-  Index *pPk = NULL;
-  int nPk = 0;
-  int nExtra = 0;
-  int i = 0, j = 0;
+  Index *pIdx;
+  Index *pPk;
+  int nPk;
+  int nExtra;
+  int i, j;
   sqlite3 *db = pParse->db;
   Vdbe *v = pParse->pVdbe;
 
@@ -116314,7 +116312,7 @@
   ** an INTEGER PRIMARY KEY table, create a new PRIMARY KEY index.
   */
   if( pTab->iPKey>=0 ){
-    ExprList *pList = NULL;
+    ExprList *pList;
     Token ipkToken;
     sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zCnName);
     pList = sqlite3ExprListAppend(pParse, 0,
@@ -116380,7 +116378,7 @@
   ** the final rowid column into one or more columns of the PRIMARY KEY.
   */
   for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-    int n = 0;
+    int n;
     if( IsPrimaryKeyIndex(pIdx) ) continue;
     for(i=n=0; i<nPk; i++){
       if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){
@@ -116440,8 +116438,8 @@
 ** for that virtual table.
 */
 SQLITE_PRIVATE int sqlite3IsShadowTableOf(sqlite3 *db, Table *pTab, const char *zName){
-  int nName = 0;                    /* Length of zName */
-  Module *pMod = NULL;                 /* Module for the virtual table */
+  int nName;                    /* Length of zName */
+  Module *pMod;                 /* Module for the virtual table */
 
   if( !IsVirtual(pTab) ) return 0;
   nName = sqlite3Strlen30(pTab->zName);
@@ -116463,9 +116461,9 @@
 ** any shadow tables seen using the TF_Shadow flag.
 */
 SQLITE_PRIVATE void sqlite3MarkAllShadowTablesOf(sqlite3 *db, Table *pTab){
-  int nName = 0;                    /* Length of pTab->zName */
-  Module *pMod = NULL;                 /* Module for the virtual table */
-  HashElem *k = NULL;                  /* For looping through the symbol table */
+  int nName;                    /* Length of pTab->zName */
+  Module *pMod;                 /* Module for the virtual table */
+  HashElem *k;                  /* For looping through the symbol table */
 
   assert( IsVirtual(pTab) );
   pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->u.vtab.azArg[0]);
@@ -116499,8 +116497,8 @@
 ** restored to its original value prior to this routine returning.
 */
 SQLITE_PRIVATE int sqlite3ShadowTableName(sqlite3 *db, const char *zName){
-  char *zTail = NULL;                  /* Pointer to the last "_" in zName */
-  Table *pTab = NULL;                  /* Table that zName is a shadow of */
+  char *zTail;                  /* Pointer to the last "_" in zName */
+  Table *pTab;                  /* Table that zName is a shadow of */
   zTail = strrchr(zName, '_');
   if( zTail==0 ) return 0;
   *zTail = 0;
@@ -116566,10 +116564,10 @@
   u32 tabOpts,            /* Extra table options. Usually 0. */
   Select *pSelect         /* Select from a "CREATE ... AS SELECT" */
 ){
-  Table *p = NULL;                 /* The new table */
+  Table *p;                 /* The new table */
   sqlite3 *db = pParse->db; /* The database connection */
-  int iDb = 0;                  /* Database in which the table lives */
-  Index *pIdx = NULL;              /* An implied index of the table */
+  int iDb;                  /* Database in which the table lives */
+  Index *pIdx;              /* An implied index of the table */
 
   if( pEnd==0 && pSelect==0 ){
     return;
@@ -116609,7 +116607,7 @@
   **      constraint.
   */
   if( tabOpts & TF_Strict ){
-    int ii = 0;
+    int ii;
     p->tabFlags |= TF_Strict;
     for(ii=0; ii<p->nCol; ii++){
       Column *pCol = &p->aCol[ii];
@@ -116675,7 +116673,7 @@
 #endif /* !defined(SQLITE_OMIT_CHECK) */
 #ifndef SQLITE_OMIT_GENERATED_COLUMNS
   if( p->tabFlags & TF_HasGenerated ){
-    int ii = 0, nNG = 0;
+    int ii, nNG = 0;
     testcase( p->tabFlags & TF_HasVirtual );
     testcase( p->tabFlags & TF_HasStored );
     for(ii=0; ii<p->nCol; ii++){
@@ -116718,11 +116716,11 @@
   ** file instead of into the main database file.
   */
   if( !db->init.busy ){
-    int n = 0;
-    Vdbe *v = NULL;
-    char *zType = NULL;    /* "view" or "table" */
-    char *zType2 = NULL;   /* "VIEW" or "TABLE" */
-    char *zStmt = NULL;    /* Text of the CREATE TABLE or CREATE VIEW statement */
+    int n;
+    Vdbe *v;
+    char *zType;    /* "view" or "table" */
+    char *zType2;   /* "VIEW" or "TABLE" */
+    char *zStmt;    /* Text of the CREATE TABLE or CREATE VIEW statement */
 
     v = sqlite3GetVdbe(pParse);
     if( NEVER(v==0) ) return;
@@ -116759,12 +116757,12 @@
     */
     if( pSelect ){
       SelectDest dest;    /* Where the SELECT should store results */
-      int regYield = 0;       /* Register holding co-routine entry-point */
-      int addrTop = 0;        /* Top of the co-routine */
-      int regRec = 0;         /* A record to be insert into the new table */
-      int regRowid = 0;       /* Rowid of the next row to insert */
-      int addrInsLoop = 0;    /* Top of the loop for inserting rows */
-      Table *pSelTab = NULL;     /* A table that describes the SELECT results */
+      int regYield;       /* Register holding co-routine entry-point */
+      int addrTop;        /* Top of the co-routine */
+      int regRec;         /* A record to be insert into the new table */
+      int regRowid;       /* Rowid of the next row to insert */
+      int addrInsLoop;    /* Top of the loop for inserting rows */
+      Table *pSelTab;     /* A table that describes the SELECT results */
 
       if( IN_SPECIAL_PARSE ){
         pParse->rc = SQLITE_ERROR;
@@ -116861,7 +116859,7 @@
   /* Add the table to the in-memory representation of the database.
   */
   if( db->init.busy ){
-    Table *pOld = NULL;
+    Table *pOld;
     Schema *pSchema = p->pSchema;
     assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
     assert( HasRowid(p) || p->iPKey<0 );
@@ -116911,13 +116909,13 @@
   int isTemp,        /* TRUE for a TEMPORARY view */
   int noErr          /* Suppress error messages if VIEW already exists */
 ){
-  Table *p = NULL;
-  int n = 0;
-  const char *z = NULL;
+  Table *p;
+  int n;
+  const char *z;
   Token sEnd;
   DbFixer sFix;
   Token *pName = 0;
-  int iDb = 0;
+  int iDb;
   sqlite3 *db = pParse->db;
 
   if( pParse->nVar>0 ){
@@ -116994,16 +116992,16 @@
 ** of errors.  If an error is seen leave an error message in pParse->zErrMsg.
 */
 SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){
-  Table *pSelTab = NULL;   /* A fake table from which we get the result set */
-  Select *pSel = NULL;     /* Copy of the SELECT that implements the view */
+  Table *pSelTab;   /* A fake table from which we get the result set */
+  Select *pSel;     /* Copy of the SELECT that implements the view */
   int nErr = 0;     /* Number of errors encountered */
-  int n = 0;            /* Temporarily holds the number of cursors assigned */
+  int n;            /* Temporarily holds the number of cursors assigned */
   sqlite3 *db = pParse->db;  /* Database connection for malloc errors */
 #ifndef SQLITE_OMIT_VIRTUALTABLE
-  int rc = 0;
+  int rc;
 #endif
 #ifndef SQLITE_OMIT_AUTHORIZATION
-  sqlite3_xauth xAuth = 0;       /* Saved xAuth pointer */
+  sqlite3_xauth xAuth;       /* Saved xAuth pointer */
 #endif
 
   assert( pTable );
@@ -117122,7 +117120,7 @@
 ** Clear the column names from every VIEW in database idx.
 */
 static void sqliteViewResetAll(sqlite3 *db, int idx){
-  HashElem *i = NULL;
+  HashElem *i;
   assert( sqlite3SchemaMutexHeld(db, idx, 0) );
   if( !DbHasProperty(db, idx, DB_UnresetViews) ) return;
   for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){
@@ -117156,9 +117154,9 @@
 */
 #ifndef SQLITE_OMIT_AUTOVACUUM
 SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3 *db, int iDb, Pgno iFrom, Pgno iTo){
-  HashElem *pElem = NULL;
-  Hash *pHash = NULL;
-  Db *pDb = NULL;
+  HashElem *pElem;
+  Hash *pHash;
+  Db *pDb;
 
   assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
   pDb = &db->aDb[iDb];
@@ -117236,7 +117234,7 @@
   Pgno iDestroyed = 0;
 
   while( 1 ){
-    Index *pIdx = NULL;
+    Index *pIdx;
     Pgno iLargest = 0;
 
     if( iDestroyed==0 || iTab<iDestroyed ){
@@ -117270,7 +117268,7 @@
   const char *zType,     /* "idx" or "tbl" */
   const char *zName      /* Name of index or table */
 ){
-  int i = 0;
+  int i;
   const char *zDbName = pParse->db->aDb[iDb].zDbSName;
   for(i=1; i<=4; i++){
     char zTab[24];
@@ -117288,9 +117286,9 @@
 ** Generate code to drop a table.
 */
 SQLITE_PRIVATE void sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){
-  Vdbe *v = NULL;
+  Vdbe *v;
   sqlite3 *db = pParse->db;
-  Trigger *pTrigger = NULL;
+  Trigger *pTrigger;
   Db *pDb = &db->aDb[iDb];
 
   v = sqlite3GetVdbe(pParse);
@@ -117396,10 +117394,10 @@
 ** pName is the name of the table to be dropped.
 */
 SQLITE_PRIVATE void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){
-  Table *pTab = NULL;
-  Vdbe *v = NULL;
+  Table *pTab;
+  Vdbe *v;
   sqlite3 *db = pParse->db;
-  int iDb = 0;
+  int iDb;
 
   if( db->mallocFailed ){
     goto exit_drop_table;
@@ -117430,7 +117428,7 @@
   }
 #ifndef SQLITE_OMIT_AUTHORIZATION
   {
-    int code = 0;
+    int code;
     const char *zTab = SCHEMA_TABLE(iDb);
     const char *zDb = db->aDb[iDb].zDbSName;
     const char *zArg2 = 0;
@@ -117525,12 +117523,12 @@
   sqlite3 *db = pParse->db;
 #ifndef SQLITE_OMIT_FOREIGN_KEY
   FKey *pFKey = 0;
-  FKey *pNextTo = NULL;
+  FKey *pNextTo;
   Table *p = pParse->pNewTable;
-  i64 nByte = 0;
-  int i = 0;
-  int nCol = 0;
-  char *z = NULL;
+  i64 nByte;
+  int i;
+  int nCol;
+  char *z;
 
   assert( pTo!=0 );
   if( p==0 || IN_DECLARE_VTAB ) goto fk_end;
@@ -117579,7 +117577,7 @@
     pFKey->aCol[0].iFrom = p->nCol-1;
   }else{
     for(i=0; i<nCol; i++){
-      int j = 0;
+      int j;
       for(j=0; j<p->nCol; j++){
         if( sqlite3StrICmp(p->aCol[j].zCnName, pFromCol->a[i].zEName)==0 ){
           pFKey->aCol[i].iFrom = j;
@@ -117649,8 +117647,8 @@
 */
 SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){
 #ifndef SQLITE_OMIT_FOREIGN_KEY
-  Table *pTab = NULL;
-  FKey *pFKey = NULL;
+  Table *pTab;
+  FKey *pFKey;
   if( (pTab = pParse->pNewTable)==0 ) return;
   if( NEVER(!IsOrdinaryTable(pTab)) ) return;
   if( (pFKey = pTab->u.tab.pFKey)==0 ) return;
@@ -117674,14 +117672,14 @@
   Table *pTab = pIndex->pTable;  /* The table that is indexed */
   int iTab = pParse->nTab++;     /* Btree cursor used for pTab */
   int iIdx = pParse->nTab++;     /* Btree cursor used for pIndex */
-  int iSorter = 0;                   /* Cursor opened by OpenSorter (if in use) */
-  int addr1 = 0;                     /* Address of top of loop */
-  int addr2 = 0;                     /* Address to jump to for next iteration */
-  Pgno tnum = 0;                     /* Root page of index */
-  int iPartIdxLabel = 0;             /* Jump to this label to skip a row */
-  Vdbe *v = NULL;                       /* Generate code into this virtual machine */
-  KeyInfo *pKey = NULL;                 /* KeyInfo for index */
-  int regRecord = 0;                 /* Register holding assembled index record */
+  int iSorter;                   /* Cursor opened by OpenSorter (if in use) */
+  int addr1;                     /* Address of top of loop */
+  int addr2;                     /* Address to jump to for next iteration */
+  Pgno tnum;                     /* Root page of index */
+  int iPartIdxLabel;             /* Jump to this label to skip a row */
+  Vdbe *v;                       /* Generate code into this virtual machine */
+  KeyInfo *pKey;                 /* KeyInfo for index */
+  int regRecord;                 /* Register holding assembled index record */
   sqlite3 *db = pParse->db;      /* The database connection */
   int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);
 
@@ -117782,8 +117780,8 @@
   int nExtra,          /* Number of bytes of extra space to alloc */
   char **ppExtra       /* Pointer to the "extra" space */
 ){
-  Index *p = NULL;            /* Allocated index object */
-  int nByte = 0;           /* Bytes of space for Index object + arrays */
+  Index *p;            /* Allocated index object */
+  int nByte;           /* Bytes of space for Index object + arrays */
 
   nByte = ROUND8(sizeof(Index)) +              /* Index structure  */
           ROUND8(sizeof(char*)*nCol) +         /* Index.azColl     */
@@ -117811,7 +117809,7 @@
 */
 SQLITE_PRIVATE int sqlite3HasExplicitNulls(Parse *pParse, ExprList *pList){
   if( pList ){
-    int i = 0;
+    int i;
     for(i=0; i<pList->nExpr; i++){
       if( pList->a[i].bNulls ){
         u8 sf = pList->a[i].sortFlags;
@@ -117853,17 +117851,17 @@
   Table *pTab = 0;     /* Table to be indexed */
   Index *pIndex = 0;   /* The index to be created */
   char *zName = 0;     /* Name of the index */
-  int nName = 0;           /* Number of characters in zName */
-  int i = 0, j = 0;
+  int nName;           /* Number of characters in zName */
+  int i, j;
   DbFixer sFix;        /* For assigning database names to pTable */
-  int sortOrderMask = 0;   /* 1 to honor DESC in index.  0 to ignore. */
+  int sortOrderMask;   /* 1 to honor DESC in index.  0 to ignore. */
   sqlite3 *db = pParse->db;
-  Db *pDb = NULL;             /* The specific table containing the indexed database */
-  int iDb = 0;             /* Index of the database that is being written */
+  Db *pDb;             /* The specific table containing the indexed database */
+  int iDb;             /* Index of the database that is being written */
   Token *pName = 0;    /* Unqualified name of the index to create */
-  struct ExprList_item *pListItem = NULL; /* For looping over pList */
+  struct ExprList_item *pListItem; /* For looping over pList */
   int nExtra = 0;                  /* Space allocated for zExtra[] */
-  int nExtraCol = 0;                   /* Number of extra columns needed */
+  int nExtraCol;                   /* Number of extra columns needed */
   char *zExtra = 0;                /* Extra space after the Index object */
   Index *pPk = 0;      /* PRIMARY KEY index for WITHOUT ROWID tables */
 
@@ -117997,8 +117995,8 @@
       }
     }
   }else{
-    int n = 0;
-    Index *pLoop = NULL;
+    int n;
+    Index *pLoop;
     for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}
     zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n);
     if( zName==0 ){
@@ -118112,9 +118110,9 @@
     pList = 0;
   }
   for(i=0; i<pIndex->nKeyCol; i++, pListItem++){
-    Expr *pCExpr = NULL;                  /* The i-th index expression */
-    int requestedSortOrder = 0;        /* ASC or DESC on the i-th expression */
-    const char *zColl = NULL;             /* Collation sequence name */
+    Expr *pCExpr;                  /* The i-th index expression */
+    int requestedSortOrder;        /* ASC or DESC on the i-th expression */
+    const char *zColl;             /* Collation sequence name */
 
     sqlite3StringToId(pListItem->pExpr);
     sqlite3ResolveSelfReference(pParse, pTab, NC_IdxExpr, pListItem->pExpr, 0);
@@ -118150,7 +118148,7 @@
     }
     zColl = 0;
     if( pListItem->pExpr->op==TK_COLLATE ){
-      int nColl = 0;
+      int nColl;
       assert( !ExprHasProperty(pListItem->pExpr, EP_IntValue) );
       zColl = pListItem->pExpr->u.zToken;
       nColl = sqlite3Strlen30(zColl) + 1;
@@ -118234,17 +118232,17 @@
     ** the constraint occur in different orders, then the constraints are
     ** considered distinct and both result in separate indices.
     */
-    Index *pIdx = NULL;
+    Index *pIdx;
     for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-      int k = 0;
+      int k;
       assert( IsUniqueIndex(pIdx) );
       assert( pIdx->idxType!=SQLITE_IDXTYPE_APPDEF );
       assert( IsUniqueIndex(pIndex) );
 
       if( pIdx->nKeyCol!=pIndex->nKeyCol ) continue;
       for(k=0; k<pIdx->nKeyCol; k++){
-        const char *z1 = NULL;
-        const char *z2 = NULL;
+        const char *z1;
+        const char *z2;
         assert( pIdx->aiColumn[k]>=0 );
         if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;
         z1 = pIdx->azColl[k];
@@ -118286,7 +118284,7 @@
     */
     assert( pParse->nErr==0 );
     if( db->init.busy ){
-      Index *p = NULL;
+      Index *p;
       assert( !IN_SPECIAL_PARSE );
       assert( sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );
       if( pTblName!=0 ){
@@ -118321,8 +118319,8 @@
     ** step can be skipped.
     */
     else if( HasRowid(pTab) || pTblName!=0 ){
-      Vdbe *v = NULL;
-      char *zStmt = NULL;
+      Vdbe *v;
+      char *zStmt;
       int iMem = ++pParse->nMem;
 
       v = sqlite3GetVdbe(pParse);
@@ -118400,10 +118398,10 @@
     ** The list was already ordered when this routine was entered, so at this
     ** point at most a single index (the newly added index) will be out of
     ** order.  So we have to reorder at most one index. */
-    Index **ppFrom = NULL;
-    Index *pThis = NULL;
+    Index **ppFrom;
+    Index *pThis;
     for(ppFrom=&pTab->pIndex; (pThis = *ppFrom)!=0; ppFrom=&pThis->pNext){
-      Index *pNext = NULL;
+      Index *pNext;
       if( pThis->onError!=OE_Replace ) continue;
       while( (pNext = pThis->pNext)!=0 && pNext->onError!=OE_Replace ){
         *ppFrom = pNext;
@@ -118452,9 +118450,9 @@
                /*                10,  9,  8,  7,  6 */
   static const LogEst aVal[] = { 33, 32, 30, 28, 26 };
   LogEst *a = pIdx->aiRowLogEst;
-  LogEst x = 0;
+  LogEst x;
   int nCopy = MIN(ArraySize(aVal), pIdx->nKeyCol);
-  int i = 0;
+  int i;
 
   /* Indexes with default row estimates should not have stat1 data */
   assert( !pIdx->hasStat1 );
@@ -118493,10 +118491,10 @@
 ** implements the DROP INDEX statement.
 */
 SQLITE_PRIVATE void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){
-  Index *pIndex = NULL;
-  Vdbe *v = NULL;
+  Index *pIndex;
+  Vdbe *v;
   sqlite3 *db = pParse->db;
-  int iDb = 0;
+  int iDb;
 
   if( db->mallocFailed ){
     goto exit_drop_index;
@@ -118581,7 +118579,7 @@
   int *pnEntry,     /* Number of objects currently in use */
   int *pIdx         /* Write the index of a new slot here */
 ){
-  char *z = NULL;
+  char *z;
   sqlite3_int64 n = *pIdx = *pnEntry;
   if( (n & (n-1))==0 ){
     sqlite3_int64 sz = (n==0) ? 1 : 2*n;
@@ -118606,7 +118604,7 @@
 */
 SQLITE_PRIVATE IdList *sqlite3IdListAppend(Parse *pParse, IdList *pList, Token *pToken){
   sqlite3 *db = pParse->db;
-  int i = 0;
+  int i;
   if( pList==0 ){
     pList = sqlite3DbMallocZero(db, sizeof(IdList) );
     if( pList==0 ) return 0;
@@ -118633,7 +118631,7 @@
 ** Delete an IdList.
 */
 SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3 *db, IdList *pList){
-  int i = 0;
+  int i;
   if( pList==0 ) return;
   for(i=0; i<pList->nId; i++){
     sqlite3DbFree(db, pList->a[i].zName);
@@ -118647,7 +118645,7 @@
 ** if not found.
 */
 SQLITE_PRIVATE int sqlite3IdListIndex(IdList *pList, const char *zName){
-  int i = 0;
+  int i;
   if( pList==0 ) return -1;
   for(i=0; i<pList->nId; i++){
     if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;
@@ -118693,7 +118691,7 @@
   int nExtra,        /* Number of new slots to add to pSrc->a[] */
   int iStart         /* Index in pSrc->a[] of first new slot */
 ){
-  int i = 0;
+  int i;
 
   /* Sanity checking on calling parameters */
   assert( iStart>=0 );
@@ -118703,7 +118701,7 @@
 
   /* Allocate additional space if needed */
   if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){
-    SrcList *pNew = NULL;
+    SrcList *pNew;
     sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;
     sqlite3 *db = pParse->db;
 
@@ -118782,8 +118780,8 @@
   Token *pTable,      /* Table to append */
   Token *pDatabase    /* Database of the table */
 ){
-  SrcItem *pItem = NULL;
-  sqlite3 *db = NULL;
+  SrcItem *pItem;
+  sqlite3 *db;
   assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */
   assert( pParse!=0 );
   assert( pParse->db!=0 );
@@ -118822,8 +118820,8 @@
 ** Assign VdbeCursor index numbers to all tables in a SrcList
 */
 SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){
-  int i = 0;
-  SrcItem *pItem = NULL;
+  int i;
+  SrcItem *pItem;
   assert( pList || pParse->db->mallocFailed );
   if( ALWAYS(pList) ){
     for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){
@@ -118840,8 +118838,8 @@
 ** Delete an entire SrcList including all its substructure.
 */
 SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){
-  int i = 0;
-  SrcItem *pItem = NULL;
+  int i;
+  SrcItem *pItem;
   if( pList==0 ) return;
   for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){
     if( pItem->zDatabase ) sqlite3DbFreeNN(db, pItem->zDatabase);
@@ -118883,7 +118881,7 @@
   Expr *pOn,              /* The ON clause of a join */
   IdList *pUsing          /* The USING clause of a join */
 ){
-  SrcItem *pItem = NULL;
+  SrcItem *pItem;
   sqlite3 *db = pParse->db;
   if( !p && (pOn || pUsing) ){
     sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s",
@@ -118927,7 +118925,7 @@
 SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){
   assert( pIndexedBy!=0 );
   if( p && pIndexedBy->n>0 ){
-    SrcItem *pItem = NULL;
+    SrcItem *pItem;
     assert( p->nSrc>0 );
     pItem = &p->a[p->nSrc-1];
     assert( pItem->fg.notIndexed==0 );
@@ -118999,7 +118997,7 @@
 */
 SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList *p){
   if( p ){
-    int i = 0;
+    int i;
     for(i=p->nSrc-1; i>0; i--){
       p->a[i].fg.jointype = p->a[i-1].fg.jointype;
     }
@@ -119011,9 +119009,9 @@
 ** Generate VDBE code for a BEGIN statement.
 */
 SQLITE_PRIVATE void sqlite3BeginTransaction(Parse *pParse, int type){
-  sqlite3 *db = NULL;
-  Vdbe *v = NULL;
-  int i = 0;
+  sqlite3 *db;
+  Vdbe *v;
+  int i;
 
   assert( pParse!=0 );
   db = pParse->db;
@@ -119025,7 +119023,7 @@
   if( !v ) return;
   if( type!=TK_DEFERRED ){
     for(i=0; i<db->nDb; i++){
-      int eTxnType = 0;
+      int eTxnType;
       Btree *pBt = db->aDb[i].pBt;
       if( pBt && sqlite3BtreeIsReadonly(pBt) ){
         eTxnType = 0;  /* Read txn */
@@ -119047,8 +119045,8 @@
 ** code is generated for a COMMIT.
 */
 SQLITE_PRIVATE void sqlite3EndTransaction(Parse *pParse, int eType){
-  Vdbe *v = NULL;
-  int isRollback = 0;
+  Vdbe *v;
+  int isRollback;
 
   assert( pParse!=0 );
   assert( pParse->db!=0 );
@@ -119091,8 +119089,8 @@
 SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *pParse){
   sqlite3 *db = pParse->db;
   if( db->aDb[1].pBt==0 && !pParse->explain ){
-    int rc = 0;
-    Btree *pBt = NULL;
+    int rc;
+    Btree *pBt;
     static const int flags =
           SQLITE_OPEN_READWRITE |
           SQLITE_OPEN_CREATE |
@@ -119146,7 +119144,7 @@
 */
 SQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){
   sqlite3 *db = pParse->db;
-  int i = 0;
+  int i;
   for(i=0; i<db->nDb; i++){
     Db *pDb = &db->aDb[i];
     if( pDb->pBt && (!zDb || 0==sqlite3StrICmp(zDb, pDb->zDbSName)) ){
@@ -119221,7 +119219,7 @@
   i8 p4type,        /* P4_STATIC or P4_TRANSIENT */
   u8 p5Errmsg       /* P5_ErrMsg type */
 ){
-  Vdbe *v = NULL;
+  Vdbe *v;
   assert( pParse->pVdbe!=0 );
   v = sqlite3GetVdbe(pParse);
   assert( (errCode&0xff)==SQLITE_CONSTRAINT || pParse->nested );
@@ -119240,8 +119238,8 @@
   int onError,      /* Constraint type */
   Index *pIdx       /* The index that triggers the constraint */
 ){
-  char *zErr = NULL;
-  int j = 0;
+  char *zErr;
+  int j;
   StrAccum errMsg;
   Table *pTab = pIdx->pTable;
 
@@ -119251,7 +119249,7 @@
     sqlite3_str_appendf(&errMsg, "index '%q'", pIdx->zName);
   }else{
     for(j=0; j<pIdx->nKeyCol; j++){
-      char *zCol = NULL;
+      char *zCol;
       assert( pIdx->aiColumn[j]>=0 );
       zCol = pTab->aCol[pIdx->aiColumn[j]].zCnName;
       if( j ) sqlite3_str_append(&errMsg, ", ", 2);
@@ -119276,8 +119274,8 @@
   int onError,      /* Conflict resolution algorithm */
   Table *pTab       /* The table with the non-unique rowid */
 ){
-  char *zMsg = NULL;
-  int rc = 0;
+  char *zMsg;
+  int rc;
   if( pTab->iPKey>=0 ){
     zMsg = sqlite3MPrintf(pParse->db, "%s.%s", pTab->zName,
                           pTab->aCol[pTab->iPKey].zCnName);
@@ -119296,7 +119294,7 @@
 */
 #ifndef SQLITE_OMIT_REINDEX
 static int collationMatch(const char *zColl, Index *pIndex){
-  int i = 0;
+  int i;
   assert( zColl!=0 );
   for(i=0; i<pIndex->nColumn; i++){
     const char *z = pIndex->azColl[i];
@@ -119316,7 +119314,7 @@
 #ifndef SQLITE_OMIT_REINDEX
 static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){
   if( !IsVirtual(pTab) ){
-    Index *pIndex = NULL;              /* An index associated with pTab */
+    Index *pIndex;              /* An index associated with pTab */
 
     for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){
       if( zColl==0 || collationMatch(zColl, pIndex) ){
@@ -119336,11 +119334,11 @@
 */
 #ifndef SQLITE_OMIT_REINDEX
 static void reindexDatabases(Parse *pParse, char const *zColl){
-  Db *pDb = NULL;                    /* A single database */
-  int iDb = 0;                    /* The database index number */
+  Db *pDb;                    /* A single database */
+  int iDb;                    /* The database index number */
   sqlite3 *db = pParse->db;   /* The database connection */
-  HashElem *k = NULL;                /* For looping over tables in pDb */
-  Table *pTab = NULL;                /* A table in the database */
+  HashElem *k;                /* For looping over tables in pDb */
+  Table *pTab;                /* A table in the database */
 
   assert( sqlite3BtreeHoldsAllMutexes(db) );  /* Needed for schema access */
   for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){
@@ -119368,14 +119366,14 @@
 */
 #ifndef SQLITE_OMIT_REINDEX
 SQLITE_PRIVATE void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){
-  CollSeq *pColl = NULL;             /* Collating sequence to be reindexed, or NULL */
-  char *z = NULL;                    /* Name of a table or index */
-  const char *zDb = NULL;            /* Name of the database */
-  Table *pTab = NULL;                /* A table in the database */
-  Index *pIndex = NULL;              /* An index associated with pTab */
-  int iDb = 0;                    /* The database index number */
+  CollSeq *pColl;             /* Collating sequence to be reindexed, or NULL */
+  char *z;                    /* Name of a table or index */
+  const char *zDb;            /* Name of the database */
+  Table *pTab;                /* A table in the database */
+  Index *pIndex;              /* An index associated with pTab */
+  int iDb;                    /* The database index number */
   sqlite3 *db = pParse->db;   /* The database connection */
-  Token *pObjName = NULL;            /* Name of the table or index to be reindexed */
+  Token *pObjName;            /* Name of the table or index to be reindexed */
 
   /* Read the database schema. If an error occurs, leave an error message
   ** and code in pParse and return NULL. */
@@ -119387,7 +119385,7 @@
     reindexDatabases(pParse, 0);
     return;
   }else if( NEVER(pName2==0) || pName2->z==0 ){
-    char *zColl = NULL;
+    char *zColl;
     assert( pName1->z );
     zColl = sqlite3NameFromToken(pParse->db, pName1);
     if( !zColl ) return;
@@ -119428,10 +119426,10 @@
 ** when it has finished using it.
 */
 SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx){
-  int i = 0;
+  int i;
   int nCol = pIdx->nColumn;
   int nKey = pIdx->nKeyCol;
-  KeyInfo *pKey = NULL;
+  KeyInfo *pKey;
   if( pParse->nErr ) return 0;
   if( pIdx->uniqNotNull ){
     pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol-nKey);
@@ -119478,7 +119476,7 @@
   Select *pQuery,         /* Query used to initialize the table */
   u8 eM10d                /* The MATERIALIZED flag */
 ){
-  Cte *pNew = NULL;
+  Cte *pNew;
   sqlite3 *db = pParse->db;
 
   pNew = sqlite3DbMallocZero(db, sizeof(*pNew));
@@ -119528,8 +119526,8 @@
   Cte *pCte               /* CTE to add to the WITH clause */
 ){
   sqlite3 *db = pParse->db;
-  With *pNew = NULL;
-  char *zName = NULL;
+  With *pNew;
+  char *zName;
 
   if( pCte==0 ){
     return pWith;
@@ -119539,7 +119537,7 @@
   ** not, store an error in the Parse structure. */
   zName = pCte->zName;
   if( zName && pWith ){
-    int i = 0;
+    int i;
     for(i=0; i<pWith->nCte; i++){
       if( sqlite3StrICmp(zName, pWith->a[i].zName)==0 ){
         sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
@@ -119571,7 +119569,7 @@
 */
 SQLITE_PRIVATE void sqlite3WithDelete(sqlite3 *db, With *pWith){
   if( pWith ){
-    int i = 0;
+    int i;
     for(i=0; i<pWith->nCte; i++){
       cteClear(db, &pWith->a[i]);
     }
@@ -119614,7 +119612,7 @@
   }
 #ifndef SQLITE_OMIT_UTF16
   if( db->xCollNeeded16 ){
-    char const *zExternal = NULL;
+    char const *zExternal;
     sqlite3_value *pTmp = sqlite3ValueNew(db);
     sqlite3ValueSetStr(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC);
     zExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE);
@@ -119634,9 +119632,9 @@
 ** possible.
 */
 static int synthCollSeq(sqlite3 *db, CollSeq *pColl){
-  CollSeq *pColl2 = NULL;
+  CollSeq *pColl2;
   char *z = pColl->zName;
-  int i = 0;
+  int i;
   static const u8 aEnc[] = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 };
   for(i=0; i<3; i++){
     pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);
@@ -119693,7 +119691,7 @@
   const char *zName,    /* Name of the collating sequence */
   int create            /* Create a new entry if true */
 ){
-  CollSeq *pColl = NULL;
+  CollSeq *pColl;
   pColl = sqlite3HashFind(&db->aCollSeq, zName);
 
   if( 0==pColl && create ){
@@ -119746,7 +119744,7 @@
   const char *zName,    /* Name of the collating sequence.  Might be NULL */
   int create            /* True to create CollSeq if doesn't already exist */
 ){
-  CollSeq *pColl = NULL;
+  CollSeq *pColl;
   assert( SQLITE_UTF8==1 && SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );
   assert( enc>=SQLITE_UTF8 && enc<=SQLITE_UTF16BE );
   if( zName ){
@@ -119791,7 +119789,7 @@
   CollSeq *pColl,       /* Collating sequence with native encoding, or NULL */
   const char *zName     /* Collating sequence name */
 ){
-  CollSeq *p = NULL;
+  CollSeq *p;
   sqlite3 *db = pParse->db;
 
   p = pColl;
@@ -119840,7 +119838,7 @@
   sqlite3 *db = pParse->db;
   u8 enc = ENC(db);
   u8 initbusy = db->init.busy;
-  CollSeq *pColl = NULL;
+  CollSeq *pColl;
 
   pColl = sqlite3FindCollSeq(db, enc, zName, initbusy);
   if( !initbusy && (!pColl || !pColl->xCmp) ){
@@ -119884,7 +119882,7 @@
   int nArg,       /* Desired number of arguments.  (-1)==any */
   u8 enc          /* Desired text encoding */
 ){
-  int match = 0;
+  int match;
   assert( p->nArg>=-1 );
 
   /* Wrong number of arguments means "no match" */
@@ -119919,7 +119917,7 @@
   int h,               /* Hash of the name */
   const char *zFunc    /* Name of function */
 ){
-  FuncDef *p = NULL;
+  FuncDef *p;
   for(p=sqlite3BuiltinFunctions.a[h]; p; p=p->u.pHash){
     assert( p->funcFlags & SQLITE_FUNC_BUILTIN );
     if( sqlite3StrICmp(p->zName, zFunc)==0 ){
@@ -119936,9 +119934,9 @@
   FuncDef *aDef,      /* List of global functions to be inserted */
   int nDef            /* Length of the apDef[] list */
 ){
-  int i = 0;
+  int i;
   for(i=0; i<nDef; i++){
-    FuncDef *pOther = NULL;
+    FuncDef *pOther;
     const char *zName = aDef[i].zName;
     int nName = sqlite3Strlen30(zName);
     int h = SQLITE_FUNC_HASH(zName[0], nName);
@@ -119984,11 +119982,11 @@
   u8 enc,            /* Preferred text encoding */
   u8 createFlag      /* Create new entry if true and does not otherwise exist */
 ){
-  FuncDef *p = NULL;         /* Iterator variable */
+  FuncDef *p;         /* Iterator variable */
   FuncDef *pBest = 0; /* Best match found so far */
   int bestScore = 0;  /* Score of best match */
-  int h = 0;              /* Hash value */
-  int nName = 0;          /* Length of the name */
+  int h;              /* Hash value */
+  int nName;          /* Length of the name */
 
   assert( nArg>=(-2) );
   assert( nArg>=(-1) || createFlag==0 );
@@ -120038,8 +120036,8 @@
   */
   if( createFlag && bestScore<FUNC_PERFECT_MATCH &&
       (pBest = sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){
-    FuncDef *pOther = NULL;
-    u8 *z = NULL;
+    FuncDef *pOther;
+    u8 *z;
     pBest->zName = (const char*)&pBest[1];
     pBest->nArg = (u16)nArg;
     pBest->funcFlags = enc;
@@ -120072,7 +120070,7 @@
 SQLITE_PRIVATE void sqlite3SchemaClear(void *p){
   Hash temp1;
   Hash temp2;
-  HashElem *pElem = NULL;
+  HashElem *pElem;
   Schema *pSchema = (Schema *)p;
 
   temp1 = pSchema->tblHash;
@@ -120102,7 +120100,7 @@
 ** a new one if necessary.
 */
 SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){
-  Schema * p = NULL;
+  Schema * p;
   if( pBt ){
     p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaClear);
   }else{
@@ -120154,7 +120152,7 @@
 */
 SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){
   SrcItem *pItem = pSrc->a;
-  Table *pTab = NULL;
+  Table *pTab;
   assert( pItem && pSrc->nSrc>=1 );
   pTab = sqlite3LocateTableItem(pParse, 0, pItem);
   sqlite3DeleteTable(pParse->db, pItem->pTab);
@@ -120194,7 +120192,7 @@
 **      is for a top-level SQL statement.
 */
 static int tabIsReadOnly(Parse *pParse, Table *pTab){
-  sqlite3 *db = NULL;
+  sqlite3 *db;
   if( IsVirtual(pTab) ){
     return sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0;
   }
@@ -120242,8 +120240,8 @@
   int iCur             /* Cursor number for ephemeral table */
 ){
   SelectDest dest;
-  Select *pSel = NULL;
-  SrcList *pFrom = NULL;
+  Select *pSel;
+  SrcList *pFrom;
   sqlite3 *db = pParse->db;
   int iDb = sqlite3SchemaToIndex(db, pView->pSchema);
   pWhere = sqlite3ExprDup(db, pWhere, 0);
@@ -120379,40 +120377,40 @@
   ExprList *pOrderBy,    /* ORDER BY clause. May be null */
   Expr *pLimit           /* LIMIT clause. May be null */
 ){
-  Vdbe *v = NULL;               /* The virtual database engine */
-  Table *pTab = NULL;           /* The table from which records will be deleted */
-  int i = 0;                 /* Loop counter */
-  WhereInfo *pWInfo = NULL;     /* Information about the WHERE clause */
-  Index *pIdx = NULL;           /* For looping over indices of the table */
-  int iTabCur = 0;           /* Cursor number for the table */
+  Vdbe *v;               /* The virtual database engine */
+  Table *pTab;           /* The table from which records will be deleted */
+  int i;                 /* Loop counter */
+  WhereInfo *pWInfo;     /* Information about the WHERE clause */
+  Index *pIdx;           /* For looping over indices of the table */
+  int iTabCur;           /* Cursor number for the table */
   int iDataCur = 0;      /* VDBE cursor for the canonical data source */
   int iIdxCur = 0;       /* Cursor number of the first index */
-  int nIdx = 0;              /* Number of indices */
-  sqlite3 *db = NULL;           /* Main database structure */
+  int nIdx;              /* Number of indices */
+  sqlite3 *db;           /* Main database structure */
   AuthContext sContext;  /* Authorization context */
   NameContext sNC;       /* Name context to resolve expressions in */
-  int iDb = 0;               /* Database number */
+  int iDb;               /* Database number */
   int memCnt = 0;        /* Memory cell used for change counting */
-  int rcauth = 0;            /* Value returned by authorization callback */
-  int eOnePass = 0;          /* ONEPASS_OFF or _SINGLE or _MULTI */
+  int rcauth;            /* Value returned by authorization callback */
+  int eOnePass;          /* ONEPASS_OFF or _SINGLE or _MULTI */
   int aiCurOnePass[2];   /* The write cursors opened by WHERE_ONEPASS */
   u8 *aToOpen = 0;       /* Open cursor iTabCur+j if aToOpen[j] is true */
-  Index *pPk = NULL;            /* The PRIMARY KEY index on the table */
+  Index *pPk;            /* The PRIMARY KEY index on the table */
   int iPk = 0;           /* First of nPk registers holding PRIMARY KEY value */
   i16 nPk = 1;           /* Number of columns in the PRIMARY KEY */
-  int iKey = 0;              /* Memory cell holding key of row to be deleted */
-  i16 nKey = 0;              /* Number of memory cells in the row key */
+  int iKey;              /* Memory cell holding key of row to be deleted */
+  i16 nKey;              /* Number of memory cells in the row key */
   int iEphCur = 0;       /* Ephemeral table holding all primary key values */
   int iRowSet = 0;       /* Register for rowset of rows to delete */
   int addrBypass = 0;    /* Address of jump over the delete logic */
   int addrLoop = 0;      /* Top of the delete loop */
   int addrEphOpen = 0;   /* Instruction to open the Ephemeral table */
-  int bComplex = 0;          /* True if there are triggers or FKs or
+  int bComplex;          /* True if there are triggers or FKs or
                          ** subqueries in the WHERE clause */
 
 #ifndef SQLITE_OMIT_TRIGGER
-  int isView = 0;                  /* True if attempting to delete from a view */
-  Trigger *pTrigger = NULL;           /* List of table triggers, if required */
+  int isView;                  /* True if attempting to delete from a view */
+  Trigger *pTrigger;           /* List of table triggers, if required */
 #endif
 
   memset(&sContext, 0, sizeof(sContext));
@@ -120835,8 +120833,8 @@
 ){
   Vdbe *v = pParse->pVdbe;        /* Vdbe */
   int iOld = 0;                   /* First register in OLD.* array */
-  int iLabel = 0;                     /* Label resolved to end of generated code */
-  u8 opSeek = 0;                      /* Seek opcode */
+  int iLabel;                     /* Label resolved to end of generated code */
+  u8 opSeek;                      /* Seek opcode */
 
   /* Vdbe is guaranteed to have been allocated by this stage. */
   assert( v );
@@ -120857,9 +120855,9 @@
   /* If there are any triggers to fire, allocate a range of registers to
   ** use for the old.* references in the triggers.  */
   if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
-    u32 mask = 0;                     /* Mask of OLD.* columns in use */
-    int iCol = 0;                     /* Iterator used while populating OLD.* */
-    int addrStart = 0;                /* Start of BEFORE trigger programs */
+    u32 mask;                     /* Mask of OLD.* columns in use */
+    int iCol;                     /* Iterator used while populating OLD.* */
+    int addrStart;                /* Start of BEFORE trigger programs */
 
     /* TODO: Could use temporary registers here. Also could attempt to
     ** avoid copying the contents of the rowid register.  */
@@ -120980,13 +120978,13 @@
   int *aRegIdx,      /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */
   int iIdxNoSeek     /* Do not delete from this cursor */
 ){
-  int i = 0;             /* Index loop counter */
+  int i;             /* Index loop counter */
   int r1 = -1;       /* Register holding an index key */
-  int iPartIdxLabel = 0; /* Jump destination for skipping partial index entries */
-  Index *pIdx = NULL;       /* Current index */
+  int iPartIdxLabel; /* Jump destination for skipping partial index entries */
+  Index *pIdx;       /* Current index */
   Index *pPrior = 0; /* Prior index */
-  Vdbe *v = NULL;           /* The prepared statement under construction */
-  Index *pPk = NULL;        /* PRIMARY KEY index, or NULL for rowid tables */
+  Vdbe *v;           /* The prepared statement under construction */
+  Index *pPk;        /* PRIMARY KEY index, or NULL for rowid tables */
 
   v = pParse->pVdbe;
   pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);
@@ -121048,9 +121046,9 @@
   int regPrior         /* Register holding previous generated key */
 ){
   Vdbe *v = pParse->pVdbe;
-  int j = 0;
-  int regBase = 0;
-  int nCol = 0;
+  int j;
+  int regBase;
+  int nCol;
 
   if( piPartIdxLabel ){
     if( pIdx->pPartIdxWhere ){
@@ -121134,7 +121132,7 @@
 ** Return the collating function associated with a function.
 */
 static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){
-  VdbeOp *pOp = NULL;
+  VdbeOp *pOp;
   assert( context->pVdbe!=0 );
   pOp = &context->pVdbe->aOp[context->iOp-1];
   assert( pOp->opcode==OP_CollSeq );
@@ -121160,10 +121158,10 @@
   int argc,
   sqlite3_value **argv
 ){
-  int i = 0;
-  int mask = 0;    /* 0 for min() or 0xffffffff for max() */
-  int iBest = 0;
-  CollSeq *pColl = NULL;
+  int i;
+  int mask;    /* 0 for min() or 0xffffffff for max() */
+  int iBest;
+  CollSeq *pColl;
 
   assert( argc>1 );
   mask = sqlite3_user_data(context)==0 ? 0 : -1;
@@ -121238,8 +121236,8 @@
     }
     case SQLITE_TEXT: {
       const unsigned char *z = sqlite3_value_text(argv[0]);
-      const unsigned char *z0 = NULL;
-      unsigned char c = 0;
+      const unsigned char *z0;
+      unsigned char c;
       if( z==0 ) return;
       z0 = z;
       while( (c = *z)!=0 ){
@@ -121318,14 +121316,14 @@
   int argc,
   sqlite3_value **argv
 ){
-  const unsigned char *zHaystack = NULL;
-  const unsigned char *zNeedle = NULL;
-  int nHaystack = 0;
-  int nNeedle = 0;
-  int typeHaystack = 0, typeNeedle = 0;
+  const unsigned char *zHaystack;
+  const unsigned char *zNeedle;
+  int nHaystack;
+  int nNeedle;
+  int typeHaystack, typeNeedle;
   int N = 1;
-  int isText = 0;
-  unsigned char firstChar = 0;
+  int isText;
+  unsigned char firstChar;
   sqlite3_value *pC1 = 0;
   sqlite3_value *pC2 = 0;
 
@@ -121388,8 +121386,8 @@
 ){
   PrintfArguments x;
   StrAccum str;
-  const char *zFormat = NULL;
-  int n = 0;
+  const char *zFormat;
+  int n;
   sqlite3 *db = sqlite3_context_db_handle(context);
 
   if( argc>=1 && (zFormat = (const char*)sqlite3_value_text(argv[0]))!=0 ){
@@ -121422,11 +121420,11 @@
   int argc,
   sqlite3_value **argv
 ){
-  const unsigned char *z = NULL;
-  const unsigned char *z2 = NULL;
-  int len = 0;
-  int p0type = 0;
-  i64 p1 = 0, p2 = 0;
+  const unsigned char *z;
+  const unsigned char *z2;
+  int len;
+  int p0type;
+  i64 p1, p2;
   int negP2 = 0;
 
   assert( argc==3 || argc==2 );
@@ -121514,8 +121512,8 @@
 #ifndef SQLITE_OMIT_FLOATING_POINT
 static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
   int n = 0;
-  double r = 0;
-  char *zBuf = NULL;
+  double r;
+  char *zBuf;
   assert( argc==1 || argc==2 );
   if( argc==2 ){
     if( SQLITE_NULL==sqlite3_value_type(argv[1]) ) return;
@@ -121554,7 +121552,7 @@
 ** raise an SQLITE_TOOBIG exception and return NULL.
 */
 static void *contextMalloc(sqlite3_context *context, i64 nByte){
-  char *z = NULL;
+  char *z;
   sqlite3 *db = sqlite3_context_db_handle(context);
   assert( nByte>0 );
   testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH] );
@@ -121575,9 +121573,9 @@
 ** Implementation of the upper() and lower() SQL functions.
 */
 static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
-  char *z1 = NULL;
-  const char *z2 = NULL;
-  int i = 0, n = 0;
+  char *z1;
+  const char *z2;
+  int i, n;
   UNUSED_PARAMETER(argc);
   z2 = (char*)sqlite3_value_text(argv[0]);
   n = sqlite3_value_bytes(argv[0]);
@@ -121594,9 +121592,9 @@
   }
 }
 static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
-  char *z1 = NULL;
-  const char *z2 = NULL;
-  int i = 0, n = 0;
+  char *z1;
+  const char *z2;
+  int i, n;
   UNUSED_PARAMETER(argc);
   z2 = (char*)sqlite3_value_text(argv[0]);
   n = sqlite3_value_bytes(argv[0]);
@@ -121631,7 +121629,7 @@
   int NotUsed,
   sqlite3_value **NotUsed2
 ){
-  sqlite_int64 r = 0;
+  sqlite_int64 r;
   UNUSED_PARAMETER2(NotUsed, NotUsed2);
   sqlite3_randomness(sizeof(r), &r);
   if( r<0 ){
@@ -121657,8 +121655,8 @@
   int argc,
   sqlite3_value **argv
 ){
-  sqlite3_int64 n = 0;
-  unsigned char *p = NULL;
+  sqlite3_int64 n;
+  unsigned char *p;
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   n = sqlite3_value_int64(argv[0]);
@@ -121804,7 +121802,7 @@
   const struct compareInfo *pInfo, /* Information about how to do the compare */
   u32 matchOther                   /* The escape char (LIKE) or '[' (GLOB) */
 ){
-  u32 c = 0, c2 = 0;                       /* Next pattern and input string chars */
+  u32 c, c2;                       /* Next pattern and input string chars */
   u32 matchOne = pInfo->matchOne;  /* "?" or "_" */
   u32 matchAll = pInfo->matchAll;  /* "*" or "%" */
   u8 noCase = pInfo->noCase;       /* True if uppercase==lowercase */
@@ -121851,7 +121849,7 @@
       */
       if( c<=0x80 ){
         char zStop[3];
-        int bMatch = 0;
+        int bMatch;
         if( noCase ){
           zStop[0] = sqlite3Toupper(c);
           zStop[1] = sqlite3Tolower(c);
@@ -121868,7 +121866,7 @@
           if( bMatch!=SQLITE_NOMATCH ) return bMatch;
         }
       }else{
-        int bMatch = 0;
+        int bMatch;
         while( (c2 = Utf8Read(zString))!=0 ){
           if( c2!=c ) continue;
           bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
@@ -121970,9 +121968,9 @@
   int argc,
   sqlite3_value **argv
 ){
-  const unsigned char *zA = NULL, *zB = NULL;
-  u32 escape = 0;
-  int nPat = 0;
+  const unsigned char *zA, *zB;
+  u32 escape;
+  int nPat;
   sqlite3 *db = sqlite3_context_db_handle(context);
   struct compareInfo *pInfo = sqlite3_user_data(context);
   struct compareInfo backupInfo;
@@ -122105,7 +122103,7 @@
   int argc,
   sqlite3_value **argv
 ){
-  const char *zOptName = NULL;
+  const char *zOptName;
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   /* IMP: R-39564-36305 The sqlite_compileoption_used() SQL
@@ -122129,7 +122127,7 @@
   int argc,
   sqlite3_value **argv
 ){
-  int n = 0;
+  int n;
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   /* IMP: R-04922-24076 The sqlite_compileoption_get() SQL function
@@ -122159,8 +122157,8 @@
 
   switch( sqlite3_value_type(pValue) ){
     case SQLITE_FLOAT: {
-      double r1 = 0, r2 = 0;
-      const char *zVal = NULL;
+      double r1, r2;
+      const char *zVal;
       r1 = sqlite3_value_double(pValue);
       sqlite3_str_appendf(pStr, "%!.15g", r1);
       zVal = sqlite3_str_value(pStr);
@@ -122184,7 +122182,7 @@
       sqlite3StrAccumEnlarge(pStr, nBlob*2 + 4);
       if( pStr->accError==0 ){
         char *zText = pStr->zText;
-        int i = 0;
+        int i;
         for(i=0; i<nBlob; i++){
           zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];
           zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];
@@ -122259,16 +122257,16 @@
   int argc,
   sqlite3_value **argv
 ){
-  unsigned char *z = NULL, *zOut = NULL;
-  int i = 0;
+  unsigned char *z, *zOut;
+  int i;
   zOut = z = sqlite3_malloc64( argc*4+1 );
   if( z==0 ){
     sqlite3_result_error_nomem(context);
     return;
   }
   for(i=0; i<argc; i++){
-    sqlite3_int64 x = 0;
-    unsigned c = 0;
+    sqlite3_int64 x;
+    unsigned c;
     x = sqlite3_value_int64(argv[i]);
     if( x<0 || x>0x10ffff ) x = 0xfffd;
     c = (unsigned)(x & 0x1fffff);
@@ -122300,9 +122298,9 @@
   int argc,
   sqlite3_value **argv
 ){
-  int i = 0, n = 0;
-  const unsigned char *pBlob = NULL;
-  char *zHex = NULL, *z = NULL;
+  int i, n;
+  const unsigned char *pBlob;
+  char *zHex, *z;
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   pBlob = sqlite3_value_blob(argv[0]);
@@ -122328,8 +122326,8 @@
   int argc,
   sqlite3_value **argv
 ){
-  i64 n = 0;
-  int rc = 0;
+  i64 n;
+  int rc;
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   n = sqlite3_value_int64(argv[0]);
@@ -122351,17 +122349,17 @@
   int argc,
   sqlite3_value **argv
 ){
-  const unsigned char *zStr = NULL;        /* The input string A */
-  const unsigned char *zPattern = NULL;    /* The pattern string B */
-  const unsigned char *zRep = NULL;        /* The replacement string C */
-  unsigned char *zOut = NULL;              /* The output */
-  int nStr = 0;                /* Size of zStr */
-  int nPattern = 0;            /* Size of zPattern */
-  int nRep = 0;                /* Size of zRep */
-  i64 nOut = 0;                /* Maximum size of zOut */
-  int loopLimit = 0;           /* Last zStr[] that might match zPattern[] */
-  int i = 0, j = 0;                /* Loop counters */
-  unsigned cntExpand = 0;      /* Number zOut expansions */
+  const unsigned char *zStr;        /* The input string A */
+  const unsigned char *zPattern;    /* The pattern string B */
+  const unsigned char *zRep;        /* The replacement string C */
+  unsigned char *zOut;              /* The output */
+  int nStr;                /* Size of zStr */
+  int nPattern;            /* Size of zPattern */
+  int nRep;                /* Size of zRep */
+  i64 nOut;                /* Maximum size of zOut */
+  int loopLimit;           /* Last zStr[] that might match zPattern[] */
+  int i, j;                /* Loop counters */
+  unsigned cntExpand;      /* Number zOut expansions */
   sqlite3 *db = sqlite3_context_db_handle(context);
 
   assert( argc==3 );
@@ -122412,7 +122410,7 @@
         if( (cntExpand&(cntExpand-1))==0 ){
           /* Grow the size of the output buffer only on substitutions
           ** whose index is a power of two: 1, 2, 4, 8, 16, 32, ... */
-          u8 *zOld = NULL;
+          u8 *zOld;
           zOld = zOut;
           zOut = sqlite3Realloc(zOut, (int)nOut + (nOut - nStr - 1));
           if( zOut==0 ){
@@ -122444,14 +122442,14 @@
   int argc,
   sqlite3_value **argv
 ){
-  const unsigned char *zIn = NULL;         /* Input string */
-  const unsigned char *zCharSet = NULL;    /* Set of characters to trim */
-  unsigned int nIn = 0;                 /* Number of bytes in input */
-  int flags = 0;                        /* 1: trimleft  2: trimright  3: trim */
-  int i = 0;                            /* Loop counter */
+  const unsigned char *zIn;         /* Input string */
+  const unsigned char *zCharSet;    /* Set of characters to trim */
+  unsigned int nIn;                 /* Number of bytes in input */
+  int flags;                        /* 1: trimleft  2: trimright  3: trim */
+  int i;                            /* Loop counter */
   unsigned int *aLen = 0;           /* Length of each character in zCharSet */
   unsigned char **azChar = 0;       /* Individual characters in zCharSet */
-  int nChar = 0;                        /* Number of characters in zCharSet */
+  int nChar;                        /* Number of characters in zCharSet */
 
   if( sqlite3_value_type(argv[0])==SQLITE_NULL ){
     return;
@@ -122470,7 +122468,7 @@
   }else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){
     return;
   }else{
-    const unsigned char *z = NULL;
+    const unsigned char *z;
     for(z=zCharSet, nChar=0; *z; nChar++){
       SQLITE_SKIP_UTF8(z);
     }
@@ -122607,7 +122605,7 @@
 */
 static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){
   const char *zFile = (const char *)sqlite3_value_text(argv[0]);
-  const char *zProc = NULL;
+  const char *zProc;
   sqlite3 *db = sqlite3_context_db_handle(context);
   char *zErrMsg = 0;
 
@@ -122656,8 +122654,8 @@
 ** it overflows an integer.
 */
 static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){
-  SumCtx *p = NULL;
-  int type = 0;
+  SumCtx *p;
+  int type;
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   p = sqlite3_aggregate_context(context, sizeof(*p));
@@ -122678,8 +122676,8 @@
 }
 #ifndef SQLITE_OMIT_WINDOWFUNC
 static void sumInverse(sqlite3_context *context, int argc, sqlite3_value**argv){
-  SumCtx *p = NULL;
-  int type = 0;
+  SumCtx *p;
+  int type;
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   p = sqlite3_aggregate_context(context, sizeof(*p));
@@ -122703,7 +122701,7 @@
 # define sumInverse 0
 #endif /* SQLITE_OMIT_WINDOWFUNC */
 static void sumFinalize(sqlite3_context *context){
-  SumCtx *p = NULL;
+  SumCtx *p;
   p = sqlite3_aggregate_context(context, 0);
   if( p && p->cnt>0 ){
     if( p->overflow ){
@@ -122716,14 +122714,14 @@
   }
 }
 static void avgFinalize(sqlite3_context *context){
-  SumCtx *p = NULL;
+  SumCtx *p;
   p = sqlite3_aggregate_context(context, 0);
   if( p && p->cnt>0 ){
     sqlite3_result_double(context, p->rSum/(double)p->cnt);
   }
 }
 static void totalFinalize(sqlite3_context *context){
-  SumCtx *p = NULL;
+  SumCtx *p;
   p = sqlite3_aggregate_context(context, 0);
   /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
   sqlite3_result_double(context, p ? p->rSum : (double)0);
@@ -122745,7 +122743,7 @@
 ** Routines to implement the count() aggregate function.
 */
 static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){
-  CountCtx *p = NULL;
+  CountCtx *p;
   p = sqlite3_aggregate_context(context, sizeof(*p));
   if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && p ){
     p->n++;
@@ -122761,13 +122759,13 @@
 #endif
 }
 static void countFinalize(sqlite3_context *context){
-  CountCtx *p = NULL;
+  CountCtx *p;
   p = sqlite3_aggregate_context(context, 0);
   sqlite3_result_int64(context, p ? p->n : 0);
 }
 #ifndef SQLITE_OMIT_WINDOWFUNC
 static void countInverse(sqlite3_context *ctx, int argc, sqlite3_value **argv){
-  CountCtx *p = NULL;
+  CountCtx *p;
   p = sqlite3_aggregate_context(ctx, sizeof(*p));
   /* p is always non-NULL since countStep() will have been called first */
   if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && ALWAYS(p) ){
@@ -122790,7 +122788,7 @@
   sqlite3_value **argv
 ){
   Mem *pArg  = (Mem *)argv[0];
-  Mem *pBest = NULL;
+  Mem *pBest;
   UNUSED_PARAMETER(NotUsed);
 
   pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));
@@ -122799,8 +122797,8 @@
   if( sqlite3_value_type(pArg)==SQLITE_NULL ){
     if( pBest->flags ) sqlite3SkipAccumulatorLoad(context);
   }else if( pBest->flags ){
-    int max = 0;
-    int cmp = 0;
+    int max;
+    int cmp;
     CollSeq *pColl = sqlite3GetFuncCollSeq(context);
     /* This step function is used for both the min() and max() aggregates,
     ** the only difference between the two being that the sense of the
@@ -122823,7 +122821,7 @@
   }
 }
 static void minMaxValueFinalize(sqlite3_context *context, int bValue){
-  sqlite3_value *pRes = NULL;
+  sqlite3_value *pRes;
   pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);
   if( pRes ){
     if( pRes->flags ){
@@ -122871,10 +122869,10 @@
   int argc,
   sqlite3_value **argv
 ){
-  const char *zVal = NULL;
-  GroupConcatCtx *pGCC = NULL;
-  const char *zSep = NULL;
-  int nVal = 0, nSep = 0;
+  const char *zVal;
+  GroupConcatCtx *pGCC;
+  const char *zSep;
+  int nVal, nSep;
   assert( argc==1 || argc==2 );
   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;
   pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));
@@ -122942,7 +122940,7 @@
   int argc,
   sqlite3_value **argv
 ){
-  GroupConcatCtx *pGCC = NULL;
+  GroupConcatCtx *pGCC;
   assert( argc==1 || argc==2 );
   (void)argc;  /* Suppress unused parameter warning */
   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;
@@ -122950,7 +122948,7 @@
   /* pGCC is always non-NULL since groupConcatStep() will have always
   ** run frist to initialize it */
   if( ALWAYS(pGCC) ){
-    int nVS = 0;
+    int nVS;
     /* Must call sqlite3_value_text() to convert the argument into text prior
     ** to invoking sqlite3_value_bytes(), in case the text encoding is UTF16 */
     (void)sqlite3_value_text(argv[0]);
@@ -123032,8 +123030,8 @@
 ** sensitive.
 */
 SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){
-  struct compareInfo *pInfo = NULL;
-  int flags = 0;
+  struct compareInfo *pInfo;
+  int flags;
   if( caseSensitive ){
     pInfo = (struct compareInfo*)&likeInfoAlt;
     flags = SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE;
@@ -123065,8 +123063,8 @@
 ** false.
 */
 SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){
-  FuncDef *pDef = NULL;
-  int nExpr = 0;
+  FuncDef *pDef;
+  int nExpr;
   assert( pExpr!=0 );
   assert( pExpr->op==TK_FUNCTION );
   assert( ExprUseXList(pExpr) );
@@ -123096,7 +123094,7 @@
     aWc[3] = 0;
   }else{
     Expr *pEscape = pExpr->x.pList->a[2].pExpr;
-    char *zEscape = NULL;
+    char *zEscape;
     if( pEscape->op!=TK_STRING ) return 0;
     assert( !ExprHasProperty(pEscape, EP_IntValue) );
     zEscape = pEscape->u.zToken;
@@ -123295,8 +123293,8 @@
   int argc,
   sqlite3_value **argv
 ){
-  int type0 = 0;
-  double x = 0;
+  int type0;
+  double x;
   UNUSED_PARAMETER(argc);
   assert( argc==1 );
   type0 = sqlite3_value_numeric_type(argv[0]);
@@ -123734,7 +123732,7 @@
         ** identified by the test.  */
         if( IsPrimaryKeyIndex(pIdx) ){
           if( aiCol ){
-            int i = 0;
+            int i;
             for(i=0; i<nCol; i++) aiCol[i] = pFKey->aCol[i].iFrom;
           }
           break;
@@ -123744,11 +123742,11 @@
         ** map to an explicit list of columns in table pParent. Check if this
         ** index matches those columns. Also, check that the index uses
         ** the default collation sequences for each column. */
-        int i = 0, j = 0;
+        int i, j;
         for(i=0; i<nCol; i++){
           i16 iCol = pIdx->aiColumn[i];     /* Index of column in parent tbl */
-          const char *zDfltColl = NULL;            /* Def. collation for column */
-          char *zIdxCol = NULL;                    /* Name of indexed column */
+          const char *zDfltColl;            /* Def. collation for column */
+          char *zIdxCol;                    /* Name of indexed column */
 
           if( iCol<0 ) break; /* No foreign keys against expression indexes */
 
@@ -123824,7 +123822,7 @@
   int nIncr,            /* Increment constraint counter by this */
   int isIgnore          /* If true, pretend pTab contains all NULL values */
 ){
-  int i = 0;                                    /* Iterator variable */
+  int i;                                    /* Iterator variable */
   Vdbe *v = sqlite3GetVdbe(pParse);         /* Vdbe to add code to */
   int iCur = pParse->nTab - 1;              /* Cursor number to use */
   int iOk = sqlite3VdbeMakeLabel(pParse);   /* jump here if parent key found */
@@ -123855,7 +123853,7 @@
     if( pIdx==0 ){
       /* If pIdx is NULL, then the parent key is the INTEGER PRIMARY KEY
       ** column of the parent table (table pTab).  */
-      int iMustBeInt = 0;               /* Address of MustBeInt instruction */
+      int iMustBeInt;               /* Address of MustBeInt instruction */
       int regTemp = sqlite3GetTempReg(pParse);
 
       /* Invoke MustBeInt to coerce the child key value to an integer (i.e.
@@ -123972,9 +123970,9 @@
   int regBase,       /* Contents of table pTab */
   i16 iCol           /* Which column of pTab is desired */
 ){
-  Expr *pExpr = NULL;
-  Column *pCol = NULL;
-  const char *zColl = NULL;
+  Expr *pExpr;
+  Column *pCol;
+  const char *zColl;
   sqlite3 *db = pParse->db;
 
   pExpr = sqlite3Expr(db, TK_REGISTER, 0);
@@ -124057,10 +124055,10 @@
   int nIncr                       /* Amount to increment deferred counter by */
 ){
   sqlite3 *db = pParse->db;       /* Database handle */
-  int i = 0;                          /* Iterator variable */
+  int i;                          /* Iterator variable */
   Expr *pWhere = 0;               /* WHERE clause to scan with */
   NameContext sNameContext;       /* Context used to resolve WHERE clause */
-  WhereInfo *pWInfo = NULL;              /* Context used by sqlite3WhereXXX() */
+  WhereInfo *pWInfo;              /* Context used by sqlite3WhereXXX() */
   int iFkIfZero = 0;              /* Address of OP_FkIfZero */
   Vdbe *v = sqlite3GetVdbe(pParse);
 
@@ -124083,11 +124081,11 @@
   ** be applied to each child key value before the comparison takes place.
   */
   for(i=0; i<pFKey->nCol; i++){
-    Expr *pLeft = NULL;                  /* Value from parent table row */
-    Expr *pRight = NULL;                 /* Column ref to child table */
-    Expr *pEq = NULL;                    /* Expression (pLeft = pRight) */
-    i16 iCol = 0;                     /* Index of column in child table */
-    const char *zCol = NULL;             /* Name of column in child table */
+    Expr *pLeft;                  /* Value from parent table row */
+    Expr *pRight;                 /* Column ref to child table */
+    Expr *pEq;                    /* Expression (pLeft = pRight) */
+    i16 iCol;                     /* Index of column in child table */
+    const char *zCol;             /* Name of column in child table */
 
     iCol = pIdx ? pIdx->aiColumn[i] : -1;
     pLeft = exprTableRegister(pParse, pTab, regData, iCol);
@@ -124114,15 +124112,15 @@
   ** by the caller.
   */
   if( pTab==pFKey->pFrom && nIncr>0 ){
-    Expr *pNe = NULL;                    /* Expression (pLeft != pRight) */
-    Expr *pLeft = NULL;                  /* Value from parent table row */
-    Expr *pRight = NULL;                 /* Column ref to child table */
+    Expr *pNe;                    /* Expression (pLeft != pRight) */
+    Expr *pLeft;                  /* Value from parent table row */
+    Expr *pRight;                 /* Column ref to child table */
     if( HasRowid(pTab) ){
       pLeft = exprTableRegister(pParse, pTab, regData, -1);
       pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, -1);
       pNe = sqlite3PExpr(pParse, TK_NE, pLeft, pRight);
     }else{
-      Expr *pEq = NULL, *pAll = 0;
+      Expr *pEq, *pAll = 0;
       assert( pIdx!=0 );
       for(i=0; i<pIdx->nKeyCol; i++){
         i16 iCol = pIdx->aiColumn[i];
@@ -124204,11 +124202,11 @@
 ** changes.
 */
 SQLITE_PRIVATE void sqlite3FkClearTriggerCache(sqlite3 *db, int iDb){
-  HashElem *k = NULL;
+  HashElem *k;
   Hash *pHash = &db->aDb[iDb].pSchema->tblHash;
   for(k=sqliteHashFirst(pHash); k; k=sqliteHashNext(k)){
     Table *pTab = sqliteHashData(k);
-    FKey *pFKey = NULL;
+    FKey *pFKey;
     if( !IsOrdinaryTable(pTab) ) continue;
     for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
       fkTriggerDelete(db, pFKey->apTrigger[0]); pFKey->apTrigger[0] = 0;
@@ -124248,7 +124246,7 @@
       ** generating any VDBE code. If one can be found, then jump over
       ** the entire DELETE if there are no outstanding deferred constraints
       ** when this statement is run.  */
-      FKey *p = NULL;
+      FKey *p;
       for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){
         if( p->isDeferred || (db->flags & SQLITE_DeferFKs) ) break;
       }
@@ -124303,7 +124301,7 @@
   int *aChange,                   /* Array indicating modified columns */
   int bChngRowid                  /* True if rowid is modified by this update */
 ){
-  int i = 0;
+  int i;
   for(i=0; i<p->nCol; i++){
     int iChildKey = p->aCol[i].iFrom;
     if( aChange[iChildKey]>=0 ) return 1;
@@ -124330,10 +124328,10 @@
   int *aChange,
   int bChngRowid
 ){
-  int i = 0;
+  int i;
   for(i=0; i<p->nCol; i++){
     char *zKey = p->aCol[i].zCol;
-    int iKey = 0;
+    int iKey;
     for(iKey=0; iKey<pTab->nCol; iKey++){
       if( aChange[iKey]>=0 || (iKey==pTab->iPKey && bChngRowid) ){
         Column *pCol = &pTab->aCol[iKey];
@@ -124395,9 +124393,9 @@
   int bChngRowid                  /* True if rowid is UPDATEd */
 ){
   sqlite3 *db = pParse->db;       /* Database handle */
-  FKey *pFKey = NULL;                    /* Used to iterate through FKs */
-  int iDb = 0;                        /* Index of database containing pTab */
-  const char *zDb = NULL;                /* Name of database containing pTab */
+  FKey *pFKey;                    /* Used to iterate through FKs */
+  int iDb;                        /* Index of database containing pTab */
+  const char *zDb;                /* Name of database containing pTab */
   int isIgnoreErrors = pParse->disableTriggers;
 
   /* Exactly one of regOld and regNew should be non-zero. */
@@ -124413,12 +124411,12 @@
   /* Loop through all the foreign key constraints for which pTab is the
   ** child table (the table that the foreign key definition is part of).  */
   for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
-    Table *pTo = NULL;                   /* Parent table of foreign key pFKey */
+    Table *pTo;                   /* Parent table of foreign key pFKey */
     Index *pIdx = 0;              /* Index on key columns in pTo */
     int *aiFree = 0;
-    int *aiCol = NULL;
-    int iCol = 0;
-    int i = 0;
+    int *aiCol;
+    int iCol;
+    int i;
     int bIgnore = 0;
 
     if( aChange
@@ -124451,7 +124449,7 @@
         Vdbe *v = sqlite3GetVdbe(pParse);
         int iJump = sqlite3VdbeCurrentAddr(v) + pFKey->nCol + 1;
         for(i=0; i<pFKey->nCol; i++){
-          int iFromCol = 0, iReg = 0;
+          int iFromCol, iReg;
           iFromCol = pFKey->aCol[i].iFrom;
           iReg = sqlite3TableColumnToStorage(pFKey->pFrom,iFromCol) + regOld+1;
           sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iJump); VdbeCoverage(v);
@@ -124478,7 +124476,7 @@
       ** authorization callback returns SQLITE_IGNORE, behave as if any
       ** values read from the parent table are NULL. */
       if( db->xAuth ){
-        int rcauth = 0;
+        int rcauth;
         char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zCnName;
         rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);
         bIgnore = (rcauth==SQLITE_IGNORE);
@@ -124517,7 +124515,7 @@
   ** (the "child" constraints) */
   for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
     Index *pIdx = 0;              /* Foreign key index for pFKey */
-    SrcList *pSrc = NULL;
+    SrcList *pSrc;
     int *aiCol = 0;
 
     if( aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid)==0 ){
@@ -124595,8 +124593,8 @@
 ){
   u32 mask = 0;
   if( pParse->db->flags&SQLITE_ForeignKeys && IsOrdinaryTable(pTab) ){
-    FKey *p = NULL;
-    int i = 0;
+    FKey *p;
+    int i;
     for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){
       for(i=0; i<p->nCol; i++) mask |= COLUMN_MASK(p->aCol[i].iFrom);
     }
@@ -124656,7 +124654,7 @@
     }else{
       /* This is an UPDATE. Foreign key processing is only required if the
       ** operation modifies one or more child or parent key columns. */
-      FKey *p = NULL;
+      FKey *p;
 
       /* Check if any child key columns are being modified. */
       for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){
@@ -124714,8 +124712,8 @@
   ExprList *pChanges              /* Change-list for UPDATE, NULL for DELETE */
 ){
   sqlite3 *db = pParse->db;       /* Database handle */
-  int action = 0;                     /* One of OE_None, OE_Cascade etc. */
-  Trigger *pTrigger = NULL;              /* Trigger definition to return */
+  int action;                     /* One of OE_None, OE_Cascade etc. */
+  Trigger *pTrigger;              /* Trigger definition to return */
   int iAction = (pChanges!=0);    /* 1 for UPDATE, 0 for DELETE */
 
   action = pFKey->aAction[iAction];
@@ -124725,15 +124723,15 @@
   pTrigger = pFKey->apTrigger[iAction];
 
   if( action!=OE_None && !pTrigger ){
-    char const *zFrom = NULL;            /* Name of child table */
-    int nFrom = 0;                    /* Length in bytes of zFrom */
+    char const *zFrom;            /* Name of child table */
+    int nFrom;                    /* Length in bytes of zFrom */
     Index *pIdx = 0;              /* Parent key index for this FK */
     int *aiCol = 0;               /* child table cols -> parent key cols */
     TriggerStep *pStep = 0;        /* First (only) step of trigger program */
     Expr *pWhere = 0;             /* WHERE clause of trigger step */
     ExprList *pList = 0;          /* Changes list if ON UPDATE CASCADE */
     Select *pSelect = 0;          /* If RESTRICT, "SELECT RAISE(...)" */
-    int i = 0;                        /* Iterator variable */
+    int i;                        /* Iterator variable */
     Expr *pWhen = 0;              /* WHEN clause for the trigger */
 
     if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;
@@ -124744,8 +124742,8 @@
       Token tNew = { "new", 3 };  /* Literal "new" token */
       Token tFromCol;             /* Name of column in child table */
       Token tToCol;               /* Name of column in parent table */
-      int iFromCol = 0;               /* Idx of column in child table */
-      Expr *pEq = NULL;                  /* tFromCol = OLD.tToCol */
+      int iFromCol;               /* Idx of column in child table */
+      Expr *pEq;                  /* tFromCol = OLD.tToCol */
 
       iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
       assert( iFromCol>=0 );
@@ -124785,14 +124783,14 @@
       }
 
       if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){
-        Expr *pNew = NULL;
+        Expr *pNew;
         if( action==OE_Cascade ){
           pNew = sqlite3PExpr(pParse, TK_DOT,
             sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
             sqlite3ExprAlloc(db, TK_ID, &tToCol, 0));
         }else if( action==OE_SetDflt ){
           Column *pCol = pFKey->pFrom->aCol + iFromCol;
-          Expr *pDflt = NULL;
+          Expr *pDflt;
           if( pCol->colFlags & COLFLAG_GENERATED ){
             testcase( pCol->colFlags & COLFLAG_VIRTUAL );
             testcase( pCol->colFlags & COLFLAG_STORED );
@@ -124819,7 +124817,7 @@
 
     if( action==OE_Restrict ){
       Token tFrom;
-      Expr *pRaise = NULL;
+      Expr *pRaise;
 
       tFrom.z = zFrom;
       tFrom.n = nFrom;
@@ -124912,7 +124910,7 @@
   ** for this operation (either update or delete), invoke the associated
   ** trigger sub-program.  */
   if( pParse->db->flags&SQLITE_ForeignKeys ){
-    FKey *pFKey = NULL;                  /* Iterator variable */
+    FKey *pFKey;                  /* Iterator variable */
     for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
       if( aChange==0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) ){
         Trigger *pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
@@ -124932,8 +124930,8 @@
 ** hash table.
 */
 SQLITE_PRIVATE void sqlite3FkDelete(sqlite3 *db, Table *pTab){
-  FKey *pFKey = NULL;                    /* Iterator variable */
-  FKey *pNext = NULL;                    /* Copy of pFKey->pNextFrom */
+  FKey *pFKey;                    /* Iterator variable */
+  FKey *pNext;                    /* Copy of pFKey->pNextFrom */
 
   assert( IsOrdinaryTable(pTab) );
   for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pNext){
@@ -125004,7 +125002,7 @@
   Table *pTab,    /* The table to be opened */
   int opcode      /* OP_OpenRead or OP_OpenWrite */
 ){
-  Vdbe *v = NULL;
+  Vdbe *v;
   assert( !IsVirtual(pTab) );
   assert( pParse->pVdbe!=0 );
   v = pParse->pVdbe;
@@ -125054,7 +125052,7 @@
     ** sqliteDeleteIndex() when the Index structure itself is cleaned
     ** up.
     */
-    int n = 0;
+    int n;
     Table *pTab = pIdx->pTable;
     pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);
     if( !pIdx->zColAff ){
@@ -125063,7 +125061,7 @@
     }
     for(n=0; n<pIdx->nColumn; n++){
       i16 x = pIdx->aiColumn[n];
-      char aff = 0;
+      char aff;
       if( x>=0 ){
         aff = pTab->aCol[x].affinity;
       }else if( x==XN_ROWID ){
@@ -125124,14 +125122,14 @@
 ** Apply the type checking to that array of registers.
 */
 SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg){
-  int i = 0, j = 0;
-  char *zColAff = NULL;
+  int i, j;
+  char *zColAff;
   if( pTab->tabFlags & TF_Strict ){
     if( iReg==0 ){
       /* Move the previous opcode (which should be OP_MakeRecord) forward
       ** by one slot and insert a new OP_TypeCheck where the current
       ** OP_MakeRecord is found */
-      VdbeOp *pPrev = NULL;
+      VdbeOp *pPrev;
       sqlite3VdbeAppendP4(v, pTab, P4_TABLE);
       pPrev = sqlite3VdbeGetOp(v, -1);
       assert( pPrev!=0 );
@@ -125186,7 +125184,7 @@
 */
 static int readsTable(Parse *p, int iDb, Table *pTab){
   Vdbe *v = sqlite3GetVdbe(p);
-  int i = 0;
+  int i;
   int iEnd = sqlite3VdbeCurrentAddr(v);
 #ifndef SQLITE_OMIT_VIRTUALTABLE
   VTable *pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p->db, pTab) : 0;
@@ -125196,7 +125194,7 @@
     VdbeOp *pOp = sqlite3VdbeGetOp(v, i);
     assert( pOp!=0 );
     if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){
-      Index *pIndex = NULL;
+      Index *pIndex;
       Pgno tnum = pOp->p2;
       if( tnum==pTab->tnum ){
         return 1;
@@ -125242,11 +125240,11 @@
   int iRegStore,    /* Register holding the first column */
   Table *pTab       /* The table */
 ){
-  int i = 0;
+  int i;
   Walker w;
-  Column *pRedo = NULL;
-  int eProgress = 0;
-  VdbeOp *pOp = NULL;
+  Column *pRedo;
+  int eProgress;
+  VdbeOp *pOp;
 
   assert( pTab->tabFlags & TF_HasGenerated );
   testcase( pTab->tabFlags & TF_HasVirtual );
@@ -125262,7 +125260,7 @@
       /* Change the OP_Affinity argument to '@' (NONE) for all stored
       ** columns.  '@' is the no-op affinity and those columns have not
       ** yet been computed. */
-      int ii = 0, jj = 0;
+      int ii, jj;
       char *zP4 = pOp->p4.z;
       assert( zP4!=0 );
       assert( pOp->p4type==P4_DYNAMIC );
@@ -125312,7 +125310,7 @@
     for(i=0; i<pTab->nCol; i++){
       Column *pCol = pTab->aCol + i;
       if( (pCol->colFlags & COLFLAG_NOTAVAIL)!=0 ){
-        int x = 0;
+        int x;
         pCol->colFlags |= COLFLAG_BUSY;
         w.eCode = 0;
         sqlite3WalkExpr(&w, sqlite3ColumnExpr(pTab, pCol));
@@ -125372,7 +125370,7 @@
    && (pParse->db->mDbFlags & DBFLAG_Vacuum)==0
   ){
     Parse *pToplevel = sqlite3ParseToplevel(pParse);
-    AutoincInfo *pInfo = NULL;
+    AutoincInfo *pInfo;
     Table *pSeqTab = pParse->db->aDb[iDb].pSchema->pSeqTab;
 
     /* Verify that the sqlite_sequence table exists and is an ordinary
@@ -125413,10 +125411,10 @@
 ** register used by the autoincrement tracker.
 */
 SQLITE_PRIVATE void sqlite3AutoincrementBegin(Parse *pParse){
-  AutoincInfo *p = NULL;            /* Information about an AUTOINCREMENT */
+  AutoincInfo *p;            /* Information about an AUTOINCREMENT */
   sqlite3 *db = pParse->db;  /* The database connection */
-  Db *pDb = NULL;                   /* Database only autoinc table */
-  int memId = 0;                 /* Register holding max rowid */
+  Db *pDb;                   /* Database only autoinc table */
+  int memId;                 /* Register holding max rowid */
   Vdbe *v = pParse->pVdbe;   /* VDBE under construction */
 
   /* This routine is never called during trigger-generation.  It is
@@ -125441,7 +125439,7 @@
       /* 10 */ {OP_Integer, 0,  0, 0},
       /* 11 */ {OP_Close,   0,  0, 0}
     };
-    VdbeOp *aOp = NULL;
+    VdbeOp *aOp;
     pDb = &db->aDb[p->iDb];
     memId = p->regCtr;
     assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );
@@ -125487,7 +125485,7 @@
 ** routine just before the "exit" code.
 */
 static SQLITE_NOINLINE void autoIncrementEnd(Parse *pParse){
-  AutoincInfo *p = NULL;
+  AutoincInfo *p;
   Vdbe *v = pParse->pVdbe;
   sqlite3 *db = pParse->db;
 
@@ -125501,9 +125499,9 @@
       /* 3 */ {OP_Insert,      0, 0, 0},
       /* 4 */ {OP_Close,       0, 0, 0}
     };
-    VdbeOp *aOp = NULL;
+    VdbeOp *aOp;
     Db *pDb = &db->aDb[p->iDb];
-    int iRec = 0;
+    int iRec;
     int memId = p->regCtr;
 
     iRec = sqlite3GetTempReg(pParse);
@@ -125650,42 +125648,42 @@
   int onError,          /* How to handle constraint errors */
   Upsert *pUpsert       /* ON CONFLICT clauses for upsert, or NULL */
 ){
-  sqlite3 *db = NULL;          /* The main database structure */
-  Table *pTab = NULL;          /* The table to insert into.  aka TABLE */
-  int i = 0, j = 0;             /* Loop counters */
-  Vdbe *v = NULL;              /* Generate code into this virtual machine */
-  Index *pIdx = NULL;          /* For looping over indices of the table */
-  int nColumn = 0;          /* Number of columns in the data */
+  sqlite3 *db;          /* The main database structure */
+  Table *pTab;          /* The table to insert into.  aka TABLE */
+  int i, j;             /* Loop counters */
+  Vdbe *v;              /* Generate code into this virtual machine */
+  Index *pIdx;          /* For looping over indices of the table */
+  int nColumn;          /* Number of columns in the data */
   int nHidden = 0;      /* Number of hidden columns if TABLE is virtual */
   int iDataCur = 0;     /* VDBE cursor that is the main data repository */
   int iIdxCur = 0;      /* First index cursor */
   int ipkColumn = -1;   /* Column that is the INTEGER PRIMARY KEY */
-  int endOfLoop = 0;        /* Label for the end of the insertion loop */
+  int endOfLoop;        /* Label for the end of the insertion loop */
   int srcTab = 0;       /* Data comes from this temporary cursor if >=0 */
   int addrInsTop = 0;   /* Jump to label "D" */
   int addrCont = 0;     /* Top of insert loop. Label "C" in templates 3 and 4 */
   SelectDest dest;      /* Destination for SELECT on rhs of INSERT */
-  int iDb = 0;              /* Index of database holding TABLE */
+  int iDb;              /* Index of database holding TABLE */
   u8 useTempTable = 0;  /* Store SELECT results in intermediate table */
   u8 appendFlag = 0;    /* True if the insert is likely to be an append */
-  u8 withoutRowid = 0;      /* 0 for normal table.  1 for WITHOUT ROWID table */
-  u8 bIdListInOrder = 0;    /* True if IDLIST is in table order */
+  u8 withoutRowid;      /* 0 for normal table.  1 for WITHOUT ROWID table */
+  u8 bIdListInOrder;    /* True if IDLIST is in table order */
   ExprList *pList = 0;  /* List of VALUES() to be inserted  */
-  int iRegStore = 0;        /* Register in which to store next column */
+  int iRegStore;        /* Register in which to store next column */
 
   /* Register allocations */
   int regFromSelect = 0;/* Base register for data coming from SELECT */
   int regAutoinc = 0;   /* Register holding the AUTOINCREMENT counter */
   int regRowCount = 0;  /* Memory cell used for the row counter */
-  int regIns = 0;           /* Block of regs holding rowid+data being inserted */
-  int regRowid = 0;         /* registers holding insert rowid */
-  int regData = 0;          /* register holding first column to insert */
+  int regIns;           /* Block of regs holding rowid+data being inserted */
+  int regRowid;         /* registers holding insert rowid */
+  int regData;          /* register holding first column to insert */
   int *aRegIdx = 0;     /* One register allocated to each index */
 
 #ifndef SQLITE_OMIT_TRIGGER
-  int isView = 0;                 /* True if attempting to insert into a view */
-  Trigger *pTrigger = NULL;          /* List of triggers on pTab, if required */
-  int tmask = 0;                  /* Mask of trigger times */
+  int isView;                 /* True if attempting to insert into a view */
+  Trigger *pTrigger;          /* List of triggers on pTab, if required */
+  int tmask;                  /* Mask of trigger times */
 #endif
 
   db = pParse->db;
@@ -125861,9 +125859,9 @@
   if( pSelect ){
     /* Data is coming from a SELECT or from a multi-row VALUES clause.
     ** Generate a co-routine to run the SELECT. */
-    int regYield = 0;       /* Register holding co-routine entry-point */
-    int addrTop = 0;        /* Top of the co-routine */
-    int rc = 0;             /* Result code */
+    int regYield;       /* Register holding co-routine entry-point */
+    int addrTop;        /* Top of the co-routine */
+    int rc;             /* Result code */
 
     regYield = ++pParse->nMem;
     addrTop = sqlite3VdbeCurrentAddr(v) + 1;
@@ -125905,9 +125903,9 @@
       **         goto L
       **      M: ...
       */
-      int regRec = 0;          /* Register to hold packed record */
-      int regTempRowid = 0;    /* Register to hold temp table ROWID */
-      int addrL = 0;           /* Label "L" */
+      int regRec;          /* Register to hold packed record */
+      int regTempRowid;    /* Register to hold temp table ROWID */
+      int addrL;           /* Label "L" */
 
       srcTab = pParse->nTab++;
       regRec = sqlite3GetTempReg(pParse);
@@ -125997,7 +125995,7 @@
 
   /* If this is not a view, open the table and and all indices */
   if( !isView ){
-    int nIdx = 0;
+    int nIdx;
     nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,
                                       &iDataCur, &iIdxCur);
     aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));
@@ -126013,7 +126011,7 @@
   }
 #ifndef SQLITE_OMIT_UPSERT
   if( pUpsert ){
-    Upsert *pNx = NULL;
+    Upsert *pNx;
     if( IsVirtual(pTab) ){
       sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"",
               pTab->zName);
@@ -126087,8 +126085,8 @@
   nHidden = 0;
   iRegStore = regData;  assert( regData==regRowid+1 );
   for(i=0; i<pTab->nCol; i++, iRegStore++){
-    int k = 0;
-    u32 colFlags = 0;
+    int k;
+    u32 colFlags;
     assert( i>=nHidden );
     if( i==pTab->iPKey ){
       /* tag-20191021-002: References to the INTEGER PRIMARY KEY are filled
@@ -126172,7 +126170,7 @@
     if( ipkColumn<0 ){
       sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);
     }else{
-      int addr1 = 0;
+      int addr1;
       assert( !withoutRowid );
       if( useTempTable ){
         sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regCols);
@@ -126242,7 +126240,7 @@
       ** to generate a unique primary key value.
       */
       if( !appendFlag ){
-        int addr1 = 0;
+        int addr1;
         if( !IsVirtual(pTab) ){
           addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); VdbeCoverage(v);
           sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);
@@ -126285,7 +126283,7 @@
 #endif
     {
       int isReplace = 0;/* Set to true if constraints may cause a replace */
-      int bUseSeek = 0;     /* True to use OPFLAG_SEEKRESULT */
+      int bUseSeek;     /* True to use OPFLAG_SEEKRESULT */
       sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
           regIns, 0, ipkColumn>=0, onError, endOfLoop, &isReplace, 0, pUpsert
       );
@@ -126622,18 +126620,18 @@
   int *aiChng,         /* column i is unchanged if aiChng[i]<0 */
   Upsert *pUpsert      /* ON CONFLICT clauses, if any.  NULL otherwise */
 ){
-  Vdbe *v = NULL;             /* VDBE under constrution */
-  Index *pIdx = NULL;         /* Pointer to one of the indices */
+  Vdbe *v;             /* VDBE under constrution */
+  Index *pIdx;         /* Pointer to one of the indices */
   Index *pPk = 0;      /* The PRIMARY KEY index for WITHOUT ROWID tables */
-  sqlite3 *db = NULL;         /* Database connection */
-  int i = 0;               /* loop counter */
-  int ix = 0;              /* Index loop counter */
-  int nCol = 0;            /* Number of columns */
-  int onError = 0;         /* Conflict resolution strategy */
+  sqlite3 *db;         /* Database connection */
+  int i;               /* loop counter */
+  int ix;              /* Index loop counter */
+  int nCol;            /* Number of columns */
+  int onError;         /* Conflict resolution strategy */
   int seenReplace = 0; /* True if REPLACE is used to resolve INT PK conflict */
-  int nPkField = 0;        /* Number of fields in PRIMARY KEY. 1 for ROWID tables */
+  int nPkField;        /* Number of fields in PRIMARY KEY. 1 for ROWID tables */
   Upsert *pUpsertClause = 0;  /* The specific ON CONFLICT clause for pIdx */
-  u8 isUpdate = 0;           /* True if this is an UPDATE operation */
+  u8 isUpdate;           /* True if this is an UPDATE operation */
   u8 bAffinityDone = 0;  /* True if the OP_Affinity operation has been run */
   int upsertIpkReturn = 0; /* Address of Goto at end of IPK uniqueness check */
   int upsertIpkDelay = 0;  /* Address of Goto to bypass initial IPK check */
@@ -126641,10 +126639,10 @@
   int ipkBottom = 0;     /* OP_Goto at the end of the IPK uniqueness check */
   /* Variables associated with retesting uniqueness constraints after
   ** replace triggers fire have run */
-  int regTrigCnt = 0;       /* Register used to count replace trigger invocations */
+  int regTrigCnt;       /* Register used to count replace trigger invocations */
   int addrRecheck = 0;  /* Jump here to recheck all uniqueness constraints */
   int lblRecheckOk = 0; /* Each recheck jumps to this label if it passes */
-  Trigger *pTrigger = NULL;    /* List of DELETE triggers on the table pTab */
+  Trigger *pTrigger;    /* List of DELETE triggers on the table pTab */
   int nReplaceTrig = 0; /* Number of replace triggers coded */
   IndexIterator sIdxIter;  /* Index iterator */
 
@@ -126679,9 +126677,9 @@
     int nGenerated = 0;       /* Number of generated columns with NOT NULL */
     while(1){  /* Make 2 passes over columns. Exit loop via "break" */
       for(i=0; i<nCol; i++){
-        int iReg = 0;                        /* Register holding column value */
+        int iReg;                        /* Register holding column value */
         Column *pCol = &pTab->aCol[i];   /* The column to check for NOT NULL */
-        int isGenerated = 0;                 /* non-zero if column is generated */
+        int isGenerated;                 /* non-zero if column is generated */
         onError = pCol->notNull;
         if( onError==OE_None ) continue; /* No NOT NULL on this column */
         if( i==pTab->iPKey ){
@@ -126780,8 +126778,8 @@
     pParse->iSelfTab = -(regNewData+1);
     onError = overrideError!=OE_Default ? overrideError : OE_Abort;
     for(i=0; i<pCheck->nExpr; i++){
-      int allOk = 0;
-      Expr *pCopy = NULL;
+      int allOk;
+      Expr *pCopy;
       Expr *pExpr = pCheck->a[i].pExpr;
       if( aiChng
        && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)
@@ -126866,10 +126864,10 @@
       /* Otherwise, we'll need to run the IndexListTerm array version of the
       ** iterator to ensure that all of the ON CONFLICT conditions are
       ** checked first and in order. */
-      int nIdx = 0, jj = 0;
-      u64 nByte = 0;
-      Upsert *pTerm = NULL;
-      u8 *bUsed = NULL;
+      int nIdx, jj;
+      u64 nByte;
+      Upsert *pTerm;
+      u8 *bUsed;
       for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){
          assert( aRegIdx[nIdx]>0 );
       }
@@ -127104,11 +127102,11 @@
       pIdx;
       pIdx = indexIteratorNext(&sIdxIter, &ix)
   ){
-    int regIdx = 0;          /* Range of registers hold conent for pIdx */
-    int regR = 0;            /* Range of registers holding conflicting PK */
-    int iThisCur = 0;        /* Cursor for this UNIQUE index */
-    int addrUniqueOk = 0;    /* Jump here if the UNIQUE constraint is satisfied */
-    int addrConflictCk = 0;  /* First opcode in the conflict check logic */
+    int regIdx;          /* Range of registers hold conent for pIdx */
+    int regR;            /* Range of registers holding conflicting PK */
+    int iThisCur;        /* Cursor for this UNIQUE index */
+    int addrUniqueOk;    /* Jump here if the UNIQUE constraint is satisfied */
+    int addrConflictCk;  /* First opcode in the conflict check logic */
 
     if( aRegIdx[ix]==0 ) continue;  /* Skip indices that do not change */
     if( pUpsert ){
@@ -127141,7 +127139,7 @@
     regIdx = aRegIdx[ix]+1;
     for(i=0; i<pIdx->nColumn; i++){
       int iField = pIdx->aiColumn[i];
-      int x = 0;
+      int x;
       if( iField==XN_EXPR ){
         pParse->iSelfTab = -(regNewData+1);
         sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);
@@ -127241,7 +127239,7 @@
           VdbeCoverage(v);
         }
       }else{
-        int x = 0;
+        int x;
         /* Extract the PRIMARY KEY from the end of the index entry and
         ** store it in registers regR..regR+nPk-1 */
         if( pIdx!=pPk ){
@@ -127310,7 +127308,7 @@
         break;
       }
       default: {
-        int nConflictCk = 0;   /* Number of opcodes in conflict check logic */
+        int nConflictCk;   /* Number of opcodes in conflict check logic */
 
         assert( onError==OE_Replace );
         nConflictCk = sqlite3VdbeCurrentAddr(v) - addrConflictCk;
@@ -127331,7 +127329,7 @@
           sqlite3VdbeAddOp1(v, OP_CursorUnlock, iDataCur);
         }
         if( regTrigCnt ){
-          int addrBypass = 0;  /* Jump destination to bypass recheck logic */
+          int addrBypass;  /* Jump destination to bypass recheck logic */
 
           sqlite3VdbeAddOp2(v, OP_AddImm, regTrigCnt, 1); /* incr trigger cnt */
           addrBypass = sqlite3VdbeAddOp0(v, OP_Goto);  /* Bypass recheck */
@@ -127358,8 +127356,8 @@
             ** a pointer to the opcode. */
             x = *sqlite3VdbeGetOp(v, addrConflictCk);
             if( x.opcode!=OP_IdxRowid ){
-              int p2 = 0;      /* New P2 value for copied conflict check opcode */
-              const char *zP4 = NULL;
+              int p2;      /* New P2 value for copied conflict check opcode */
+              const char *zP4;
               if( sqlite3OpcodeProperty[x.opcode]&OPFLG_JUMP ){
                 p2 = lblRecheckOk;
               }else{
@@ -127504,10 +127502,10 @@
   int appendBias,     /* True if this is likely to be an append */
   int useSeekResult   /* True to set the USESEEKRESULT flag on OP_[Idx]Insert */
 ){
-  Vdbe *v = NULL;            /* Prepared statements under construction */
-  Index *pIdx = NULL;        /* An index being inserted or updated */
-  u8 pik_flags = 0;       /* flag values passed to the btree insert */
-  int i = 0;              /* Loop counter */
+  Vdbe *v;            /* Prepared statements under construction */
+  Index *pIdx;        /* An index being inserted or updated */
+  u8 pik_flags;       /* flag values passed to the btree insert */
+  int i;              /* Loop counter */
 
   assert( update_flags==0
        || update_flags==OPFLAG_ISUPDATE
@@ -127591,11 +127589,11 @@
   int *piDataCur,  /* Write the database source cursor number here */
   int *piIdxCur    /* Write the first index cursor number here */
 ){
-  int i = 0;
-  int iDb = 0;
-  int iDataCur = 0;
-  Index *pIdx = NULL;
-  Vdbe *v = NULL;
+  int i;
+  int iDb;
+  int iDataCur;
+  Index *pIdx;
+  Vdbe *v;
 
   assert( op==OP_OpenRead || op==OP_OpenWrite );
   assert( op==OP_OpenWrite || p5==0 );
@@ -127661,7 +127659,7 @@
 **    *   The index has the exact same WHERE clause
 */
 static int xferCompatibleIndex(Index *pDest, Index *pSrc){
-  int i = 0;
+  int i;
   assert( pDest && pSrc );
   assert( pDest->pTable!=pSrc->pTable );
   if( pDest->nKeyCol!=pSrc->nKeyCol || pDest->nColumn!=pSrc->nColumn ){
@@ -127729,20 +127727,20 @@
   int iDbDest           /* The database of pDest */
 ){
   sqlite3 *db = pParse->db;
-  ExprList *pEList = NULL;                /* The result set of the SELECT */
-  Table *pSrc = NULL;                     /* The table in the FROM clause of SELECT */
-  Index *pSrcIdx = NULL, *pDestIdx = NULL;       /* Source and destination indices */
-  SrcItem *pItem = NULL;                  /* An element of pSelect->pSrc */
-  int i = 0;                           /* Loop counter */
-  int iDbSrc = 0;                      /* The database of pSrc */
-  int iSrc = 0, iDest = 0;                 /* Cursors from source and destination */
-  int addr1 = 0, addr2 = 0;                /* Loop addresses */
+  ExprList *pEList;                /* The result set of the SELECT */
+  Table *pSrc;                     /* The table in the FROM clause of SELECT */
+  Index *pSrcIdx, *pDestIdx;       /* Source and destination indices */
+  SrcItem *pItem;                  /* An element of pSelect->pSrc */
+  int i;                           /* Loop counter */
+  int iDbSrc;                      /* The database of pSrc */
+  int iSrc, iDest;                 /* Cursors from source and destination */
+  int addr1, addr2;                /* Loop addresses */
   int emptyDestTest = 0;           /* Address of test for empty pDest */
   int emptySrcTest = 0;            /* Address of test for empty pSrc */
-  Vdbe *v = NULL;                         /* The VDBE we are building */
-  int regAutoinc = 0;                  /* Memory register used by AUTOINC */
+  Vdbe *v;                         /* The VDBE we are building */
+  int regAutoinc;                  /* Memory register used by AUTOINC */
   int destHasUniqueIdx = 0;        /* True if pDest has a UNIQUE index */
-  int regData = 0, regRowid = 0;           /* Registers holding data and rowid */
+  int regData, regRowid;           /* Registers holding data and rowid */
 
   assert( pSelect!=0 );
   if( pParse->pWith || pSelect->pWith ){
@@ -127981,7 +127979,7 @@
     sqlite3VdbeJumpHere(v, addr1);
   }
   if( HasRowid(pSrc) ){
-    u8 insFlags = 0;
+    u8 insFlags;
     sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, OP_OpenRead);
     emptySrcTest = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);
     if( pDest->iPKey>=0 ){
@@ -128140,10 +128138,10 @@
   char **pzErrMsg             /* Write error messages here */
 ){
   int rc = SQLITE_OK;         /* Return code */
-  const char *zLeftover = NULL;      /* Tail of unprocessed SQL */
+  const char *zLeftover;      /* Tail of unprocessed SQL */
   sqlite3_stmt *pStmt = 0;    /* The current SQL statement */
   char **azCols = 0;          /* Names of result columns */
-  int callbackIsInit = 0;         /* True if callback data is initialized */
+  int callbackIsInit;         /* True if callback data is initialized */
 
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
   if( zSql==0 ) zSql = "";
@@ -128168,7 +128166,7 @@
     callbackIsInit = 0;
 
     while( 1 ){
-      int i = 0;
+      int i;
       rc = sqlite3_step(pStmt);
 
       /* Invoke the callback function if required */
@@ -129463,15 +129461,15 @@
   char **pzErrMsg       /* Put error message here if not 0 */
 ){
   sqlite3_vfs *pVfs = db->pVfs;
-  void *handle = NULL;
-  sqlite3_loadext_entry xInit = 0;
+  void *handle;
+  sqlite3_loadext_entry xInit;
   char *zErrmsg = 0;
-  const char *zEntry = NULL;
+  const char *zEntry;
   char *zAltEntry = 0;
-  void **aHandle = NULL;
+  void **aHandle;
   u64 nMsg = strlen(zFile);
-  int ii = 0;
-  int rc = 0;
+  int ii;
+  int rc;
 
   /* Shared library endings to try if zFile cannot be loaded as written */
   static const char *azEndings[] = {
@@ -129533,7 +129531,7 @@
   **    C:/lib/mathfuncs.dll              ==>  sqlite3_mathfuncs_init
   */
   if( xInit==0 && zProc==0 ){
-    int iFile = 0, iEntry = 0, c = 0;
+    int iFile, iEntry, c;
     int ncFile = sqlite3Strlen30(zFile);
     zAltEntry = sqlite3_malloc64(ncFile+30);
     if( zAltEntry==0 ){
@@ -129613,7 +129611,7 @@
   const char *zProc,    /* Entry point.  Use "sqlite3_extension_init" if 0 */
   char **pzErrMsg       /* Put error message here if not 0 */
 ){
-  int rc = 0;
+  int rc;
   sqlite3_mutex_enter(db->mutex);
   rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);
   rc = sqlite3ApiExit(db, rc);
@@ -129626,7 +129624,7 @@
 ** to clean up loaded extensions
 */
 SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db){
-  int i = 0;
+  int i;
   assert( sqlite3_mutex_held(db->mutex) );
   for(i=0; i<db->nExtension; i++){
     sqlite3OsDlClose(db->pVfs, db->aExtension[i]);
@@ -129695,7 +129693,7 @@
   }else
 #endif
   {
-    u32 i = 0;
+    u32 i;
 #if SQLITE_THREADSAFE
     sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
 #endif
@@ -129706,7 +129704,7 @@
     }
     if( i==wsdAutoext.nExt ){
       u64 nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);
-      void (**aNew = 0)(void);
+      void (**aNew)(void);
       aNew = sqlite3_realloc64(wsdAutoext.aExt, nByte);
       if( aNew==0 ){
         rc = SQLITE_NOMEM_BKPT;
@@ -129737,7 +129735,7 @@
 #if SQLITE_THREADSAFE
   sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
 #endif
-  int i = 0;
+  int i;
   int n = 0;
   wsdAutoextInit;
   sqlite3_mutex_enter(mutex);
@@ -129779,10 +129777,10 @@
 ** If anything goes wrong, set an error in the database connection.
 */
 SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3 *db){
-  u32 i = 0;
+  u32 i;
   int go = 1;
-  int rc = 0;
-  sqlite3_loadext_entry xInit = 0;
+  int rc;
+  sqlite3_loadext_entry xInit;
 
   wsdAutoextInit;
   if( wsdAutoext.nExt==0 ){
@@ -129790,7 +129788,7 @@
     return;
   }
   for(i=0; go; i++){
-    char *zErrmsg = NULL;
+    char *zErrmsg;
 #if SQLITE_THREADSAFE
     sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
 #endif
@@ -130533,7 +130531,7 @@
   static const u8 iLength[] = {2, 2, 3,  5,    3,   4,   5,    4};
   static const u8 iValue[] =  {1, 0, 0,  0,    1,   1,   3,    2};
                             /* on no off false yes true extra full */
-  int i = 0, n = 0;
+  int i, n;
   if( sqlite3Isdigit(*z) ){
     return (u8)sqlite3Atoi(z);
   }
@@ -130580,7 +130578,7 @@
 ** acceptable, as are their numeric equivalents: 0, 1 and 2 respectively.
 */
 static int getAutoVacuum(const char *z){
-  int i = 0;
+  int i;
   if( 0==sqlite3StrICmp(z, "none") ) return BTREE_AUTOVACUUM_NONE;
   if( 0==sqlite3StrICmp(z, "full") ) return BTREE_AUTOVACUUM_FULL;
   if( 0==sqlite3StrICmp(z, "incremental") ) return BTREE_AUTOVACUUM_INCR;
@@ -130661,7 +130659,7 @@
   if( n==0 ){
     sqlite3VdbeSetColName(v, 0, COLNAME_NAME, pPragma->zName, SQLITE_STATIC);
   }else{
-    int i = 0, j = 0;
+    int i, j;
     for(i=0, j=pPragma->iPragCName; i<n; i++, j++){
       sqlite3VdbeSetColName(v, i, COLNAME_NAME, pragCName[j], SQLITE_STATIC);
     }
@@ -130724,7 +130722,7 @@
 */
 #ifndef SQLITE_OMIT_FOREIGN_KEY
 static const char *actionName(u8 action){
-  const char *zName = NULL;
+  const char *zName;
   switch( action ){
     case OE_SetNull:  zName = "SET NULL";        break;
     case OE_SetDflt:  zName = "SET DEFAULT";     break;
@@ -130766,7 +130764,7 @@
 ** Locate a pragma in the aPragmaName[] array.
 */
 static const PragmaName *pragmaLocate(const char *zName){
-  int upr = 0, lwr = 0, mid = 0, rc;
+  int upr, lwr, mid = 0, rc;
   lwr = 0;
   upr = ArraySize(aPragmaName)-1;
   while( lwr<=upr ){
@@ -130793,7 +130791,7 @@
   int showInternFuncs    /* True if showing internal functions */
 ){
   for(; p; p=p->pNext){
-    const char *zType = NULL;
+    const char *zType;
     static const u32 mask =
         SQLITE_DETERMINISTIC |
         SQLITE_DIRECTONLY |
@@ -130839,7 +130837,7 @@
 ** and halt if the maximum number of result rows have been issued.
 */
 static int integrityCheckResultRow(Vdbe *v){
-  int addr = 0;
+  int addr;
   sqlite3VdbeAddOp2(v, OP_ResultRow, 3, 1);
   addr = sqlite3VdbeAddOp3(v, OP_IfPos, 1, sqlite3VdbeCurrentAddr(v)+2, 1);
   VdbeCoverage(v);
@@ -130872,14 +130870,14 @@
   char *zLeft = 0;       /* Nul-terminated UTF-8 string <id> */
   char *zRight = 0;      /* Nul-terminated UTF-8 string <value>, or NULL */
   const char *zDb = 0;   /* The database name */
-  Token *pId = NULL;            /* Pointer to <id> token */
+  Token *pId;            /* Pointer to <id> token */
   char *aFcntl[4];       /* Argument to SQLITE_FCNTL_PRAGMA */
-  int iDb = 0;               /* Database index for <database> */
-  int rc = 0;                      /* return value form SQLITE_FCNTL_PRAGMA */
+  int iDb;               /* Database index for <database> */
+  int rc;                      /* return value form SQLITE_FCNTL_PRAGMA */
   sqlite3 *db = pParse->db;    /* The database connection */
-  Db *pDb = NULL;                     /* The specific database being pragmaed */
+  Db *pDb;                     /* The specific database being pragmaed */
   Vdbe *v = sqlite3GetVdbe(pParse);  /* Prepared statement */
-  const PragmaName *pPragma = NULL;   /* The pragma */
+  const PragmaName *pPragma;   /* The pragma */
 
   if( v==0 ) return;
   sqlite3VdbeRunOnlyOnce(v);
@@ -131003,7 +131001,7 @@
       { OP_Noop,        0, 0,        0},
       { OP_ResultRow,   1, 1,        0},
     };
-    VdbeOp *aOp = NULL;
+    VdbeOp *aOp;
     sqlite3VdbeUsesBtree(v, iDb);
     if( !zRight ){
       pParse->nMem += 2;
@@ -131073,7 +131071,7 @@
       }
     }
     if( pId2->n==0 && b>=0 ){
-      int ii = 0;
+      int ii;
       for(ii=0; ii<db->nDb; ii++){
         sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);
       }
@@ -131101,7 +131099,7 @@
   ** Return the number of pages in the specified database.
   */
   case PragTyp_PAGE_COUNT: {
-    int iReg = 0;
+    int iReg;
     i64 x = 0;
     sqlite3CodeVerifySchema(pParse, iDb);
     iReg = ++pParse->nMem;
@@ -131135,7 +131133,7 @@
       */
       eMode = db->dfltLockMode;
     }else{
-      Pager *pPager = NULL;
+      Pager *pPager;
       if( pId2->n==0 ){
         /* This indicates that no database name was specified as part
         ** of the PRAGMA command. In this case the locking-mode must be
@@ -131145,7 +131143,7 @@
         ** any subsequently attached databases also use the specified
         ** locking mode.
         */
-        int ii = 0;
+        int ii;
         assert(pDb==&db->aDb[0]);
         for(ii=2; ii<db->nDb; ii++){
           pPager = sqlite3BtreePager(db->aDb[ii].pBt);
@@ -131172,15 +131170,15 @@
   **                      (delete|persist|off|truncate|memory|wal|off)
   */
   case PragTyp_JOURNAL_MODE: {
-    int eMode = 0;        /* One of the PAGER_JOURNALMODE_XXX symbols */
-    int ii = 0;           /* Loop counter */
+    int eMode;        /* One of the PAGER_JOURNALMODE_XXX symbols */
+    int ii;           /* Loop counter */
 
     if( zRight==0 ){
       /* If there is no "=MODE" part of the pragma, do a query for the
       ** current mode */
       eMode = PAGER_JOURNALMODE_QUERY;
     }else{
-      const char *zMode = NULL;
+      const char *zMode;
       int n = sqlite3Strlen30(zRight);
       for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){
         if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;
@@ -131268,7 +131266,7 @@
           { OP_Halt,           SQLITE_OK, OE_Abort,          0},    /* 3 */
           { OP_SetCookie,      0,         BTREE_INCR_VACUUM, 0},    /* 4 */
         };
-        VdbeOp *aOp = NULL;
+        VdbeOp *aOp;
         int iAddr = sqlite3VdbeCurrentAddr(v);
         sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));
         aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);
@@ -131292,7 +131290,7 @@
   */
 #ifndef SQLITE_OMIT_AUTOVACUUM
   case PragTyp_INCREMENTAL_VACUUM: {
-    int iLimit = 0, addr = 0;
+    int iLimit, addr;
     if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){
       iLimit = 0x7fffffff;
     }
@@ -131389,11 +131387,11 @@
   ** upper layers will never invoke the xFetch interfaces to the VFS.
   */
   case PragTyp_MMAP_SIZE: {
-    sqlite3_int64 sz = 0;
+    sqlite3_int64 sz;
 #if SQLITE_MAX_MMAP_SIZE>0
     assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
     if( zRight ){
-      int ii = 0;
+      int ii;
       sqlite3DecOrHexToI64(zRight, &sz);
       if( sz<0 ) sz = sqlite3GlobalConfig.szMmap;
       if( pId2->n==0 ) db->szMmap = sz;
@@ -131454,7 +131452,7 @@
     }else{
 #ifndef SQLITE_OMIT_WSD
       if( zRight[0] ){
-        int res = 0;
+        int res;
         rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);
         if( rc!=SQLITE_OK || res==0 ){
           sqlite3ErrorMsg(pParse, "not a writable directory");
@@ -131642,19 +131640,19 @@
   ** pk:         Non-zero for PK fields.
   */
   case PragTyp_TABLE_INFO: if( zRight ){
-    Table *pTab = NULL;
+    Table *pTab;
     sqlite3CodeVerifyNamedSchema(pParse, zDb);
     pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);
     if( pTab ){
-      int i = 0, k = 0;
+      int i, k;
       int nHidden = 0;
-      Column *pCol = NULL;
+      Column *pCol;
       Index *pPk = sqlite3PrimaryKeyIndex(pTab);
       pParse->nMem = 7;
       sqlite3ViewGetColumnNames(pParse, pTab);
       for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
         int isHidden = 0;
-        const Expr *pColExpr = NULL;
+        const Expr *pColExpr;
         if( pCol->colFlags & COLFLAG_NOINSERT ){
           if( pPragma->iArg==0 ){
             nHidden++;
@@ -131706,13 +131704,13 @@
   ** strict:     True for a STRICT table
   */
   case PragTyp_TABLE_LIST: {
-    int ii = 0;
+    int ii;
     pParse->nMem = 6;
     sqlite3CodeVerifyNamedSchema(pParse, zDb);
     for(ii=0; ii<db->nDb; ii++){
-      HashElem *k = NULL;
-      Hash *pHash = NULL;
-      int initNCol = 0;
+      HashElem *k;
+      Hash *pHash;
+      int initNCol;
       if( zDb && sqlite3_stricmp(zDb, db->aDb[ii].zDbSName)!=0 ) continue;
 
       /* Ensure that the Table.nCol field is initialized for all views
@@ -131724,7 +131722,7 @@
       initNCol = sqliteHashCount(pHash);
       while( initNCol-- ){
         for(k=sqliteHashFirst(pHash); 1; k=sqliteHashNext(k) ){
-          Table *pTab = NULL;
+          Table *pTab;
           if( k==0 ){ initNCol = 0; break; }
           pTab = sqliteHashData(k);
           if( pTab->nCol==0 ){
@@ -131747,7 +131745,7 @@
 
       for(k=sqliteHashFirst(pHash); k; k=sqliteHashNext(k) ){
         Table *pTab = sqliteHashData(k);
-        const char *zType = NULL;
+        const char *zType;
         if( zRight && sqlite3_stricmp(zRight, pTab->zName)!=0 ) continue;
         if( IsView(pTab) ){
           zType = "view";
@@ -131799,8 +131797,8 @@
 #endif
 
   case PragTyp_INDEX_INFO: if( zRight ){
-    Index *pIdx = NULL;
-    Table *pTab = NULL;
+    Index *pIdx;
+    Table *pTab;
     pIdx = sqlite3FindIndex(db, zRight, zDb);
     if( pIdx==0 ){
       /* If there is no index named zRight, check to see if there is a
@@ -131813,8 +131811,8 @@
     }
     if( pIdx ){
       int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);
-      int i = 0;
-      int mx = 0;
+      int i;
+      int mx;
       if( pPragma->iArg ){
         /* PRAGMA index_xinfo (newer version with more rows and columns) */
         mx = pIdx->nColumn;
@@ -131844,9 +131842,9 @@
   break;
 
   case PragTyp_INDEX_LIST: if( zRight ){
-    Index *pIdx = NULL;
-    Table *pTab = NULL;
-    int i = 0;
+    Index *pIdx;
+    Table *pTab;
+    int i;
     pTab = sqlite3FindTable(db, zRight, zDb);
     if( pTab ){
       int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
@@ -131866,7 +131864,7 @@
   break;
 
   case PragTyp_DATABASE_LIST: {
-    int i = 0;
+    int i;
     pParse->nMem = 3;
     for(i=0; i<db->nDb; i++){
       if( db->aDb[i].pBt==0 ) continue;
@@ -131881,7 +131879,7 @@
 
   case PragTyp_COLLATION_LIST: {
     int i = 0;
-    HashElem *p = NULL;
+    HashElem *p;
     pParse->nMem = 2;
     for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){
       CollSeq *pColl = (CollSeq *)sqliteHashData(p);
@@ -131892,9 +131890,9 @@
 
 #ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS
   case PragTyp_FUNCTION_LIST: {
-    int i = 0;
-    HashElem *j = NULL;
-    FuncDef *p = NULL;
+    int i;
+    HashElem *j;
+    FuncDef *p;
     int showInternFunc = (db->mDbFlags & DBFLAG_InternalFunc)!=0;
     pParse->nMem = 6;
     for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){
@@ -131913,7 +131911,7 @@
 
 #ifndef SQLITE_OMIT_VIRTUALTABLE
   case PragTyp_MODULE_LIST: {
-    HashElem *j = NULL;
+    HashElem *j;
     pParse->nMem = 1;
     for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){
       Module *pMod = (Module*)sqliteHashData(j);
@@ -131924,7 +131922,7 @@
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
 
   case PragTyp_PRAGMA_LIST: {
-    int i = 0;
+    int i;
     for(i=0; i<ArraySize(aPragmaName); i++){
       sqlite3VdbeMultiLoad(v, 1, "s", aPragmaName[i].zName);
     }
@@ -131936,8 +131934,8 @@
 
 #ifndef SQLITE_OMIT_FOREIGN_KEY
   case PragTyp_FOREIGN_KEY_LIST: if( zRight ){
-    FKey *pFK = NULL;
-    Table *pTab = NULL;
+    FKey *pFK;
+    Table *pTab;
     pTab = sqlite3FindTable(db, zRight, zDb);
     if( pTab && IsOrdinaryTable(pTab) ){
       pFK = pTab->u.tab.pFKey;
@@ -131947,7 +131945,7 @@
         pParse->nMem = 8;
         sqlite3CodeVerifySchema(pParse, iTabDb);
         while(pFK){
-          int j = 0;
+          int j;
           for(j=0; j<pFK->nCol; j++){
             sqlite3VdbeMultiLoad(v, 1, "iissssss",
                    i,
@@ -131971,20 +131969,20 @@
 #ifndef SQLITE_OMIT_FOREIGN_KEY
 #ifndef SQLITE_OMIT_TRIGGER
   case PragTyp_FOREIGN_KEY_CHECK: {
-    FKey *pFK = NULL;             /* A foreign key constraint */
-    Table *pTab = NULL;           /* Child table contain "REFERENCES" keyword */
-    Table *pParent = NULL;        /* Parent table that child points to */
-    Index *pIdx = NULL;           /* Index in the parent table */
-    int i = 0;                 /* Loop counter:  Foreign key number for pTab */
-    int j = 0;                 /* Loop counter:  Field of the foreign key */
-    HashElem *k = NULL;           /* Loop counter:  Next table in schema */
-    int x = 0;                 /* result variable */
-    int regResult = 0;         /* 3 registers to hold a result row */
-    int regKey = 0;            /* Register to hold key for checking the FK */
-    int regRow = 0;            /* Registers to hold a row from pTab */
-    int addrTop = 0;           /* Top of a loop checking foreign keys */
-    int addrOk = 0;            /* Jump here if the key is OK */
-    int *aiCols = NULL;           /* child to parent column mapping */
+    FKey *pFK;             /* A foreign key constraint */
+    Table *pTab;           /* Child table contain "REFERENCES" keyword */
+    Table *pParent;        /* Parent table that child points to */
+    Index *pIdx;           /* Index in the parent table */
+    int i;                 /* Loop counter:  Foreign key number for pTab */
+    int j;                 /* Loop counter:  Field of the foreign key */
+    HashElem *k;           /* Loop counter:  Next table in schema */
+    int x;                 /* result variable */
+    int regResult;         /* 3 registers to hold a result row */
+    int regKey;            /* Register to hold key for checking the FK */
+    int regRow;            /* Registers to hold a row from pTab */
+    int addrTop;           /* Top of a loop checking foreign keys */
+    int addrOk;            /* Jump here if the key is OK */
+    int *aiCols;           /* child to parent column mapping */
 
     regResult = pParse->nMem+1;
     pParse->nMem += 4;
@@ -132127,7 +132125,7 @@
   **      PRAGMA schema.integrity_check;
   */
   case PragTyp_INTEGRITY_CHECK: {
-    int i = 0, j = 0, addr = 0, mxErr = 0;
+    int i, j, addr, mxErr;
     Table *pObjTab = 0;     /* Check only this one table, if not NULL */
 
     int isQuick = (sqlite3Tolower(zLeft[0])=='q');
@@ -132164,9 +132162,9 @@
 
     /* Do an integrity check on each database file */
     for(i=0; i<db->nDb; i++){
-      HashElem *x = NULL;     /* For looping over tables in the schema */
-      Hash *pTbls = NULL;     /* Set of all tables in the schema */
-      int *aRoot = NULL;      /* Array of root page numbers of all btrees */
+      HashElem *x;     /* For looping over tables in the schema */
+      Hash *pTbls;     /* Set of all tables in the schema */
+      int *aRoot;      /* Array of root page numbers of all btrees */
       int cnt = 0;     /* Number of entries in aRoot[] */
       int mxIdx = 0;   /* Maximum number of indexes for any table */
 
@@ -132184,8 +132182,8 @@
       pTbls = &db->aDb[i].pSchema->tblHash;
       for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){
         Table *pTab = sqliteHashData(x);  /* Current table */
-        Index *pIdx = NULL;                      /* An index on pTab */
-        int nIdx = 0;                         /* Number of indexes on pTab */
+        Index *pIdx;                      /* An index on pTab */
+        int nIdx;                         /* Number of indexes on pTab */
         if( pObjTab && pObjTab!=pTab ) continue;
         if( HasRowid(pTab) ) cnt++;
         for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }
@@ -132199,7 +132197,7 @@
       if( pObjTab ) aRoot[++cnt] = 0;
       for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){
         Table *pTab = sqliteHashData(x);
-        Index *pIdx = NULL;
+        Index *pIdx;
         if( pObjTab && pObjTab!=pTab ) continue;
         if( HasRowid(pTab) ) aRoot[++cnt] = pTab->tnum;
         for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
@@ -132227,12 +132225,12 @@
       */
       for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){
         Table *pTab = sqliteHashData(x);
-        Index *pIdx = NULL, *pPk = NULL;
+        Index *pIdx, *pPk;
         Index *pPrior = 0;
-        int loopTop = 0;
-        int iDataCur = 0, iIdxCur = 0;
+        int loopTop;
+        int iDataCur, iIdxCur;
         int r1 = -1;
-        int bStrict = 0;
+        int bStrict;
 
         if( !IsOrdinaryTable(pTab) ) continue;
         if( pObjTab && pObjTab!=pTab ) continue;
@@ -132260,9 +132258,9 @@
         ** same time verify the type of the content of STRICT tables */
         bStrict = (pTab->tabFlags & TF_Strict)!=0;
         for(j=0; j<pTab->nCol; j++){
-          char *zErr = NULL;
+          char *zErr;
           Column *pCol = pTab->aCol + j;
-          int doError = 0, jmp2 = 0;
+          int doError, jmp2;
           if( j==pTab->iPKey ) continue;
           if( pCol->notNull==0 && !bStrict ) continue;
           doError = bStrict ? sqlite3VdbeMakeLabel(pParse) : 0;
@@ -132303,8 +132301,8 @@
           if( db->mallocFailed==0 ){
             int addrCkFault = sqlite3VdbeMakeLabel(pParse);
             int addrCkOk = sqlite3VdbeMakeLabel(pParse);
-            char *zErr = NULL;
-            int k = 0;
+            char *zErr;
+            int k;
             pParse->iSelfTab = iDataCur + 1;
             for(k=pCheck->nExpr-1; k>0; k--){
               sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);
@@ -132324,7 +132322,7 @@
         if( !isQuick ){ /* Omit the remaining tests for quick_check */
           /* Validate index entries for the current row */
           for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
-            int jmp2 = 0, jmp3 = 0, jmp4 = 0, jmp5 = 0;
+            int jmp2, jmp3, jmp4, jmp5;
             int ckUniq = sqlite3VdbeMakeLabel(pParse);
             if( pPk==pIdx ) continue;
             r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,
@@ -132347,8 +132345,8 @@
             ** or (2) the next entry has a different key */
             if( IsUniqueIndex(pIdx) ){
               int uniqOk = sqlite3VdbeMakeLabel(pParse);
-              int jmp6 = 0;
-              int kk = 0;
+              int jmp6;
+              int kk;
               for(kk=0; kk<pIdx->nKeyCol; kk++){
                 int iCol = pIdx->aiColumn[kk];
                 assert( iCol!=XN_ROWID && iCol<pTab->nCol );
@@ -132397,7 +132395,7 @@
         { OP_String8,     0, 3,        0},    /* 5 */
         { OP_Goto,        0, 3,        0},    /* 6 */
       };
-      VdbeOp *aOp = NULL;
+      VdbeOp *aOp;
 
       aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);
       if( aOp ){
@@ -132451,7 +132449,7 @@
       { "UTF16",    0                  }, /* SQLITE_UTF16NATIVE */
       { 0, 0 }
     };
-    const struct EncName *pEnc = NULL;
+    const struct EncName *pEnc;
     if( !zRight ){    /* "PRAGMA encoding" */
       if( sqlite3ReadSchema(pParse) ) goto pragma_out;
       assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );
@@ -132524,7 +132522,7 @@
         { OP_Transaction,    0,  1,  0},    /* 0 */
         { OP_SetCookie,      0,  0,  0},    /* 1 */
       };
-      VdbeOp *aOp = NULL;
+      VdbeOp *aOp;
       sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));
       aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);
       if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;
@@ -132540,7 +132538,7 @@
         { OP_ReadCookie,      0,  1,  0},    /* 1 */
         { OP_ResultRow,       1,  1,  0}
       };
-      VdbeOp *aOp = NULL;
+      VdbeOp *aOp;
       sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));
       aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie),readCookie,0);
       if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;
@@ -132562,7 +132560,7 @@
   */
   case PragTyp_COMPILE_OPTIONS: {
     int i = 0;
-    const char *zOpt = NULL;
+    const char *zOpt;
     pParse->nMem = 1;
     while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){
       sqlite3VdbeLoadString(v, 1, zOpt);
@@ -132683,15 +132681,15 @@
   ** future releases.
   */
   case PragTyp_OPTIMIZE: {
-    int iDbLast = 0;           /* Loop termination point for the schema loop */
-    int iTabCur = 0;           /* Cursor for a table whose size needs checking */
-    HashElem *k = NULL;           /* Loop over tables of a schema */
-    Schema *pSchema = NULL;       /* The current schema */
-    Table *pTab = NULL;           /* A table in the schema */
-    Index *pIdx = NULL;           /* An index of the table */
-    LogEst szThreshold = 0;    /* Size threshold above which reanalysis is needd */
-    char *zSubSql = NULL;         /* SQL statement for the OP_SqlExec opcode */
-    u32 opMask = 0;            /* Mask of operations to perform */
+    int iDbLast;           /* Loop termination point for the schema loop */
+    int iTabCur;           /* Cursor for a table whose size needs checking */
+    HashElem *k;           /* Loop over tables of a schema */
+    Schema *pSchema;       /* The current schema */
+    Table *pTab;           /* A table in the schema */
+    Index *pIdx;           /* An index of the table */
+    LogEst szThreshold;    /* Size threshold above which reanalysis is needd */
+    char *zSubSql;         /* SQL statement for the OP_SqlExec opcode */
+    u32 opMask;            /* Mask of operations to perform */
 
     if( zRight ){
       opMask = (u32)sqlite3Atoi(zRight);
@@ -132771,7 +132769,7 @@
   ** sqlite3_soft_heap_limit64(-1) C-language function.
   */
   case PragTyp_SOFT_HEAP_LIMIT: {
-    sqlite3_int64 N = 0;
+    sqlite3_int64 N;
     if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){
       sqlite3_soft_heap_limit64(N);
     }
@@ -132791,7 +132789,7 @@
   ** constraint that cannot be relaxed by an untrusted SQL script.
   */
   case PragTyp_HARD_HEAP_LIMIT: {
-    sqlite3_int64 N = 0;
+    sqlite3_int64 N;
     if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){
       sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);
       if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);
@@ -132808,7 +132806,7 @@
   ** maximum, which might be less than requested.
   */
   case PragTyp_THREADS: {
-    sqlite3_int64 N = 0;
+    sqlite3_int64 N;
     if( zRight
      && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK
      && N>=0
@@ -132827,7 +132825,7 @@
   ** in each index that it looks at.  Return the new limit.
   */
   case PragTyp_ANALYSIS_LIMIT: {
-    sqlite3_int64 N = 0;
+    sqlite3_int64 N;
     if( zRight
      && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK /* IMP: R-40975-20399 */
      && N>=0
@@ -132923,8 +132921,8 @@
 ){
   const PragmaName *pPragma = (const PragmaName*)pAux;
   PragmaVtab *pTab = 0;
-  int rc = 0;
-  int i = 0, j = 0;
+  int rc;
+  int i, j;
   char cSep = '(';
   StrAccum acc;
   char zBuf[200];
@@ -132991,8 +132989,8 @@
 */
 static int pragmaVtabBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
   PragmaVtab *pTab = (PragmaVtab*)tab;
-  const struct sqlite3_index_constraint *pConstraint = NULL;
-  int i = 0, j = 0;
+  const struct sqlite3_index_constraint *pConstraint;
+  int i, j;
   int seen[2];
 
   pIdxInfo->estimatedCost = (double)1;
@@ -133027,7 +133025,7 @@
 
 /* Create a new cursor for the pragma virtual table */
 static int pragmaVtabOpen(sqlite3_vtab *pVtab, sqlite3_vtab_cursor **ppCursor){
-  PragmaVtabCursor *pCsr = NULL;
+  PragmaVtabCursor *pCsr;
   pCsr = (PragmaVtabCursor*)sqlite3_malloc(sizeof(*pCsr));
   if( pCsr==0 ) return SQLITE_NOMEM;
   memset(pCsr, 0, sizeof(PragmaVtabCursor));
@@ -133038,7 +133036,7 @@
 
 /* Clear all content from pragma virtual table cursor. */
 static void pragmaVtabCursorClear(PragmaVtabCursor *pCsr){
-  int i = 0;
+  int i;
   sqlite3_finalize(pCsr->pPragma);
   pCsr->pPragma = 0;
   for(i=0; i<ArraySize(pCsr->azArg); i++){
@@ -133081,10 +133079,10 @@
 ){
   PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
   PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);
-  int rc = 0;
-  int i = 0, j = 0;
+  int rc;
+  int i, j;
   StrAccum acc;
-  char *zSql = NULL;
+  char *zSql;
 
   UNUSED_PARAMETER(idxNum);
   UNUSED_PARAMETER(idxStr);
@@ -133190,7 +133188,7 @@
 ** a pointer to the Module object for the new virtual table.
 */
 SQLITE_PRIVATE Module *sqlite3PragmaVtabRegister(sqlite3 *db, const char *zName){
-  const PragmaName *pName = NULL;
+  const PragmaName *pName;
   assert( sqlite3_strnicmp(zName, "pragma_", 7)==0 );
   pName = pragmaLocate(zName+7);
   if( pName==0 ) return 0;
@@ -133251,7 +133249,7 @@
   }else if( db->flags & SQLITE_WriteSchema ){
     pData->rc = SQLITE_CORRUPT_BKPT;
   }else{
-    char *z = NULL;
+    char *z;
     const char *zObj = azObj[1] ? azObj[1] : "?";
     z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
     if( zExtra && zExtra[0] ) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
@@ -133266,7 +133264,7 @@
 ** This would indicate a corrupt schema.
 */
 SQLITE_PRIVATE int sqlite3IndexHasDuplicateRootPage(Index *pIndex){
-  Index *p = NULL;
+  Index *p;
   for(p=pIndex->pTable->pIndex; p; p=p->pNext){
     if( p->tnum==pIndex->tnum && p!=pIndex ) return 1;
   }
@@ -133331,9 +133329,9 @@
     ** any other kind of statement while parsing the schema, even a corrupt
     ** schema.
     */
-    int rc = 0;
+    int rc;
     u8 saved_iDb = db->init.iDb;
-    sqlite3_stmt *pStmt = NULL;
+    sqlite3_stmt *pStmt;
     TESTONLY(int rcp);            /* Return code from sqlite3_prepare() */
 
     assert( db->init.busy );
@@ -133376,7 +133374,7 @@
     ** been created when we processed the CREATE TABLE.  All we have
     ** to do here is record the root page number for that index.
     */
-    Index *pIndex = NULL;
+    Index *pIndex;
     pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);
     if( pIndex==0 ){
       corruptSchema(pData, argv, "orphan index");
@@ -133403,16 +133401,16 @@
 ** indicate success or failure.
 */
 SQLITE_PRIVATE int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg, u32 mFlags){
-  int rc = 0;
-  int i = 0;
+  int rc;
+  int i;
 #ifndef SQLITE_OMIT_DEPRECATED
-  int size = 0;
+  int size;
 #endif
-  Db *pDb = NULL;
+  Db *pDb;
   char const *azArg[6];
   int meta[5];
   InitData initData;
-  const char *zSchemaTabName = NULL;
+  const char *zSchemaTabName;
   int openedTransaction = 0;
   int mask = ((db->mDbFlags & DBFLAG_EncodingFixed) | ~DBFLAG_EncodingFixed);
 
@@ -133505,7 +133503,7 @@
   */
   if( meta[BTREE_TEXT_ENCODING-1] ){  /* text encoding */
     if( iDb==0 && (db->mDbFlags & DBFLAG_EncodingFixed)==0 ){
-      u8 encoding = 0;
+      u8 encoding;
 #ifndef SQLITE_OMIT_UTF16
       /* If opening the main database, set ENC(db). */
       encoding = (u8)meta[BTREE_TEXT_ENCODING-1] & 3;
@@ -133567,13 +133565,13 @@
   assert( db->init.busy );
   initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);
   {
-    char *zSql = NULL;
+    char *zSql;
     zSql = sqlite3MPrintf(db,
         "SELECT*FROM\"%w\".%s ORDER BY rowid",
         db->aDb[iDb].zDbSName, zSchemaTabName);
 #ifndef SQLITE_OMIT_AUTHORIZATION
     {
-      sqlite3_xauth xAuth = 0;
+      sqlite3_xauth xAuth;
       xAuth = db->xAuth;
       db->xAuth = 0;
 #endif
@@ -133642,7 +133640,7 @@
 ** bit is set in the flags field of the Db structure.
 */
 SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){
-  int i = 0, rc = 0;
+  int i, rc;
   int commit_internal = !(db->mDbFlags&DBFLAG_SchemaChange);
 
   assert( sqlite3_mutex_held(db->mutex) );
@@ -133697,9 +133695,9 @@
 */
 static void schemaIsValid(Parse *pParse){
   sqlite3 *db = pParse->db;
-  int iDb = 0;
-  int rc = 0;
-  int cookie = 0;
+  int iDb;
+  int rc;
+  int cookie;
 
   assert( pParse->checkSchema );
   assert( sqlite3_mutex_held(db->mutex) );
@@ -133883,7 +133881,7 @@
   const char **pzTail       /* OUT: End of parsed string */
 ){
   int rc = SQLITE_OK;       /* Result code */
-  int i = 0;                    /* Loop counter */
+  int i;                    /* Loop counter */
   Parse sParse;             /* Parsing context */
 
   /* sqlite3ParseObjectInit(&sParse, db); // inlined for performance */
@@ -133948,7 +133946,7 @@
   sqlite3VtabUnlockList(db);
 
   if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){
-    char *zSqlCopy = NULL;
+    char *zSqlCopy;
     int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];
     testcase( nBytes==mxLen );
     testcase( nBytes==mxLen+1 );
@@ -134025,7 +134023,7 @@
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const char **pzTail       /* OUT: End of parsed string */
 ){
-  int rc = 0;
+  int rc;
   int cnt = 0;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
@@ -134064,11 +134062,11 @@
 ** occurs, return SQLITE_SCHEMA.
 */
 SQLITE_PRIVATE int sqlite3Reprepare(Vdbe *p){
-  int rc = 0;
-  sqlite3_stmt *pNew = NULL;
-  const char *zSql = NULL;
-  sqlite3 *db = NULL;
-  u8 prepFlags = 0;
+  int rc;
+  sqlite3_stmt *pNew;
+  const char *zSql;
+  sqlite3 *db;
+  u8 prepFlags;
 
   assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) );
   zSql = sqlite3_sql((sqlite3_stmt *)p);
@@ -134109,7 +134107,7 @@
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const char **pzTail       /* OUT: End of parsed string */
 ){
-  int rc = 0;
+  int rc;
   rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);
   assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
   return rc;
@@ -134121,7 +134119,7 @@
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const char **pzTail       /* OUT: End of parsed string */
 ){
-  int rc = 0;
+  int rc;
   /* EVIDENCE-OF: R-37923-12173 The sqlite3_prepare_v2() interface works
   ** exactly the same as sqlite3_prepare_v3() with a zero prepFlags
   ** parameter.
@@ -134140,7 +134138,7 @@
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const char **pzTail       /* OUT: End of parsed string */
 ){
-  int rc = 0;
+  int rc;
   /* EVIDENCE-OF: R-56861-42673 sqlite3_prepare_v3() differs from
   ** sqlite3_prepare_v2() only in having the extra prepFlags parameter,
   ** which is a bit array consisting of zero or more of the
@@ -134172,7 +134170,7 @@
   ** encoded string to UTF-8, then invoking sqlite3_prepare(). The
   ** tricky bit is figuring out the pointer to return in *pzTail.
   */
-  char *zSql8 = NULL;
+  char *zSql8;
   const char *zTail8 = 0;
   int rc = SQLITE_OK;
 
@@ -134184,7 +134182,7 @@
     return SQLITE_MISUSE_BKPT;
   }
   if( nBytes>=0 ){
-    int sz = 0;
+    int sz;
     const char *z = (const char*)zSql;
     for(sz=0; sz<nBytes && (z[sz]!=0 || z[sz+1]!=0); sz += 2){}
     nBytes = sz;
@@ -134225,7 +134223,7 @@
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const void **pzTail       /* OUT: End of parsed string */
 ){
-  int rc = 0;
+  int rc;
   rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);
   assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
   return rc;
@@ -134237,7 +134235,7 @@
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const void **pzTail       /* OUT: End of parsed string */
 ){
-  int rc = 0;
+  int rc;
   rc = sqlite3Prepare16(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,ppStmt,pzTail);
   assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
   return rc;
@@ -134250,7 +134248,7 @@
   sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
   const void **pzTail       /* OUT: End of parsed string */
 ){
-  int rc = 0;
+  int rc;
   rc = sqlite3Prepare16(db,zSql,nBytes,
          SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),
          ppStmt,pzTail);
@@ -134393,7 +134391,7 @@
   u32 selFlags,         /* Flag parameters, such as SF_Distinct */
   Expr *pLimit          /* LIMIT value.  NULL means not used */
 ){
-  Select *pNew = NULL, *pAllocated = NULL;
+  Select *pNew, *pAllocated;
   Select standin;
   pAllocated = pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );
   if( pNew==0 ){
@@ -134472,7 +134470,7 @@
 SQLITE_PRIVATE int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){
   int jointype = 0;
   Token *apAll[3];
-  Token *p = NULL;
+  Token *p;
                              /*   0123456789 123456789 123456789 123 */
   static const char zKeyText[] = "naturaleftouterightfullinnercross";
   static const struct {
@@ -134488,7 +134486,7 @@
     /* inner   */ { 23, 5, JT_INNER                  },
     /* cross   */ { 28, 5, JT_INNER|JT_CROSS         },
   };
-  int i = 0, j = 0;
+  int i, j;
   apAll[0] = pA;
   apAll[1] = pB;
   apAll[2] = pC;
@@ -134531,9 +134529,9 @@
 ** is not contained in the table.
 */
 SQLITE_PRIVATE int sqlite3ColumnIndex(Table *pTab, const char *zCol){
-  int i = 0;
+  int i;
   u8 h = sqlite3StrIHash(zCol);
-  Column *pCol = NULL;
+  Column *pCol;
   for(pCol=pTab->aCol, i=0; i<pTab->nCol; pCol++, i++){
     if( pCol->hName==h && sqlite3StrICmp(pCol->zCnName, zCol)==0 ) return i;
   }
@@ -134557,8 +134555,8 @@
   int *piCol,          /* Write index of pSrc->a[*piTab].pTab->aCol[] here */
   int bIgnoreHidden    /* True to ignore hidden columns */
 ){
-  int i = 0;               /* For looping over tables in pSrc */
-  int iCol = 0;            /* Index of column matching zCol */
+  int i;               /* For looping over tables in pSrc */
+  int iCol;            /* Index of column matching zCol */
 
   assert( (piTab==0)==(piCol==0) );  /* Both or neither are NULL */
   for(i=0; i<N; i++){
@@ -134598,9 +134596,9 @@
   Expr **ppWhere                  /* IN/OUT: The WHERE clause to add to */
 ){
   sqlite3 *db = pParse->db;
-  Expr *pE1 = NULL;
-  Expr *pE2 = NULL;
-  Expr *pEq = NULL;
+  Expr *pE1;
+  Expr *pE2;
+  Expr *pEq;
 
   assert( iLeft<iRight );
   assert( pSrc->nSrc>iRight );
@@ -134658,7 +134656,7 @@
     if( p->op==TK_FUNCTION ){
       assert( ExprUseXList(p) );
       if( p->x.pList ){
-        int i = 0;
+        int i;
         for(i=0; i<p->x.pList->nExpr; i++){
           sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable);
         }
@@ -134687,7 +134685,7 @@
     if( p->op==TK_FUNCTION ){
       assert( ExprUseXList(p) );
       if( p->x.pList ){
-        int i = 0;
+        int i;
         for(i=0; i<p->x.pList->nExpr; i++){
           unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);
         }
@@ -134713,17 +134711,17 @@
 ** This routine returns the number of errors encountered.
 */
 static int sqliteProcessJoin(Parse *pParse, Select *p){
-  SrcList *pSrc = NULL;                  /* All tables in the FROM clause */
-  int i = 0, j = 0;                       /* Loop counters */
-  SrcItem *pLeft = NULL;                 /* Left table being joined */
-  SrcItem *pRight = NULL;                /* Right table being joined */
+  SrcList *pSrc;                  /* All tables in the FROM clause */
+  int i, j;                       /* Loop counters */
+  SrcItem *pLeft;                 /* Left table being joined */
+  SrcItem *pRight;                /* Right table being joined */
 
   pSrc = p->pSrc;
   pLeft = &pSrc->a[0];
   pRight = &pLeft[1];
   for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){
     Table *pRightTab = pRight->pTab;
-    int isOuter = 0;
+    int isOuter;
 
     if( NEVER(pLeft->pTab==0 || pRightTab==0) ) continue;
     isOuter = (pRight->fg.jointype & JT_OUTER)!=0;
@@ -134738,9 +134736,9 @@
         return 1;
       }
       for(j=0; j<pRightTab->nCol; j++){
-        char *zName = NULL;   /* Name of column in the right table */
-        int iLeft = 0;     /* Matching left table */
-        int iLeftCol = 0;  /* Matching column in the left table */
+        char *zName;   /* Name of column in the right table */
+        int iLeft;     /* Matching left table */
+        int iLeftCol;  /* Matching column in the left table */
 
         if( IsHiddenColumn(&pRightTab->aCol[j]) ) continue;
         zName = pRightTab->aCol[j].zCnName;
@@ -134778,10 +134776,10 @@
     if( pRight->pUsing ){
       IdList *pList = pRight->pUsing;
       for(j=0; j<pList->nId; j++){
-        char *zName = NULL;     /* Name of the term in the USING clause */
-        int iLeft = 0;       /* Table on the left with matching column name */
-        int iLeftCol = 0;    /* Column number of matching column on the left */
-        int iRightCol = 0;   /* Column number of matching column on the right */
+        char *zName;     /* Name of the term in the USING clause */
+        int iLeft;       /* Table on the left with matching column name */
+        int iLeftCol;    /* Column number of matching column on the left */
+        int iRightCol;   /* Column number of matching column on the right */
 
         zName = pList->a[j].zName;
         iRightCol = sqlite3ColumnIndex(pRightTab, zName);
@@ -134873,11 +134871,11 @@
   int bSeq = ((pSort->sortFlags & SORTFLAG_UseSorter)==0);
   int nExpr = pSort->pOrderBy->nExpr;              /* No. of ORDER BY terms */
   int nBase = nExpr + bSeq + nData;                /* Fields in sorter record */
-  int regBase = 0;                                     /* Regs for sorter record */
+  int regBase;                                     /* Regs for sorter record */
   int regRecord = 0;                               /* Assembled sorter record */
   int nOBSat = pSort->nOBSat;                      /* ORDER BY terms to skip */
-  int op = 0;                            /* Opcode to add sorter record to sorter */
-  int iLimit = 0;                        /* LIMIT counter */
+  int op;                            /* Opcode to add sorter record to sorter */
+  int iLimit;                        /* LIMIT counter */
   int iSkip = 0;                     /* End of the sorter insert loop */
 
   assert( bSeq==0 || bSeq==1 );
@@ -134916,12 +134914,12 @@
     sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);
   }
   if( nOBSat>0 ){
-    int regPrevKey = 0;   /* The first nOBSat columns of the previous row */
-    int addrFirst = 0;    /* Address of the OP_IfNot opcode */
-    int addrJmp = 0;      /* Address of the OP_Jump opcode */
-    VdbeOp *pOp = NULL;      /* Opcode that opens the sorter */
-    int nKey = 0;         /* Number of sorting key columns, including OP_Sequence */
-    KeyInfo *pKI = NULL;     /* Original KeyInfo on the sorter table */
+    int regPrevKey;   /* The first nOBSat columns of the previous row */
+    int addrFirst;    /* Address of the OP_IfNot opcode */
+    int addrJmp;      /* Address of the OP_Jump opcode */
+    VdbeOp *pOp;      /* Opcode that opens the sorter */
+    int nKey;         /* Number of sorting key columns, including OP_Sequence */
+    KeyInfo *pKI;     /* Original KeyInfo on the sorter table */
 
     regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
     regPrevKey = pParse->nMem+1;
@@ -135070,9 +135068,9 @@
 
   switch( eTnctType ){
     case WHERE_DISTINCT_ORDERED: {
-      int i = 0;
-      int iJump = 0;              /* Jump destination */
-      int regPrev = 0;            /* Previous row content */
+      int i;
+      int iJump;              /* Jump destination */
+      int regPrev;            /* Previous row content */
 
       /* Allocate space for the previous row */
       iRet = regPrev = pParse->nMem+1;
@@ -135273,11 +135271,11 @@
   int iBreak              /* Jump here to break out of the inner loop */
 ){
   Vdbe *v = pParse->pVdbe;
-  int i = 0;
-  int hasDistinct = 0;            /* True if the DISTINCT keyword is present */
+  int i;
+  int hasDistinct;            /* True if the DISTINCT keyword is present */
   int eDest = pDest->eDest;   /* How to dispose of results */
   int iParm = pDest->iSDParm; /* First argument to disposal method */
-  int nResultCol = 0;             /* Number of result columns */
+  int nResultCol;             /* Number of result columns */
   int nPrefixReg = 0;         /* Number of extra registers before regResult */
   RowLoadInfo sRowLoadInfo;   /* Info for deferred row loading */
 
@@ -135286,8 +135284,8 @@
   ** same value. However, if the results are being sent to the sorter, the
   ** values for any expressions that are also part of the sort-key are omitted
   ** from this array. In this case regOrig is set to zero.  */
-  int regResult = 0;              /* Start of memory holding current results */
-  int regOrig = 0;                /* Start of memory holding full result (or 0) */
+  int regResult;              /* Start of memory holding current results */
+  int regOrig;                /* Start of memory holding full result (or 0) */
 
   assert( v );
   assert( p->pEList!=0 );
@@ -135332,8 +135330,8 @@
     /* If the destination is an EXISTS(...) expression, the actual
     ** values returned by the SELECT are not required.
     */
-    u8 ecelFlags = 0;    /* "ecel" is an abbreviation of "ExprCodeExprList" */
-    ExprList *pEList = NULL;
+    u8 ecelFlags;    /* "ecel" is an abbreviation of "ExprCodeExprList" */
+    ExprList *pEList;
     if( eDest==SRT_Mem || eDest==SRT_Output || eDest==SRT_Coroutine ){
       ecelFlags = SQLITE_ECEL_DUP;
     }else{
@@ -135349,7 +135347,7 @@
       ecelFlags |= (SQLITE_ECEL_OMITREF|SQLITE_ECEL_REF);
 
       for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++){
-        int j = 0;
+        int j;
         if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){
           p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;
         }
@@ -135433,7 +135431,7 @@
     */
 #ifndef SQLITE_OMIT_COMPOUND_SELECT
     case SRT_Union: {
-      int r1 = 0;
+      int r1;
       r1 = sqlite3GetTempReg(pParse);
       sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1);
       sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);
@@ -135590,10 +135588,10 @@
     */
     case SRT_DistQueue:
     case SRT_Queue: {
-      int nKey = 0;
-      int r1 = 0, r2 = 0, r3 = 0;
+      int nKey;
+      int r1, r2, r3;
       int addrTest = 0;
-      ExprList *pSO = NULL;
+      ExprList *pSO;
       pSO = pDest->pOrderBy;
       assert( pSO );
       nKey = pSO->nExpr;
@@ -135725,11 +135723,11 @@
   int iStart,          /* Begin with this column of pList */
   int nExtra           /* Add this many extra columns to the end */
 ){
-  int nExpr = 0;
-  KeyInfo *pInfo = NULL;
-  struct ExprList_item *pItem = NULL;
+  int nExpr;
+  KeyInfo *pInfo;
+  struct ExprList_item *pItem;
   sqlite3 *db = pParse->db;
-  int i = 0;
+  int i;
 
   nExpr = pList->nExpr;
   pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);
@@ -135747,7 +135745,7 @@
 ** Name of the connection operator, used for error messages.
 */
 SQLITE_PRIVATE const char *sqlite3SelectOpName(int id){
-  char *z = NULL;
+  char *z;
   switch( id ){
     case TK_ALL:       z = "UNION ALL";   break;
     case TK_INTERSECT: z = "INTERSECT";   break;
@@ -135804,19 +135802,19 @@
   Vdbe *v = pParse->pVdbe;                     /* The prepared statement */
   int addrBreak = pSort->labelDone;            /* Jump here to exit loop */
   int addrContinue = sqlite3VdbeMakeLabel(pParse);/* Jump here for next cycle */
-  int addr = 0;                       /* Top of output loop. Jump for Next. */
+  int addr;                       /* Top of output loop. Jump for Next. */
   int addrOnce = 0;
-  int iTab = 0;
+  int iTab;
   ExprList *pOrderBy = pSort->pOrderBy;
   int eDest = pDest->eDest;
   int iParm = pDest->iSDParm;
-  int regRow = 0;
-  int regRowid = 0;
-  int iCol = 0;
-  int nKey = 0;                       /* Number of key columns in sorter record */
-  int iSortTab = 0;                   /* Sorter cursor to read from */
-  int i = 0;
-  int bSeq = 0;                       /* True if sorter record includes seq. no. */
+  int regRow;
+  int regRowid;
+  int iCol;
+  int nKey;                       /* Number of key columns in sorter record */
+  int iSortTab;                   /* Sorter cursor to read from */
+  int i;
+  int bSeq;                       /* True if sorter record includes seq. no. */
   int nRefKey = 0;
   struct ExprList_item *aOutEx = p->pEList->a;
 
@@ -135918,7 +135916,7 @@
     }else
 #endif
     {
-      int iRead = 0;
+      int iRead;
       if( aOutEx[i].u.x.iOrderByCol ){
         iRead = aOutEx[i].u.x.iOrderByCol-1;
       }else{
@@ -136034,7 +136032,7 @@
 #endif
 ){
   char const *zType = 0;
-  int j = 0;
+  int j;
 #ifdef SQLITE_ENABLE_COLUMN_METADATA
   char const *zOrigDb = 0;
   char const *zOrigTab = 0;
@@ -136144,8 +136142,8 @@
       ** statement.
       */
       NameContext sNC;
-      Select *pS = NULL;
-      Expr *p = NULL;
+      Select *pS;
+      Expr *p;
       assert( ExprUseXSelect(pExpr) );
       pS = pExpr->x.pSelect;
       p = pS->pEList->a[0].pExpr;
@@ -136180,14 +136178,14 @@
 ){
 #ifndef SQLITE_OMIT_DECLTYPE
   Vdbe *v = pParse->pVdbe;
-  int i = 0;
+  int i;
   NameContext sNC;
   sNC.pSrcList = pTabList;
   sNC.pParse = pParse;
   sNC.pNext = 0;
   for(i=0; i<pEList->nExpr; i++){
     Expr *p = pEList->a[i].pExpr;
-    const char *zType = NULL;
+    const char *zType;
 #ifdef SQLITE_ENABLE_COLUMN_METADATA
     const char *zOrigDb = 0;
     const char *zOrigTab = 0;
@@ -136245,13 +136243,13 @@
   Select *pSelect     /* Generate column names for this SELECT statement */
 ){
   Vdbe *v = pParse->pVdbe;
-  int i = 0;
-  Table *pTab = NULL;
-  SrcList *pTabList = NULL;
-  ExprList *pEList = NULL;
+  int i;
+  Table *pTab;
+  SrcList *pTabList;
+  ExprList *pEList;
   sqlite3 *db = pParse->db;
-  int fullName = 0;    /* TABLE.COLUMN if no AS clause and is a direct table ref */
-  int srcName = 0;     /* COLUMN or TABLE.COLUMN if no AS clause and is direct */
+  int fullName;    /* TABLE.COLUMN if no AS clause and is a direct table ref */
+  int srcName;     /* COLUMN or TABLE.COLUMN if no AS clause and is direct */
 
 #ifndef SQLITE_OMIT_EXPLAIN
   /* If this is an EXPLAIN, skip this step */
@@ -136284,7 +136282,7 @@
       char *zName = pEList->a[i].zEName;
       sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);
     }else if( srcName && p->op==TK_COLUMN ){
-      char *zCol = NULL;
+      char *zCol;
       int iCol = p->iColumn;
       pTab = p->y.pTab;
       assert( pTab!=0 );
@@ -136340,14 +136338,14 @@
   Column **paCol          /* Write the new column list here */
 ){
   sqlite3 *db = pParse->db;   /* Database connection */
-  int i = 0, j = 0;                   /* Loop counters */
-  u32 cnt = 0;                    /* Index added to make the name unique */
-  Column *aCol = NULL, *pCol = NULL;        /* For looping over result columns */
-  int nCol = 0;                   /* Number of columns in the result set */
-  char *zName = NULL;                /* Column name */
-  int nName = 0;                  /* Size of name in zName[] */
+  int i, j;                   /* Loop counters */
+  u32 cnt;                    /* Index added to make the name unique */
+  Column *aCol, *pCol;        /* For looping over result columns */
+  int nCol;                   /* Number of columns in the result set */
+  char *zName;                /* Column name */
+  int nName;                  /* Size of name in zName[] */
   Hash ht;                    /* Hash table of column names */
-  Table *pTab = NULL;
+  Table *pTab;
 
   sqlite3HashInit(&ht);
   if( pEList ){
@@ -136448,11 +136446,11 @@
 ){
   sqlite3 *db = pParse->db;
   NameContext sNC;
-  Column *pCol = NULL;
-  CollSeq *pColl = NULL;
-  int i = 0;
-  Expr *p = NULL;
-  struct ExprList_item *a = NULL;
+  Column *pCol;
+  CollSeq *pColl;
+  int i;
+  Expr *p;
+  struct ExprList_item *a;
 
   assert( pSelect!=0 );
   assert( (pSelect->selFlags & SF_Resolved)!=0 );
@@ -136462,8 +136460,8 @@
   sNC.pSrcList = pSelect->pSrc;
   a = pSelect->pEList->a;
   for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
-    const char *zType = NULL;
-    i64 n = 0, m = 0;
+    const char *zType;
+    i64 n, m;
     pTab->tabFlags |= (pCol->colFlags & COLFLAG_NOINSERT);
     p = a[i].pExpr;
     zType = columnType(&sNC, p, 0, 0, 0);
@@ -136496,9 +136494,9 @@
 ** the result set of that SELECT.
 */
 SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){
-  Table *pTab = NULL;
+  Table *pTab;
   sqlite3 *db = pParse->db;
-  u64 savedFlags = 0;
+  u64 savedFlags;
 
   savedFlags = db->flags;
   db->flags &= ~(u64)SQLITE_FullColNames;
@@ -136567,8 +136565,8 @@
 static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
   Vdbe *v = 0;
   int iLimit = 0;
-  int iOffset = 0;
-  int n = 0;
+  int iOffset;
+  int n;
   Expr *pLimit = p->pLimit;
 
   if( p->iLimit ) return;
@@ -136622,7 +136620,7 @@
 ** left-most term of the select that has a collating sequence.
 */
 static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){
-  CollSeq *pRet = NULL;
+  CollSeq *pRet;
   if( p->pPrior ){
     pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);
   }else{
@@ -136653,11 +136651,11 @@
   sqlite3 *db = pParse->db;
   KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);
   if( pRet ){
-    int i = 0;
+    int i;
     for(i=0; i<nOrderBy; i++){
       struct ExprList_item *pItem = &pOrderBy->a[i];
       Expr *pTerm = pItem->pExpr;
-      CollSeq *pColl = NULL;
+      CollSeq *pColl;
 
       if( pTerm->flags & EP_Collate ){
         pColl = sqlite3ExprCollSeq(pParse, pTerm);
@@ -136721,21 +136719,21 @@
   SrcList *pSrc = p->pSrc;      /* The FROM clause of the recursive query */
   int nCol = p->pEList->nExpr;  /* Number of columns in the recursive table */
   Vdbe *v = pParse->pVdbe;      /* The prepared statement under construction */
-  Select *pSetup = NULL;               /* The setup query */
-  Select *pFirstRec = NULL;            /* Left-most recursive term */
-  int addrTop = 0;                  /* Top of the loop */
-  int addrCont = 0, addrBreak = 0;      /* CONTINUE and BREAK addresses */
+  Select *pSetup;               /* The setup query */
+  Select *pFirstRec;            /* Left-most recursive term */
+  int addrTop;                  /* Top of the loop */
+  int addrCont, addrBreak;      /* CONTINUE and BREAK addresses */
   int iCurrent = 0;             /* The Current table */
-  int regCurrent = 0;               /* Register holding Current table */
-  int iQueue = 0;                   /* The Queue table */
+  int regCurrent;               /* Register holding Current table */
+  int iQueue;                   /* The Queue table */
   int iDistinct = 0;            /* To ensure unique results if UNION */
   int eDest = SRT_Fifo;         /* How to write to Queue */
   SelectDest destQueue;         /* SelectDest targetting the Queue table */
-  int i = 0;                        /* Loop counter */
-  int rc = 0;                       /* Result code */
-  ExprList *pOrderBy = NULL;           /* The ORDER BY clause */
-  Expr *pLimit = NULL;                 /* Saved LIMIT and OFFSET */
-  int regLimit = 0, regOffset = 0;      /* Registers used by LIMIT and OFFSET */
+  int i;                        /* Loop counter */
+  int rc;                       /* Result code */
+  ExprList *pOrderBy;           /* The ORDER BY clause */
+  Expr *pLimit;                 /* Saved LIMIT and OFFSET */
+  int regLimit, regOffset;      /* Registers used by LIMIT and OFFSET */
 
 #ifndef SQLITE_OMIT_WINDOWFUNC
   if( p->pWin ){
@@ -136968,11 +136966,11 @@
   SelectDest *pDest     /* What to do with query results */
 ){
   int rc = SQLITE_OK;   /* Success code from a subroutine */
-  Select *pPrior = NULL;       /* Another SELECT immediately to our left */
-  Vdbe *v = NULL;              /* Generate code to this VDBE */
+  Select *pPrior;       /* Another SELECT immediately to our left */
+  Vdbe *v;              /* Generate code to this VDBE */
   SelectDest dest;      /* Alternative data destination */
   Select *pDelete = 0;  /* Chain of simple selects to delete */
-  sqlite3 *db = NULL;          /* Database connection */
+  sqlite3 *db;          /* Database connection */
 
   /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only
   ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.
@@ -137077,11 +137075,11 @@
       }
       case TK_EXCEPT:
       case TK_UNION: {
-        int unionTab = 0;    /* Cursor number of the temp table holding result */
+        int unionTab;    /* Cursor number of the temp table holding result */
         u8 op = 0;       /* One of the SRT_ operations to apply to self */
-        int priorOp = 0;     /* The SRT_ operation to apply to prior selects */
-        Expr *pLimit = NULL;    /* Saved values of p->nLimit  */
-        int addr = 0;
+        int priorOp;     /* The SRT_ operation to apply to prior selects */
+        Expr *pLimit;    /* Saved values of p->nLimit  */
+        int addr;
         SelectDest uniondest;
 
         testcase( p->op==TK_EXCEPT );
@@ -137152,7 +137150,7 @@
         assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );
         assert( p->pEList || db->mallocFailed );
         if( dest.eDest!=priorOp && db->mallocFailed==0 ){
-          int iCont = 0, iBreak = 0, iStart = 0;
+          int iCont, iBreak, iStart;
           iBreak = sqlite3VdbeMakeLabel(pParse);
           iCont = sqlite3VdbeMakeLabel(pParse);
           computeLimitRegisters(pParse, p, iBreak);
@@ -137168,12 +137166,12 @@
         break;
       }
       default: assert( p->op==TK_INTERSECT ); {
-        int tab1 = 0, tab2 = 0;
-        int iCont = 0, iBreak = 0, iStart = 0;
-        Expr *pLimit = NULL;
-        int addr = 0;
+        int tab1, tab2;
+        int iCont, iBreak, iStart;
+        Expr *pLimit;
+        int addr;
         SelectDest intersectdest;
-        int r1 = 0;
+        int r1;
 
         /* INTERSECT is different from the others since it requires
         ** two temporary tables.  Hence it has its own case.  Begin
@@ -137263,11 +137261,11 @@
   ** no temp tables are required.
   */
   if( p->selFlags & SF_UsesEphemeral ){
-    int i = 0;                        /* Loop counter */
-    KeyInfo *pKeyInfo = NULL;            /* Collating sequence for the result set */
-    Select *pLoop = NULL;                /* For looping through SELECT statements */
-    CollSeq **apColl = NULL;             /* For looping through pKeyInfo->aColl[] */
-    int nCol = 0;                     /* Number of columns in result set */
+    int i;                        /* Loop counter */
+    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */
+    Select *pLoop;                /* For looping through SELECT statements */
+    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */
+    int nCol;                     /* Number of columns in result set */
 
     assert( p->pNext==0 );
     assert( p->pEList!=0 );
@@ -137359,8 +137357,8 @@
   int iBreak              /* Jump here if we hit the LIMIT */
 ){
   Vdbe *v = pParse->pVdbe;
-  int iContinue = 0;
-  int addr = 0;
+  int iContinue;
+  int addr;
 
   addr = sqlite3VdbeCurrentAddr(v);
   iContinue = sqlite3VdbeMakeLabel(pParse);
@@ -137368,7 +137366,7 @@
   /* Suppress duplicates for UNION, EXCEPT, and INTERSECT
   */
   if( regPrev ){
-    int addr1 = 0, addr2 = 0;
+    int addr1, addr2;
     addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);
     addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,
                               (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
@@ -137404,7 +137402,7 @@
     /* If we are creating a set for an "expr IN (SELECT ...)".
     */
     case SRT_Set: {
-      int r1 = 0;
+      int r1;
       testcase( pIn->nSdst>1 );
       r1 = sqlite3GetTempReg(pParse);
       sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst,
@@ -137561,42 +137559,42 @@
   Select *p,            /* The right-most of SELECTs to be coded */
   SelectDest *pDest     /* What to do with query results */
 ){
-  int i = 0, j = 0;             /* Loop counters */
-  Select *pPrior = NULL;       /* Another SELECT immediately to our left */
-  Select *pSplit = NULL;       /* Left-most SELECT in the right-hand group */
-  int nSelect = 0;          /* Number of SELECT statements in the compound */
-  Vdbe *v = NULL;              /* Generate code to this VDBE */
+  int i, j;             /* Loop counters */
+  Select *pPrior;       /* Another SELECT immediately to our left */
+  Select *pSplit;       /* Left-most SELECT in the right-hand group */
+  int nSelect;          /* Number of SELECT statements in the compound */
+  Vdbe *v;              /* Generate code to this VDBE */
   SelectDest destA;     /* Destination for coroutine A */
   SelectDest destB;     /* Destination for coroutine B */
-  int regAddrA = 0;         /* Address register for select-A coroutine */
-  int regAddrB = 0;         /* Address register for select-B coroutine */
-  int addrSelectA = 0;      /* Address of the select-A coroutine */
-  int addrSelectB = 0;      /* Address of the select-B coroutine */
-  int regOutA = 0;          /* Address register for the output-A subroutine */
-  int regOutB = 0;          /* Address register for the output-B subroutine */
-  int addrOutA = 0;         /* Address of the output-A subroutine */
+  int regAddrA;         /* Address register for select-A coroutine */
+  int regAddrB;         /* Address register for select-B coroutine */
+  int addrSelectA;      /* Address of the select-A coroutine */
+  int addrSelectB;      /* Address of the select-B coroutine */
+  int regOutA;          /* Address register for the output-A subroutine */
+  int regOutB;          /* Address register for the output-B subroutine */
+  int addrOutA;         /* Address of the output-A subroutine */
   int addrOutB = 0;     /* Address of the output-B subroutine */
-  int addrEofA = 0;         /* Address of the select-A-exhausted subroutine */
-  int addrEofA_noB = 0;     /* Alternate addrEofA if B is uninitialized */
-  int addrEofB = 0;         /* Address of the select-B-exhausted subroutine */
-  int addrAltB = 0;         /* Address of the A<B subroutine */
-  int addrAeqB = 0;         /* Address of the A==B subroutine */
-  int addrAgtB = 0;         /* Address of the A>B subroutine */
-  int regLimitA = 0;        /* Limit register for select-A */
-  int regLimitB = 0;        /* Limit register for select-A */
-  int regPrev = 0;          /* A range of registers to hold previous output */
-  int savedLimit = 0;       /* Saved value of p->iLimit */
-  int savedOffset = 0;      /* Saved value of p->iOffset */
-  int labelCmpr = 0;        /* Label for the start of the merge algorithm */
-  int labelEnd = 0;         /* Label for the end of the overall SELECT stmt */
-  int addr1 = 0;            /* Jump instructions that get retargetted */
-  int op = 0;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */
+  int addrEofA;         /* Address of the select-A-exhausted subroutine */
+  int addrEofA_noB;     /* Alternate addrEofA if B is uninitialized */
+  int addrEofB;         /* Address of the select-B-exhausted subroutine */
+  int addrAltB;         /* Address of the A<B subroutine */
+  int addrAeqB;         /* Address of the A==B subroutine */
+  int addrAgtB;         /* Address of the A>B subroutine */
+  int regLimitA;        /* Limit register for select-A */
+  int regLimitB;        /* Limit register for select-A */
+  int regPrev;          /* A range of registers to hold previous output */
+  int savedLimit;       /* Saved value of p->iLimit */
+  int savedOffset;      /* Saved value of p->iOffset */
+  int labelCmpr;        /* Label for the start of the merge algorithm */
+  int labelEnd;         /* Label for the end of the overall SELECT stmt */
+  int addr1;            /* Jump instructions that get retargetted */
+  int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */
   KeyInfo *pKeyDup = 0; /* Comparison information for duplicate removal */
-  KeyInfo *pKeyMerge = NULL;   /* Comparison information for merging rows */
-  sqlite3 *db = NULL;          /* Database connection */
-  ExprList *pOrderBy = NULL;   /* The ORDER BY clause */
-  int nOrderBy = 0;         /* Number of terms in the ORDER BY clause */
-  u32 *aPermute = NULL;        /* Mapping from ORDER BY terms to result set columns */
+  KeyInfo *pKeyMerge;   /* Comparison information for merging rows */
+  sqlite3 *db;          /* Database connection */
+  ExprList *pOrderBy;   /* The ORDER BY clause */
+  int nOrderBy;         /* Number of terms in the ORDER BY clause */
+  u32 *aPermute;        /* Mapping from ORDER BY terms to result set columns */
 
   assert( p->pOrderBy!=0 );
   assert( pKeyDup==0 ); /* "Managed" code needs this.  Ticket #3382. */
@@ -137621,7 +137619,7 @@
   */
   if( op!=TK_ALL ){
     for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){
-      struct ExprList_item *pItem = NULL;
+      struct ExprList_item *pItem;
       for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){
         assert( pItem!=0 );
         assert( pItem->u.x.iOrderByCol>0 );
@@ -137647,7 +137645,7 @@
   */
   aPermute = sqlite3DbMallocRawNN(db, sizeof(u32)*(nOrderBy + 1));
   if( aPermute ){
-    struct ExprList_item *pItem = NULL;
+    struct ExprList_item *pItem;
     aPermute[0] = nOrderBy;
     for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++){
       assert( pItem!=0 );
@@ -137926,7 +137924,7 @@
     }else
 #endif
     {
-      Expr *pNew = NULL;
+      Expr *pNew;
       Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;
       Expr ifNullRow;
       assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );
@@ -137995,7 +137993,7 @@
   SubstContext *pSubst, /* Description of the substitution */
   ExprList *pList       /* List to scan and in which to make substitutes */
 ){
-  int i = 0;
+  int i;
   if( pList==0 ) return;
   for(i=0; i<pList->nExpr; i++){
     pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);
@@ -138006,9 +138004,9 @@
   Select *p,            /* SELECT statement in which to make substitutions */
   int doPrior           /* Do substitutes on p->pPrior too */
 ){
-  SrcList *pSrc = NULL;
-  SrcItem *pItem = NULL;
-  int i = 0;
+  SrcList *pSrc;
+  SrcItem *pItem;
+  int i;
   if( !p ) return;
   do{
     substExprList(pSubst, p->pEList);
@@ -138037,7 +138035,7 @@
 ** pSrcItem->colUsed mask.
 */
 static int recomputeColumnsUsedExpr(Walker *pWalker, Expr *pExpr){
-  SrcItem *pItem = NULL;
+  SrcItem *pItem;
   if( pExpr->op!=TK_COLUMN ) return WRC_Continue;
   pItem = pWalker->u.pSrcItem;
   if( pItem->iCursor!=pExpr->iTable ) return WRC_Continue;
@@ -138080,11 +138078,11 @@
   SrcList *pSrc,                  /* FROM clause to renumber */
   int iExcept                     /* FROM clause item to skip */
 ){
-  int i = 0;
-  SrcItem *pItem = NULL;
+  int i;
+  SrcItem *pItem;
   for(i=0, pItem=pSrc->a; i<pSrc->nSrc; i++, pItem++){
     if( i!=iExcept ){
-      Select *p = NULL;
+      Select *p;
       assert( pItem->iCursor < aCsrMap[0] );
       if( !pItem->fg.isRecursive || aCsrMap[pItem->iCursor+1]==0 ){
         aCsrMap[pItem->iCursor+1] = pParse->nTab++;
@@ -138319,17 +138317,17 @@
   int isAgg            /* True if outer SELECT uses aggregate functions */
 ){
   const char *zSavedAuthContext = pParse->zAuthContext;
-  Select *pParent = NULL;    /* Current UNION ALL term of the other query */
-  Select *pSub = NULL;       /* The inner query or "subquery" */
-  Select *pSub1 = NULL;      /* Pointer to the rightmost select in sub-query */
-  SrcList *pSrc = NULL;      /* The FROM clause of the outer query */
-  SrcList *pSubSrc = NULL;   /* The FROM clause of the subquery */
-  int iParent = 0;        /* VDBE cursor number of the pSub result set temp table */
+  Select *pParent;    /* Current UNION ALL term of the other query */
+  Select *pSub;       /* The inner query or "subquery" */
+  Select *pSub1;      /* Pointer to the rightmost select in sub-query */
+  SrcList *pSrc;      /* The FROM clause of the outer query */
+  SrcList *pSubSrc;   /* The FROM clause of the subquery */
+  int iParent;        /* VDBE cursor number of the pSub result set temp table */
   int iNewParent = -1;/* Replacement table for iParent */
   int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */
-  int i = 0;              /* Loop counter */
-  Expr *pWhere = NULL;                    /* The WHERE clause */
-  SrcItem *pSubitem = NULL;               /* The subquery */
+  int i;              /* Loop counter */
+  Expr *pWhere;                    /* The WHERE clause */
+  SrcItem *pSubitem;               /* The subquery */
   sqlite3 *db = pParse->db;
   Walker w;                        /* Walker to persist agginfo data */
   int *aCsrMap = 0;
@@ -138451,7 +138449,7 @@
 
     /* Restriction (18). */
     if( p->pOrderBy ){
-      int ii = 0;
+      int ii;
       for(ii=0; ii<p->pOrderBy->nExpr; ii++){
         if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;
       }
@@ -138522,7 +138520,7 @@
   ** We call this the "compound-subquery flattening".
   */
   for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){
-    Select *pNew = NULL;
+    Select *pNew;
     ExprList *pOrderBy = p->pOrderBy;
     Expr *pLimit = p->pLimit;
     Select *pPrior = p->pPrior;
@@ -138594,7 +138592,7 @@
   */
   pSub = pSub1;
   for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
-    int nSubSrc = 0;
+    int nSubSrc;
     u8 jointype = 0;
     assert( pSub!=0 );
     pSubSrc = pSub->pSrc;     /* FROM clause of subquery */
@@ -138760,7 +138758,7 @@
   Expr *pValue,        /* The VALUE part of the constraint */
   Expr *pExpr          /* Overall expression: COLUMN=VALUE or VALUE=COLUMN */
 ){
-  int i = 0;
+  int i;
   assert( pColumn->op==TK_COLUMN );
   assert( sqlite3ExprIsConstant(pValue) );
 
@@ -138803,7 +138801,7 @@
 ** found, add it to the pConst structure.
 */
 static void findConstInWhere(WhereConst *pConst, Expr *pExpr){
-  Expr *pRight = NULL, *pLeft = NULL;
+  Expr *pRight, *pLeft;
   if( NEVER(pExpr==0) ) return;
   if( ExprHasProperty(pExpr, EP_FromJoin) ) return;
   if( pExpr->op==TK_AND ){
@@ -138838,7 +138836,7 @@
   Expr *pExpr,
   int bIgnoreAffBlob
 ){
-  int i = 0;
+  int i;
   if( pConst->pOomFault[0] ) return WRC_Prune;
   if( pExpr->op!=TK_COLUMN ) return WRC_Continue;
   if( ExprHasProperty(pExpr, EP_FixedCol|EP_FromJoin) ){
@@ -139088,14 +139086,14 @@
   Expr *pWhere,         /* The WHERE clause of the outer query */
   SrcItem *pSrc         /* The subquery term of the outer FROM clause */
 ){
-  Expr *pNew = NULL;
+  Expr *pNew;
   int nChng = 0;
   if( pWhere==0 ) return 0;
   if( pSubq->selFlags & (SF_Recursive|SF_MultiPart) ) return 0;
 
 #ifndef SQLITE_OMIT_WINDOWFUNC
   if( pSubq->pPrior ){
-    Select *pSel = NULL;
+    Select *pSel;
     for(pSel=pSubq; pSel; pSel=pSel->pPrior){
       if( pSel->pWin ) return 0;    /* restriction (6b) */
     }
@@ -139190,9 +139188,9 @@
 */
 static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){
   int eRet = WHERE_ORDERBY_NORMAL;      /* Return value */
-  ExprList *pEList = NULL;                     /* Arguments to agg function */
-  const char *zFunc = NULL;                    /* Name of aggregate function pFunc */
-  ExprList *pOrderBy = NULL;
+  ExprList *pEList;                     /* Arguments to agg function */
+  const char *zFunc;                    /* Name of aggregate function pFunc */
+  ExprList *pOrderBy;
   u8 sortFlags = 0;
 
   assert( *ppMinMax==0 );
@@ -139244,8 +139242,8 @@
 ** result in incorrect answers and/or crashes.  So, when in doubt, return NULL.
 */
 static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){
-  Table *pTab = NULL;
-  Expr *pExpr = NULL;
+  Table *pTab;
+  Expr *pExpr;
 
   assert( !p->pGroupBy );
 
@@ -139284,7 +139282,7 @@
 SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, SrcItem *pFrom){
   Table *pTab = pFrom->pTab;
   char *zIndexedBy = pFrom->u1.zIndexedBy;
-  Index *pIdx = NULL;
+  Index *pIdx;
   assert( pTab!=0 );
   assert( pFrom->fg.isIndexedBy!=0 );
 
@@ -139324,13 +139322,13 @@
 ** there are COLLATE terms in the ORDER BY.
 */
 static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){
-  int i = 0;
-  Select *pNew = NULL;
-  Select *pX = NULL;
-  sqlite3 *db = NULL;
-  struct ExprList_item *a = NULL;
-  SrcList *pNewSrc = NULL;
-  Parse *pParse = NULL;
+  int i;
+  Select *pNew;
+  Select *pX;
+  sqlite3 *db;
+  struct ExprList_item *a;
+  SrcList *pNewSrc;
+  Parse *pParse;
   Token dummy;
 
   if( p->pPrior==0 ) return WRC_Continue;
@@ -139413,11 +139411,11 @@
   With **ppContext                /* OUT: WITH clause return value belongs to */
 ){
   const char *zName = pItem->zName;
-  With *p = NULL;
+  With *p;
   assert( pItem->zDatabase==0 );
   assert( zName!=0 );
   for(p=pWith; p; p=p->pOuter){
-    int i = 0;
+    int i;
     for(i=0; i<p->nCte; i++){
       if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){
         *ppContext = p;
@@ -139482,8 +139480,8 @@
   Walker *pWalker,                /* Current tree walker */
   SrcItem *pFrom                  /* The FROM clause term to check */
 ){
-  Cte *pCte = NULL;               /* Matched CTE (or NULL if no match) */
-  With *pWith = NULL;             /* The matching WITH */
+  Cte *pCte;               /* Matched CTE (or NULL if no match) */
+  With *pWith;             /* The matching WITH */
 
   assert( pFrom->pTab==0 );
   if( pParse->pWith==0 ){
@@ -139511,15 +139509,15 @@
   pCte = searchWith(pParse->pWith, pFrom, &pWith);
   if( pCte ){
     sqlite3 *db = pParse->db;
-    Table *pTab = NULL;
-    ExprList *pEList = NULL;
-    Select *pSel = NULL;
-    Select *pLeft = NULL;                /* Left-most SELECT statement */
-    Select *pRecTerm = NULL;             /* Left-most recursive term */
-    int bMayRecursive = 0;            /* True if compound joined by UNION [ALL] */
-    With *pSavedWith = NULL;             /* Initial value of pParse->pWith */
+    Table *pTab;
+    ExprList *pEList;
+    Select *pSel;
+    Select *pLeft;                /* Left-most SELECT statement */
+    Select *pRecTerm;             /* Left-most recursive term */
+    int bMayRecursive;            /* True if compound joined by UNION [ALL] */
+    With *pSavedWith;             /* Initial value of pParse->pWith */
     int iRecTab = -1;             /* Cursor for recursive table */
-    CteUse *pCteUse = NULL;
+    CteUse *pCteUse;
 
     /* If pCte->zCteErr is non-NULL at this point, then this is an illegal
     ** recursive reference to CTE pCte. Leave an error in pParse and return
@@ -139570,7 +139568,7 @@
     pRecTerm = pSel = pFrom->pSelect;
     bMayRecursive = ( pSel->op==TK_ALL || pSel->op==TK_UNION );
     while( bMayRecursive && pRecTerm->op==pSel->op ){
-      int i = 0;
+      int i;
       SrcList *pSrc = pRecTerm->pSrc;
       assert( pRecTerm->pPrior!=0 );
       for(i=0; i<pSrc->nSrc; i++){
@@ -139601,7 +139599,7 @@
     pSavedWith = pParse->pWith;
     pParse->pWith = pWith;
     if( pSel->selFlags & SF_Recursive ){
-      int rc = 0;
+      int rc;
       assert( pRecTerm!=0 );
       assert( (pRecTerm->selFlags & SF_Recursive)==0 );
       assert( pRecTerm->pNext!=0 );
@@ -139682,7 +139680,7 @@
 */
 SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse *pParse, SrcItem *pFrom){
   Select *pSel = pFrom->pSelect;
-  Table *pTab = NULL;
+  Table *pTab;
 
   assert( pSel );
   pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));
@@ -139734,12 +139732,12 @@
 */
 static int selectExpander(Walker *pWalker, Select *p){
   Parse *pParse = pWalker->pParse;
-  int i = 0, j = 0, k = 0, rc = 0;
-  SrcList *pTabList = NULL;
-  ExprList *pEList = NULL;
-  SrcItem *pFrom = NULL;
+  int i, j, k, rc;
+  SrcList *pTabList;
+  ExprList *pEList;
+  SrcItem *pFrom;
   sqlite3 *db = pParse->db;
-  Expr *pE = NULL, *pRight = NULL, *pExpr = NULL;
+  Expr *pE, *pRight, *pExpr;
   u16 selFlags = p->selFlags;
   u32 elistFlags = 0;
 
@@ -139778,7 +139776,7 @@
   ** then create a transient table structure to describe the subquery.
   */
   for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
-    Table *pTab = NULL;
+    Table *pTab;
     assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );
     if( pFrom->pTab ) continue;
     assert( pFrom->fg.isRecursive==0 );
@@ -139814,7 +139812,7 @@
       }
 #if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
       if( !IsOrdinaryTable(pTab) ){
-        i16 nCol = 0;
+        i16 nCol;
         u8 eCodeOrig = pWalker->eCode;
         if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;
         assert( pFrom->pSelect==0 );
@@ -139924,7 +139922,7 @@
           Select *pSub = pFrom->pSelect;
           char *zTabName = pFrom->zAlias;
           const char *zSchemaName = 0;
-          int iDb = 0;
+          int iDb;
           if( zTabName==0 ){
             zTabName = pTab->zName;
           }
@@ -139939,8 +139937,8 @@
           }
           for(j=0; j<pTab->nCol; j++){
             char *zName = pTab->aCol[j].zCnName;
-            char *zColname = NULL;  /* The computed column name */
-            char *zToFree = NULL;   /* Malloced string that needs to be freed */
+            char *zColname;  /* The computed column name */
+            char *zToFree;   /* Malloced string that needs to be freed */
             Token sColname;  /* Computed column name as a token */
 
             assert( zName );
@@ -139979,7 +139977,7 @@
             zColname = zName;
             zToFree = 0;
             if( longNames || pTabList->nSrc>1 ){
-              Expr *pLeft = NULL;
+              Expr *pLeft;
               pLeft = sqlite3Expr(db, TK_ID, zTabName);
               pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);
               if( zSchemaName ){
@@ -140090,10 +140088,10 @@
 ** routine is called after identifier resolution.
 */
 static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){
-  Parse *pParse = NULL;
-  int i = 0;
-  SrcList *pTabList = NULL;
-  SrcItem *pFrom = NULL;
+  Parse *pParse;
+  int i;
+  SrcList *pTabList;
+  SrcItem *pFrom;
 
   assert( p->selFlags & SF_Resolved );
   if( p->selFlags & SF_HasTypeInfo ) return;
@@ -140174,8 +140172,8 @@
 */
 static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){
   Vdbe *v = pParse->pVdbe;
-  int i = 0;
-  struct AggInfo_func *pFunc = NULL;
+  int i;
+  struct AggInfo_func *pFunc;
   int nReg = pAggInfo->nFunc + pAggInfo->nColumn;
   assert( pParse->db->pParse==pParse );
   assert( pParse->db->mallocFailed==0 || pParse->nErr!=0 );
@@ -140220,10 +140218,10 @@
 */
 static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){
   Vdbe *v = pParse->pVdbe;
-  int i = 0;
-  struct AggInfo_func *pF = NULL;
+  int i;
+  struct AggInfo_func *pF;
   for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
-    ExprList *pList = NULL;
+    ExprList *pList;
     assert( ExprUseXList(pF->pFExpr) );
     pList = pF->pFExpr->x.pList;
     sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);
@@ -140248,18 +140246,18 @@
   int eDistinctType
 ){
   Vdbe *v = pParse->pVdbe;
-  int i = 0;
+  int i;
   int regHit = 0;
   int addrHitTest = 0;
-  struct AggInfo_func *pF = NULL;
-  struct AggInfo_col *pC = NULL;
+  struct AggInfo_func *pF;
+  struct AggInfo_col *pC;
 
   pAggInfo->directMode = 1;
   for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
-    int nArg = 0;
+    int nArg;
     int addrNext = 0;
-    int regAgg = 0;
-    ExprList *pList = NULL;
+    int regAgg;
+    ExprList *pList;
     assert( ExprUseXList(pF->pFExpr) );
     assert( !IsWindowFunc(pF->pFExpr) );
     pList = pF->pFExpr->x.pList;
@@ -140302,8 +140300,8 @@
     }
     if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){
       CollSeq *pColl = 0;
-      struct ExprList_item *pItem = NULL;
-      int j = 0;
+      struct ExprList_item *pItem;
+      int j;
       assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */
       for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){
         pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
@@ -140440,11 +140438,11 @@
   SrcList *pTabList,           /* Search for self-joins in this FROM clause */
   SrcItem *pThis               /* Search for prior reference to this subquery */
 ){
-  SrcItem *pItem = NULL;
+  SrcItem *pItem;
   assert( pThis->pSelect!=0 );
   if( pThis->pSelect->selFlags & SF_PushDown ) return 0;
   for(pItem = pTabList->a; pItem<pThis; pItem++){
-    Select *pS1 = NULL;
+    Select *pS1;
     if( pItem->pSelect==0 ) continue;
     if( pItem->fg.viaCoroutine ) continue;
     if( pItem->zName==0 ) continue;
@@ -140584,23 +140582,23 @@
   Select *p,             /* The SELECT statement being coded. */
   SelectDest *pDest      /* What to do with the query results */
 ){
-  int i = 0, j = 0;              /* Loop counters */
-  WhereInfo *pWInfo = NULL;     /* Return from sqlite3WhereBegin() */
-  Vdbe *v = NULL;               /* The virtual machine under construction */
-  int isAgg = 0;             /* True for select lists like "count(*)" */
+  int i, j;              /* Loop counters */
+  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */
+  Vdbe *v;               /* The virtual machine under construction */
+  int isAgg;             /* True for select lists like "count(*)" */
   ExprList *pEList = 0;  /* List of columns to extract. */
-  SrcList *pTabList = NULL;     /* List of tables to select from */
-  Expr *pWhere = NULL;          /* The WHERE clause.  May be NULL */
-  ExprList *pGroupBy = NULL;    /* The GROUP BY clause.  May be NULL */
-  Expr *pHaving = NULL;         /* The HAVING clause.  May be NULL */
+  SrcList *pTabList;     /* List of tables to select from */
+  Expr *pWhere;          /* The WHERE clause.  May be NULL */
+  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */
+  Expr *pHaving;         /* The HAVING clause.  May be NULL */
   AggInfo *pAggInfo = 0; /* Aggregate information */
   int rc = 1;            /* Value to return from this function */
   DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */
   SortCtx sSort;         /* Info on how to code the ORDER BY clause */
-  int iEnd = 0;              /* Address of the end of the query */
-  sqlite3 *db = NULL;           /* The database connection */
+  int iEnd;              /* Address of the end of the query */
+  sqlite3 *db;           /* The database connection */
   ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */
-  u8 minMaxFlag = 0;                 /* Flag for min/max queries */
+  u8 minMaxFlag;                 /* Flag for min/max queries */
 
   db = pParse->db;
   assert( pParse==db->pParse );
@@ -140879,11 +140877,11 @@
   */
   for(i=0; i<pTabList->nSrc; i++){
     SrcItem *pItem = &pTabList->a[i];
-    SrcItem *pPrior = NULL;
+    SrcItem *pPrior;
     SelectDest dest;
-    Select *pSub = NULL;
+    Select *pSub;
 #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
-    const char *zSavedAuthContext = NULL;
+    const char *zSavedAuthContext;
 #endif
 
     /* Issue SQLITE_READ authorizations with a fake column name for any
@@ -141004,9 +141002,9 @@
       /* Materialize the view.  If the view is not correlated, generate a
       ** subroutine to do the materialization so that subsequent uses of
       ** the same view can reuse the materialization. */
-      int topAddr = 0;
+      int topAddr;
       int onceAddr = 0;
-      int retAddr = 0;
+      int retAddr;
 
       pItem->regReturn = ++pParse->nMem;
       topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);
@@ -141104,7 +141102,7 @@
   ** that change.
   */
   if( sSort.pOrderBy ){
-    KeyInfo *pKeyInfo = NULL;
+    KeyInfo *pKeyInfo;
     pKeyInfo = sqlite3KeyInfoFromExprList(
         pParse, sSort.pOrderBy, 0, pEList->nExpr);
     sSort.iECursor = pParse->nTab++;
@@ -141226,14 +141224,14 @@
     /* This case when there exist aggregate functions or a GROUP BY clause
     ** or both */
     NameContext sNC;    /* Name context for processing aggregate information */
-    int iAMem = 0;          /* First Mem address for storing current GROUP BY */
-    int iBMem = 0;          /* First Mem address for previous GROUP BY */
-    int iUseFlag = 0;       /* Mem address holding flag indicating that at least
+    int iAMem;          /* First Mem address for storing current GROUP BY */
+    int iBMem;          /* First Mem address for previous GROUP BY */
+    int iUseFlag;       /* Mem address holding flag indicating that at least
                         ** one row of the input to the aggregator has been
                         ** processed */
-    int iAbortFlag = 0;     /* Mem address which causes query abort if positive */
-    int groupBySort = 0;    /* Rows come from source in GROUP BY order */
-    int addrEnd = 0;        /* End of processing for this SELECT */
+    int iAbortFlag;     /* Mem address which causes query abort if positive */
+    int groupBySort;    /* Rows come from source in GROUP BY order */
+    int addrEnd;        /* End of processing for this SELECT */
     int sortPTab = 0;   /* Pseudotable used to decode sorting results */
     int sortOut = 0;    /* Output register from the sorter */
     int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */
@@ -141242,8 +141240,8 @@
     ** GROUP BY clause.
     */
     if( pGroupBy ){
-      int k = 0;                        /* Loop counter */
-      struct ExprList_item *pItem = NULL;  /* For looping over expression in a list */
+      int k;                        /* Loop counter */
+      struct ExprList_item *pItem;  /* For looping over expression in a list */
 
       for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){
         pItem->u.x.iAlias = 0;
@@ -141263,7 +141261,7 @@
       ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp
       ** variable.  */
       if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){
-        int ii = 0;
+        int ii;
         /* The GROUP BY processing doesn't care whether rows are delivered in
         ** ASC or DESC order - only that each group is returned contiguously.
         ** So set the ASC/DESC flags in the GROUP BY to match those in the
@@ -141367,15 +141365,15 @@
     ** much more complex than aggregates without a GROUP BY.
     */
     if( pGroupBy ){
-      KeyInfo *pKeyInfo = NULL;  /* Keying information for the group by clause */
-      int addr1 = 0;          /* A-vs-B comparision jump */
-      int addrOutputRow = 0;  /* Start of subroutine that outputs a result row */
-      int regOutputRow = 0;   /* Return address register for output subroutine */
-      int addrSetAbort = 0;   /* Set the abort flag and return */
-      int addrTopOfLoop = 0;  /* Top of the input loop */
-      int addrSortingIdx = 0; /* The OP_OpenEphemeral for the sorting index */
-      int addrReset = 0;      /* Subroutine for resetting the accumulator */
-      int regReset = 0;       /* Return address register for reset subroutine */
+      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */
+      int addr1;          /* A-vs-B comparision jump */
+      int addrOutputRow;  /* Start of subroutine that outputs a result row */
+      int regOutputRow;   /* Return address register for output subroutine */
+      int addrSetAbort;   /* Set the abort flag and return */
+      int addrTopOfLoop;  /* Top of the input loop */
+      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */
+      int addrReset;      /* Subroutine for resetting the accumulator */
+      int regReset;       /* Return address register for reset subroutine */
       ExprList *pDistinct = 0;
       u16 distFlag = 0;
       int eDist = WHERE_DISTINCT_NOOP;
@@ -141449,10 +141447,10 @@
         ** then loop over the sorting index in order to get the output
         ** in sorted order
         */
-        int regBase = 0;
-        int regRecord = 0;
-        int nCol = 0;
-        int nGroupBy = 0;
+        int regBase;
+        int regRecord;
+        int nCol;
+        int nGroupBy;
 
         explainTempTable(pParse,
             (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?
@@ -141617,7 +141615,7 @@
       }
     } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */
     else {
-      Table *pTab = NULL;
+      Table *pTab;
       if( (pTab = isSimpleCount(p, pAggInfo))!=0 ){
         /* If isSimpleCount() returns a pointer to a Table structure, then
         ** the SQL statement is of the form:
@@ -141634,7 +141632,7 @@
         */
         const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
         const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */
-        Index *pIdx = NULL;                         /* Iterator variable */
+        Index *pIdx;                         /* Iterator variable */
         KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */
         Index *pBest = 0;                    /* Best index found so far */
         Pgno iRoot = pTab->tnum;             /* Root page of scanned b-tree */
@@ -141680,7 +141678,7 @@
         int regAcc = 0;           /* "populate accumulators" flag */
         ExprList *pDistinct = 0;
         u16 distFlag = 0;
-        int eDist = 0;
+        int eDist;
 
         /* If there are accumulator registers but no min() or max() functions
         ** without FILTER clauses, allocate register regAcc. Register regAcc
@@ -141858,9 +141856,9 @@
 */
 static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
   TabResult *p = (TabResult*)pArg;  /* Result accumulator */
-  int need = 0;                         /* Slots needed in p->azResult[] */
-  int i = 0;                            /* Loop counter */
-  char *z = NULL;                          /* A single column of result */
+  int need;                         /* Slots needed in p->azResult[] */
+  int i;                            /* Loop counter */
+  char *z;                          /* A single column of result */
 
   /* Make sure there is enough space in p->azResult to hold everything
   ** we need to remember from this invocation of the callback.
@@ -141871,7 +141869,7 @@
     need = nCol;
   }
   if( p->nData + need > p->nAlloc ){
-    char **azNew = NULL;
+    char **azNew;
     p->nAlloc = p->nAlloc*2 + need;
     azNew = sqlite3Realloc( p->azResult, sizeof(char*)*p->nAlloc );
     if( azNew==0 ) goto malloc_failed;
@@ -141938,7 +141936,7 @@
   int *pnColumn,              /* Write the number of columns of result here */
   char **pzErrMsg             /* Write error messages here */
 ){
-  int rc = 0;
+  int rc;
   TabResult res;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
@@ -141981,7 +141979,7 @@
     return rc;
   }
   if( res.nAlloc>res.nData ){
-    char **azNew = NULL;
+    char **azNew;
     azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );
     if( azNew==0 ){
       sqlite3_free_table(&res.azResult[1]);
@@ -142003,7 +142001,7 @@
   char **azResult            /* Result returned from sqlite3_get_table() */
 ){
   if( azResult ){
-    int i = 0, n = 0;
+    int i, n;
     azResult--;
     assert( azResult!=0 );
     n = SQLITE_PTR_TO_INT(azResult[0]);
@@ -142066,9 +142064,9 @@
 ** pTab as well as the triggers lised in pTab->pTrigger.
 */
 SQLITE_PRIVATE Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab){
-  Schema *pTmpSchema = NULL;       /* Schema of the pTab table */
-  Trigger *pList = NULL;           /* List of triggers to return */
-  HashElem *p = NULL;              /* Loop variable for TEMP triggers */
+  Schema *pTmpSchema;       /* Schema of the pTab table */
+  Trigger *pList;           /* List of triggers to return */
+  HashElem *p;              /* Loop variable for TEMP triggers */
 
   if( pParse->disableTriggers ){
     return 0;
@@ -142134,11 +142132,11 @@
   int noErr           /* Suppress errors if the trigger already exists */
 ){
   Trigger *pTrigger = 0;  /* The new trigger */
-  Table *pTab = NULL;            /* Table that the trigger fires off of */
+  Table *pTab;            /* Table that the trigger fires off of */
   char *zName = 0;        /* Name of the trigger */
   sqlite3 *db = pParse->db;  /* The database connection */
-  int iDb = 0;                /* The database to store the trigger in */
-  Token *pName = NULL;           /* The unqualified db name */
+  int iDb;                /* The database to store the trigger in */
+  Token *pName;           /* The unqualified db name */
   DbFixer sFix;           /* State vector for the DB fixer */
 
   assert( pName1!=0 );   /* pName1->z might be NULL, but not pName1 itself */
@@ -142334,10 +142332,10 @@
   Token *pAll             /* Token that describes the complete CREATE TRIGGER */
 ){
   Trigger *pTrig = pParse->pNewTrigger;   /* Trigger being finished */
-  char *zName = NULL;                            /* Name of trigger */
+  char *zName;                            /* Name of trigger */
   sqlite3 *db = pParse->db;               /* The database */
   DbFixer sFix;                           /* Fixer object */
-  int iDb = 0;                                /* Database containing the trigger */
+  int iDb;                                /* Database containing the trigger */
   Token nameToken;                        /* Trigger name for error reporting */
 
   pParse->pNewTrigger = 0;
@@ -142369,8 +142367,8 @@
   ** build the sqlite_schema entry
   */
   if( !db->init.busy ){
-    Vdbe *v = NULL;
-    char *z = NULL;
+    Vdbe *v;
+    char *z;
 
     /* Make an entry in the sqlite_schema table */
     v = sqlite3GetVdbe(pParse);
@@ -142398,7 +142396,7 @@
     if( pTrig ){
       sqlite3OomFault(db);
     }else if( pLink->pSchema==pLink->pTabSchema ){
-      Table *pTab = NULL;
+      Table *pTab;
       pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);
       assert( pTab!=0 );
       pLink->pNext = pTab->pTrigger;
@@ -142418,7 +142416,7 @@
 */
 static char *triggerSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){
   char *z = sqlite3DbSpanDup(db, zStart, zEnd);
-  int i = 0;
+  int i;
   if( z ) for(i=0; z[i]; i++) if( sqlite3Isspace(z[i]) ) z[i] = ' ';
   return z;
 }
@@ -142462,7 +142460,7 @@
   const char *zEnd            /* End of SQL text */
 ){
   sqlite3 *db = pParse->db;
-  TriggerStep *pTriggerStep = NULL;
+  TriggerStep *pTriggerStep;
 
   if( pParse->nErr ) return 0;
   pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n + 1);
@@ -142498,7 +142496,7 @@
   const char *zEnd    /* End of SQL text */
 ){
   sqlite3 *db = pParse->db;
-  TriggerStep *pTriggerStep = NULL;
+  TriggerStep *pTriggerStep;
 
   assert(pSelect != 0 || db->mallocFailed);
 
@@ -142543,7 +142541,7 @@
   const char *zEnd     /* End of SQL text */
 ){
   sqlite3 *db = pParse->db;
-  TriggerStep *pTriggerStep = NULL;
+  TriggerStep *pTriggerStep;
 
   pTriggerStep = triggerStepAllocate(pParse, TK_UPDATE, pTableName,zStart,zEnd);
   if( pTriggerStep ){
@@ -142580,7 +142578,7 @@
   const char *zEnd        /* End of SQL text */
 ){
   sqlite3 *db = pParse->db;
-  TriggerStep *pTriggerStep = NULL;
+  TriggerStep *pTriggerStep;
 
   pTriggerStep = triggerStepAllocate(pParse, TK_DELETE, pTableName,zStart,zEnd);
   if( pTriggerStep ){
@@ -142619,9 +142617,9 @@
 **/
 SQLITE_PRIVATE void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){
   Trigger *pTrigger = 0;
-  int i = 0;
-  const char *zDb = NULL;
-  const char *zName = NULL;
+  int i;
+  const char *zDb;
+  const char *zName;
   sqlite3 *db = pParse->db;
 
   if( db->mallocFailed ) goto drop_trigger_cleanup;
@@ -142668,10 +142666,10 @@
 ** Drop a trigger given a pointer to that trigger.
 */
 SQLITE_PRIVATE void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){
-  Table   *pTable = NULL;
-  Vdbe *v = NULL;
+  Table   *pTable;
+  Vdbe *v;
   sqlite3 *db = pParse->db;
-  int iDb = 0;
+  int iDb;
 
   iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
   assert( iDb>=0 && iDb<db->nDb );
@@ -142706,8 +142704,8 @@
 ** Remove a trigger from the hash tables of the sqlite* pointer.
 */
 SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){
-  Trigger *pTrigger = NULL;
-  Hash *pHash = NULL;
+  Trigger *pTrigger;
+  Hash *pHash;
 
   assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
   pHash = &(db->aDb[iDb].pSchema->trigHash);
@@ -142716,7 +142714,7 @@
     if( pTrigger->pSchema==pTrigger->pTabSchema ){
       Table *pTab = tableOfTrigger(pTrigger);
       if( pTab ){
-        Trigger **pp = NULL;
+        Trigger **pp;
         for(pp=&pTab->pTrigger; *pp; pp=&((*pp)->pNext)){
           if( *pp==pTrigger ){
             *pp = (*pp)->pNext;
@@ -142740,7 +142738,7 @@
 ** if there is no match.
 */
 static int checkColumnOverlap(IdList *pIdList, ExprList *pEList){
-  int e = 0;
+  int e;
   if( pIdList==0 || NEVER(pEList==0) ) return 1;
   for(e=0; e<pEList->nExpr; e++){
     if( sqlite3IdListIndex(pIdList, pEList->a[e].zEName)>=0 ) return 1;
@@ -142763,7 +142761,7 @@
 ){
   int mask = 0;
   Trigger *pList = 0;
-  Trigger *p = NULL;
+  Trigger *p;
 
   pList = sqlite3TriggerList(pParse, pTab);
   assert( pList==0 || IsVirtual(pTab)==0
@@ -142833,7 +142831,7 @@
   TriggerStep *pStep   /* The trigger containing the target token */
 ){
   sqlite3 *db = pParse->db;
-  SrcList *pSrc = NULL;                  /* SrcList to be returned */
+  SrcList *pSrc;                  /* SrcList to be returned */
   char *zName = sqlite3DbStrDup(db, pStep->zTarget);
   pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
   assert( pSrc==0 || pSrc->nSrc==1 );
@@ -142886,15 +142884,15 @@
 ){
   ExprList *pNew = 0;
   sqlite3 *db = pParse->db;
-  int i = 0;
+  int i;
 
   for(i=0; i<pList->nExpr; i++){
     Expr *pOldExpr = pList->a[i].pExpr;
     if( NEVER(pOldExpr==0) ) continue;
     if( isAsteriskTerm(pParse, pOldExpr) ){
-      int jj = 0;
+      int jj;
       for(jj=0; jj<pTab->nCol; jj++){
-        Expr *pNewExpr = NULL;
+        Expr *pNewExpr;
         if( IsHiddenColumn(pTab->aCol+jj) ) continue;
         pNewExpr = sqlite3Expr(db, TK_ID, pTab->aCol[jj].zCnName);
         pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
@@ -142930,8 +142928,8 @@
 ){
   Vdbe *v = pParse->pVdbe;
   sqlite3 *db = pParse->db;
-  ExprList *pNew = NULL;
-  Returning *pReturning = NULL;
+  ExprList *pNew;
+  Returning *pReturning;
   Select sSelect;
   SrcList sFrom;
 
@@ -142969,7 +142967,7 @@
     if( sqlite3ResolveExprListNames(&sNC, pNew)==SQLITE_OK
      && ALWAYS(!db->mallocFailed)
     ){
-      int i = 0;
+      int i;
       int nCol = pNew->nExpr;
       int reg = pParse->nMem+1;
       pParse->nMem += nCol+2;
@@ -143003,7 +143001,7 @@
   TriggerStep *pStepList,   /* List of statements inside the trigger body */
   int orconf                /* Conflict algorithm. (OE_Abort, etc) */
 ){
-  TriggerStep *pStep = NULL;
+  TriggerStep *pStep;
   Vdbe *v = pParse->pVdbe;
   sqlite3 *db = pParse->db;
 
@@ -143126,9 +143124,9 @@
 ){
   Parse *pTop = sqlite3ParseToplevel(pParse);
   sqlite3 *db = pParse->db;   /* Database handle */
-  TriggerPrg *pPrg = NULL;           /* Value to return */
+  TriggerPrg *pPrg;           /* Value to return */
   Expr *pWhen = 0;            /* Duplicate of trigger WHEN expression */
-  Vdbe *v = NULL;                    /* Temporary VM */
+  Vdbe *v;                    /* Temporary VM */
   NameContext sNC;            /* Name context for sub-vdbe */
   SubProgram *pProgram = 0;   /* Sub-vdbe for trigger program */
   int iEndTrigger = 0;        /* Label to jump to if WHEN is false */
@@ -143239,7 +143237,7 @@
   int orconf           /* ON CONFLICT algorithm. */
 ){
   Parse *pRoot = sqlite3ParseToplevel(pParse);
-  TriggerPrg *pPrg = NULL;
+  TriggerPrg *pPrg;
 
   assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );
 
@@ -143276,7 +143274,7 @@
   int ignoreJump       /* Instruction to jump to for RAISE(IGNORE) */
 ){
   Vdbe *v = sqlite3GetVdbe(pParse); /* Main VM */
-  TriggerPrg *pPrg = NULL;
+  TriggerPrg *pPrg;
   pPrg = getRowTrigger(pParse, p, pTab, orconf);
   assert( pPrg || pParse->nErr );
 
@@ -143350,7 +143348,7 @@
   int orconf,          /* ON CONFLICT policy */
   int ignoreJump       /* Instruction to jump to for RAISE(IGNORE) */
 ){
-  Trigger *p = NULL;          /* Used to iterate through pTrigger list */
+  Trigger *p;          /* Used to iterate through pTrigger list */
 
   assert( op==TK_UPDATE || op==TK_INSERT || op==TK_DELETE );
   assert( tr_tm==TRIGGER_BEFORE || tr_tm==TRIGGER_AFTER );
@@ -143420,7 +143418,7 @@
 ){
   const int op = pChanges ? TK_UPDATE : TK_DELETE;
   u32 mask = 0;
-  Trigger *p = NULL;
+  Trigger *p;
 
   assert( isNew==1 || isNew==0 );
   for(p=pTrigger; p; p=p->pNext){
@@ -143431,7 +143429,7 @@
       if( p->bReturning ){
         mask = 0xffffffff;
       }else{
-        TriggerPrg *pPrg = NULL;
+        TriggerPrg *pPrg;
         pPrg = getRowTrigger(pParse, p, pTab, orconf);
         if( pPrg ){
           mask |= pPrg->aColmask[isNew];
@@ -143640,7 +143638,7 @@
   ExprList *pOrderBy,             /* ORDER BY clause */
   Expr *pLimit                    /* LIMIT clause */
 ){
-  int i = 0;
+  int i;
   SelectDest dest;
   Select *pSelect = 0;
   ExprList *pList = 0;
@@ -143649,9 +143647,9 @@
   ExprList *pOrderBy2 = 0;
   sqlite3 *db = pParse->db;
   Table *pTab = pTabList->a[0].pTab;
-  SrcList *pSrc = NULL;
-  Expr *pWhere2 = NULL;
-  int eDest = 0;
+  SrcList *pSrc;
+  Expr *pWhere2;
+  int eDest;
 
 #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
   if( pOrderBy && pLimit==0 ) {
@@ -143737,44 +143735,44 @@
   Expr *pLimit,          /* LIMIT clause. May be null */
   Upsert *pUpsert        /* ON CONFLICT clause, or null */
 ){
-  int i = 0, j = 0, k = 0;           /* Loop counters */
-  Table *pTab = NULL;           /* The table to be updated */
+  int i, j, k;           /* Loop counters */
+  Table *pTab;           /* The table to be updated */
   int addrTop = 0;       /* VDBE instruction address of the start of the loop */
   WhereInfo *pWInfo = 0; /* Information about the WHERE clause */
-  Vdbe *v = NULL;               /* The virtual database engine */
-  Index *pIdx = NULL;           /* For looping over indices */
-  Index *pPk = NULL;            /* The PRIMARY KEY index for WITHOUT ROWID tables */
-  int nIdx = 0;              /* Number of indices that need updating */
-  int nAllIdx = 0;           /* Total number of indexes */
-  int iBaseCur = 0;          /* Base cursor number */
-  int iDataCur = 0;          /* Cursor for the canonical data btree */
-  int iIdxCur = 0;           /* Cursor for the first index */
-  sqlite3 *db = NULL;           /* The database structure */
+  Vdbe *v;               /* The virtual database engine */
+  Index *pIdx;           /* For looping over indices */
+  Index *pPk;            /* The PRIMARY KEY index for WITHOUT ROWID tables */
+  int nIdx;              /* Number of indices that need updating */
+  int nAllIdx;           /* Total number of indexes */
+  int iBaseCur;          /* Base cursor number */
+  int iDataCur;          /* Cursor for the canonical data btree */
+  int iIdxCur;           /* Cursor for the first index */
+  sqlite3 *db;           /* The database structure */
   int *aRegIdx = 0;      /* Registers for to each index and the main table */
   int *aXRef = 0;        /* aXRef[i] is the index in pChanges->a[] of the
                          ** an expression for the i-th column of the table.
                          ** aXRef[i]==-1 if the i-th column is not changed. */
-  u8 *aToOpen = NULL;           /* 1 for tables and indices to be opened */
-  u8 chngPk = 0;             /* PRIMARY KEY changed in a WITHOUT ROWID table */
-  u8 chngRowid = 0;          /* Rowid changed in a normal table */
-  u8 chngKey = 0;            /* Either chngPk or chngRowid */
+  u8 *aToOpen;           /* 1 for tables and indices to be opened */
+  u8 chngPk;             /* PRIMARY KEY changed in a WITHOUT ROWID table */
+  u8 chngRowid;          /* Rowid changed in a normal table */
+  u8 chngKey;            /* Either chngPk or chngRowid */
   Expr *pRowidExpr = 0;  /* Expression defining the new record number */
   int iRowidExpr = -1;   /* Index of "rowid=" (or IPK) assignment in pChanges */
   AuthContext sContext;  /* The authorization context */
   NameContext sNC;       /* The name-context to resolve expressions in */
-  int iDb = 0;               /* Database containing the table being updated */
-  int eOnePass = 0;          /* ONEPASS_XXX value from where.c */
-  int hasFK = 0;             /* True if foreign key processing is required */
-  int labelBreak = 0;        /* Jump here to break out of UPDATE loop */
-  int labelContinue = 0;     /* Jump here to continue next step of UPDATE loop */
-  int flags = 0;             /* Flags for sqlite3WhereBegin() */
+  int iDb;               /* Database containing the table being updated */
+  int eOnePass;          /* ONEPASS_XXX value from where.c */
+  int hasFK;             /* True if foreign key processing is required */
+  int labelBreak;        /* Jump here to break out of UPDATE loop */
+  int labelContinue;     /* Jump here to continue next step of UPDATE loop */
+  int flags;             /* Flags for sqlite3WhereBegin() */
 
 #ifndef SQLITE_OMIT_TRIGGER
-  int isView = 0;            /* True when updating a view (INSTEAD OF trigger) */
-  Trigger *pTrigger = NULL;     /* List of triggers on pTab, if required */
-  int tmask = 0;             /* Mask of TRIGGER_BEFORE|TRIGGER_AFTER */
+  int isView;            /* True when updating a view (INSTEAD OF trigger) */
+  Trigger *pTrigger;     /* List of triggers on pTab, if required */
+  int tmask;             /* Mask of TRIGGER_BEFORE|TRIGGER_AFTER */
 #endif
-  int newmask = 0;           /* Mask of NEW.* columns accessed by BEFORE triggers */
+  int newmask;           /* Mask of NEW.* columns accessed by BEFORE triggers */
   int iEph = 0;          /* Ephemeral table holding all primary key values */
   int nKey = 0;          /* Number of elements in regKey for WITHOUT ROWID */
   int aiCurOnePass[2];   /* The write cursors opened by WHERE_ONEPASS */
@@ -143947,7 +143945,7 @@
     }
 #ifndef SQLITE_OMIT_AUTHORIZATION
     {
-      int rc = 0;
+      int rc;
       rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab->zName,
                             j<0 ? "ROWID" : pTab->aCol[j].zCnName,
                             db->aDb[iDb].zDbSName);
@@ -143973,7 +143971,7 @@
   ** obvious when looking at aXRef[] in a symbolic debugger.
   */
   if( pTab->tabFlags & TF_HasGenerated ){
-    int bProgress = 0;
+    int bProgress;
     testcase( pTab->tabFlags & TF_HasVirtual );
     testcase( pTab->tabFlags & TF_HasStored );
     do{
@@ -144008,7 +144006,7 @@
   */
   if( onError==OE_Replace ) bReplace = 1;
   for(nAllIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nAllIdx++){
-    int reg = 0;
+    int reg;
     if( chngKey || hasFK>1 || pIdx==pPk
      || indexWhereClauseMightChange(pIdx,aXRef,chngRowid)
     ){
@@ -144630,19 +144628,19 @@
   int onError          /* ON CONFLICT strategy */
 ){
   Vdbe *v = pParse->pVdbe;  /* Virtual machine under construction */
-  int ephemTab = 0;             /* Table holding the result of the SELECT */
-  int i = 0;                    /* Loop counter */
+  int ephemTab;             /* Table holding the result of the SELECT */
+  int i;                    /* Loop counter */
   sqlite3 *db = pParse->db; /* Database connection */
   const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);
   WhereInfo *pWInfo = 0;
   int nArg = 2 + pTab->nCol;      /* Number of arguments to VUpdate */
-  int regArg = 0;                     /* First register in VUpdate arg array */
-  int regRec = 0;                     /* Register in which to assemble record */
-  int regRowid = 0;                   /* Register for ephem table rowid */
+  int regArg;                     /* First register in VUpdate arg array */
+  int regRec;                     /* Register in which to assemble record */
+  int regRowid;                   /* Register for ephem table rowid */
   int iCsr = pSrc->a[0].iCursor;  /* Cursor used for virtual table scan */
   int aDummy[2];                  /* Unused arg for sqlite3WhereOkOnePass() */
-  int eOnePass = 0;                   /* True to use onepass strategy */
-  int addr = 0;                       /* Address of OP_OpenEphemeral */
+  int eOnePass;                   /* True to use onepass strategy */
+  int addr;                       /* Address of OP_OpenEphemeral */
 
   /* Allocate nArg registers in which to gather the arguments for VUpdate. Then
   ** create and open the ephemeral table in which the records created from
@@ -144654,8 +144652,8 @@
   pParse->nMem += nArg;
   if( pSrc->nSrc>1 ){
     Index *pPk = 0;
-    Expr *pRow = NULL;
-    ExprList *pList = NULL;
+    Expr *pRow;
+    ExprList *pList;
     if( HasRowid(pTab) ){
       if( pRowid ){
         pRow = sqlite3ExprDup(db, pRowid, 0);
@@ -144663,7 +144661,7 @@
         pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);
       }
     }else{
-      i16 iPk = 0;      /* PRIMARY KEY column */
+      i16 iPk;      /* PRIMARY KEY column */
       pPk = sqlite3PrimaryKeyIndex(pTab);
       assert( pPk!=0 );
       assert( pPk->nKeyCol==1 );
@@ -144717,8 +144715,8 @@
         sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);
       }
     }else{
-      Index *pPk = NULL;   /* PRIMARY KEY index */
-      i16 iPk = 0;      /* PRIMARY KEY column */
+      Index *pPk;   /* PRIMARY KEY index */
+      i16 iPk;      /* PRIMARY KEY column */
       pPk = sqlite3PrimaryKeyIndex(pTab);
       assert( pPk!=0 );
       assert( pPk->nKeyCol==1 );
@@ -144849,7 +144847,7 @@
   Expr *pWhere,          /* WHERE clause for the ON CONFLICT UPDATE */
   Upsert *pNext          /* Next ON CONFLICT clause in the list */
 ){
-  Upsert *pNew = NULL;
+  Upsert *pNew;
   pNew = sqlite3DbMallocZero(db, sizeof(Upsert));
   if( pNew==0 ){
     sqlite3ExprListDelete(db, pTarget);
@@ -144881,12 +144879,12 @@
   SrcList *pTabList, /* Table into which we are inserting */
   Upsert *pUpsert    /* The ON CONFLICT clauses */
 ){
-  Table *pTab = NULL;            /* That table into which we are inserting */
-  int rc = 0;                 /* Result code */
-  int iCursor = 0;            /* Cursor used by pTab */
-  Index *pIdx = NULL;            /* One of the indexes of pTab */
-  ExprList *pTarget = NULL;      /* The conflict-target clause */
-  Expr *pTerm = NULL;            /* One term of the conflict-target clause */
+  Table *pTab;            /* That table into which we are inserting */
+  int rc;                 /* Result code */
+  int iCursor;            /* Cursor used by pTab */
+  Index *pIdx;            /* One of the indexes of pTab */
+  ExprList *pTarget;      /* The conflict-target clause */
+  Expr *pTerm;            /* One term of the conflict-target clause */
   NameContext sNC;        /* Context for resolving symbolic names */
   Expr sCol[2];           /* Index column converted into an Expr */
   int nClause = 0;        /* Counter of ON CONFLICT clauses */
@@ -144938,7 +144936,7 @@
 
     /* Check for matches against other indexes */
     for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-      int ii = 0, jj = 0, nn = 0;
+      int ii, jj, nn;
       if( !IsUniqueIndex(pIdx) ) continue;
       if( pTarget->nExpr!=pIdx->nKeyCol ) continue;
       if( pIdx->pPartIdxWhere ){
@@ -144950,7 +144948,7 @@
       }
       nn = pIdx->nKeyCol;
       for(ii=0; ii<nn; ii++){
-        Expr *pExpr = NULL;
+        Expr *pExpr;
         sCol[0].u.zToken = (char*)pIdx->azColl[ii];
         if( pIdx->aiColumn[ii]==XN_EXPR ){
           assert( pIdx->aColExpr!=0 );
@@ -145004,7 +145002,7 @@
 ** clause that targets the INTEGER PRIMARY KEY.
 */
 SQLITE_PRIVATE int sqlite3UpsertNextIsIPK(Upsert *pUpsert){
-  Upsert *pNext = NULL;
+  Upsert *pNext;
   if( NEVER(pUpsert==0) ) return 0;
   pNext = pUpsert->pNextUpsert;
   if( pNext==0 ) return 1;
@@ -145048,9 +145046,9 @@
 ){
   Vdbe *v = pParse->pVdbe;
   sqlite3 *db = pParse->db;
-  SrcList *pSrc = NULL;            /* FROM clause for the UPDATE */
-  int iDataCur = 0;
-  int i = 0;
+  SrcList *pSrc;            /* FROM clause for the UPDATE */
+  int iDataCur;
+  int i;
   Upsert *pTop = pUpsert;
 
   assert( v!=0 );
@@ -145071,7 +145069,7 @@
       int iPk = pParse->nMem+1;
       pParse->nMem += nPk;
       for(i=0; i<nPk; i++){
-        int k = 0;
+        int k;
         assert( pPk->aiColumn[i]>=0 );
         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);
         sqlite3VdbeAddOp3(v, OP_Column, iCur, k, iPk+i);
@@ -145137,8 +145135,8 @@
 ** a format string as its third argument
 */
 static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){
-  sqlite3_stmt *pStmt = NULL;
-  int rc = 0;
+  sqlite3_stmt *pStmt;
+  int rc;
 
   /* printf("SQL: [%s]\n", zSql); fflush(stdout); */
   rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
@@ -145167,9 +145165,9 @@
   return rc;
 }
 static int execSqlF(sqlite3 *db, char **pzErrMsg, const char *zSql, ...){
-  char *z = NULL;
+  char *z;
   va_list ap;
-  int rc = 0;
+  int rc;
   va_start(ap, zSql);
   z = sqlite3VMPrintf(db, zSql, ap);
   va_end(ap);
@@ -145254,20 +145252,20 @@
   sqlite3_value *pOut     /* Write results here, if not NULL. VACUUM INTO */
 ){
   int rc = SQLITE_OK;     /* Return code from service routines */
-  Btree *pMain = NULL;           /* The database being vacuumed */
-  Btree *pTemp = NULL;           /* The temporary database we vacuum into */
-  u32 saved_mDbFlags = 0;     /* Saved value of db->mDbFlags */
-  u64 saved_flags = 0;        /* Saved value of db->flags */
-  i64 saved_nChange = 0;      /* Saved value of db->nChange */
-  i64 saved_nTotalChange = 0; /* Saved value of db->nTotalChange */
-  u32 saved_openFlags = 0;    /* Saved value of db->openFlags */
-  u8 saved_mTrace = 0;        /* Saved trace settings */
+  Btree *pMain;           /* The database being vacuumed */
+  Btree *pTemp;           /* The temporary database we vacuum into */
+  u32 saved_mDbFlags;     /* Saved value of db->mDbFlags */
+  u64 saved_flags;        /* Saved value of db->flags */
+  i64 saved_nChange;      /* Saved value of db->nChange */
+  i64 saved_nTotalChange; /* Saved value of db->nTotalChange */
+  u32 saved_openFlags;    /* Saved value of db->openFlags */
+  u8 saved_mTrace;        /* Saved trace settings */
   Db *pDb = 0;            /* Database to detach at end of vacuum */
-  int isMemDb = 0;            /* True if vacuuming a :memory: database */
-  int nRes = 0;               /* Bytes of reserved space at the end of each page */
-  int nDb = 0;                /* Number of attached databases */
-  const char *zDbMain = NULL;    /* Schema name of database to vacuum */
-  const char *zOut = NULL;       /* Name of output file */
+  int isMemDb;            /* True if vacuuming a :memory: database */
+  int nRes;               /* Bytes of reserved space at the end of each page */
+  int nDb;                /* Number of attached databases */
+  const char *zDbMain;    /* Schema name of database to vacuum */
+  const char *zOut;       /* Name of output file */
 
   if( !db->autoCommit ){
     sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
@@ -145431,8 +145429,8 @@
   ** call to sqlite3BtreeCommit().
   */
   {
-    u32 meta = 0;
-    int i = 0;
+    u32 meta;
+    int i;
 
     /* This array determines which meta meta values are preserved in the
     ** vacuum.  Even entries are the meta value number and odd entries
@@ -145559,9 +145557,9 @@
   void *pAux,                     /* Context pointer for xCreate/xConnect */
   void (*xDestroy)(void *)        /* Module destructor function */
 ){
-  Module *pMod = NULL;
-  Module *pDel = NULL;
-  char *zCopy = NULL;
+  Module *pMod;
+  Module *pDel;
+  char *zCopy;
   if( pModule==0 ){
     zCopy = (char*)zName;
     pMod = 0;
@@ -145654,7 +145652,7 @@
 ** on the azNames list.
 */
 SQLITE_API int sqlite3_drop_modules(sqlite3 *db, const char** azNames){
-  HashElem *pThis = NULL, *pNext = NULL;
+  HashElem *pThis, *pNext;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
 #endif
@@ -145662,7 +145660,7 @@
     Module *pMod = (Module*)sqliteHashData(pThis);
     pNext = sqliteHashNext(pThis);
     if( azNames ){
-      int ii = 0;
+      int ii;
       for(ii=0; azNames[ii]!=0 && strcmp(azNames[ii],pMod->zName)!=0; ii++){}
       if( azNames[ii]!=0 ) continue;
     }
@@ -145706,7 +145704,7 @@
 ** this virtual-table, if one has been created, or NULL otherwise.
 */
 SQLITE_PRIVATE VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){
-  VTable *pVtab = NULL;
+  VTable *pVtab;
   assert( IsVirtual(pTab) );
   for(pVtab=pTab->u.vtab.p; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);
   return pVtab;
@@ -145744,7 +145742,7 @@
 */
 static VTable *vtabDisconnectAll(sqlite3 *db, Table *p){
   VTable *pRet = 0;
-  VTable *pVTable = NULL;
+  VTable *pVTable;
 
   assert( IsVirtual(p) );
   pVTable = p->u.vtab.p;
@@ -145786,7 +145784,7 @@
 ** be being used by other shared-cache connections).
 */
 SQLITE_PRIVATE void sqlite3VtabDisconnect(sqlite3 *db, Table *p){
-  VTable **ppVTab = NULL;
+  VTable **ppVTab;
 
   assert( IsVirtual(p) );
   assert( sqlite3BtreeHoldsAllMutexes(db) );
@@ -145858,7 +145856,7 @@
   assert( IsVirtual(p) );
   if( !db || db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);
   if( p->u.vtab.azArg ){
-    int i = 0;
+    int i;
     for(i=0; i<p->u.vtab.nArg; i++){
       if( i!=1 ) sqlite3DbFree(db, p->u.vtab.azArg[i]);
     }
@@ -145873,8 +145871,8 @@
 ** deleted.
 */
 static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){
-  sqlite3_int64 nBytes = 0;
-  char **azModuleArg = NULL;
+  sqlite3_int64 nBytes;
+  char **azModuleArg;
   sqlite3 *db = pParse->db;
 
   assert( IsVirtual(pTable) );
@@ -145905,8 +145903,8 @@
   Token *pModuleName,   /* Name of the module for the virtual table */
   int ifNotExists       /* No error if the table already exists */
 ){
-  Table *pTable = NULL;        /* The new virtual table */
-  sqlite3 *db = NULL;          /* Database connection */
+  Table *pTable;        /* The new virtual table */
+  sqlite3 *db;          /* Database connection */
 
   sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);
   pTable = pParse->pNewTable;
@@ -145977,11 +145975,11 @@
   ** in the sqlite_schema table.
   */
   if( !db->init.busy ){
-    char *zStmt = NULL;
-    char *zWhere = NULL;
-    int iDb = 0;
-    int iReg = 0;
-    Vdbe *v = NULL;
+    char *zStmt;
+    char *zWhere;
+    int iDb;
+    int iReg;
+    Vdbe *v;
 
     sqlite3MayAbort(pParse);
 
@@ -146024,7 +146022,7 @@
   }else{
     /* If we are rereading the sqlite_schema table create the in-memory
     ** record of the table. */
-    Table *pOld = NULL;
+    Table *pOld;
     Schema *pSchema = pTab->pSchema;
     const char *zName = pTab->zName;
     assert( zName!=0 );
@@ -146077,14 +146075,14 @@
   char **pzErr
 ){
   VtabCtx sCtx;
-  VTable *pVTable = NULL;
-  int rc = 0;
-  const char *const*azArg = NULL;
+  VTable *pVTable;
+  int rc;
+  const char *const*azArg;
   int nArg = pTab->u.vtab.nArg;
   char *zErr = 0;
-  char *zModuleName = NULL;
-  int iDb = 0;
-  VtabCtx *pCtx = NULL;
+  char *zModuleName;
+  int iDb;
+  VtabCtx *pCtx;
 
   assert( IsVirtual(pTab) );
   azArg = (const char *const*)pTab->u.vtab.azArg;
@@ -146151,7 +146149,7 @@
       sqlite3VtabUnlock(pVTable);
       rc = SQLITE_ERROR;
     }else{
-      int iCol = 0;
+      int iCol;
       u16 oooHidden = 0;
       /* If everything went according to plan, link the new VTable structure
       ** into the linked list headed by pTab->u.vtab.p. Then loop through the
@@ -146163,7 +146161,7 @@
 
       for(iCol=0; iCol<pTab->nCol; iCol++){
         char *zType = sqlite3ColumnType(&pTab->aCol[iCol], "");
-        int nType = 0;
+        int nType;
         int i = 0;
         nType = sqlite3Strlen30(zType);
         for(i=0; i<nType; i++){
@@ -146175,7 +146173,7 @@
           }
         }
         if( i<nType ){
-          int j = 0;
+          int j;
           int nDel = 6 + (zType[i+6] ? 1 : 0);
           for(j=i; (j+nDel)<=nType; j++){
             zType[j] = zType[j+nDel];
@@ -146207,9 +146205,9 @@
 */
 SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){
   sqlite3 *db = pParse->db;
-  const char *zMod = NULL;
-  Module *pMod = NULL;
-  int rc = 0;
+  const char *zMod;
+  Module *pMod;
+  int rc;
 
   assert( pTab );
   assert( IsVirtual(pTab) );
@@ -146246,7 +146244,7 @@
 
   /* Grow the sqlite3.aVTrans array if required */
   if( (db->nVTrans%ARRAY_INCR)==0 ){
-    VTable **aVTrans = NULL;
+    VTable **aVTrans;
     sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*
                                  ((sqlite3_int64)db->nVTrans + ARRAY_INCR);
     aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);
@@ -146280,9 +146278,9 @@
 */
 SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){
   int rc = SQLITE_OK;
-  Table *pTab = NULL;
-  Module *pMod = NULL;
-  const char *zMod = NULL;
+  Table *pTab;
+  Module *pMod;
+  const char *zMod;
 
   pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
   assert( pTab && IsVirtual(pTab) && !pTab->u.vtab.p );
@@ -146320,11 +146318,11 @@
 ** virtual table module.
 */
 SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){
-  VtabCtx *pCtx = NULL;
+  VtabCtx *pCtx;
   int rc = SQLITE_OK;
-  Table *pTab = NULL;
+  Table *pTab;
   Parse sParse;
-  int initBusy = 0;
+  int initBusy;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) || zCreateTable==0 ){
@@ -146359,7 +146357,7 @@
     assert( sParse.zErrMsg==0 );
     if( !pTab->aCol ){
       Table *pNew = sParse.pNewTable;
-      Index *pIdx = NULL;
+      Index *pIdx;
       pTab->aCol = pNew->aCol;
       sqlite3ExprListDelete(db, pNew->u.tab.pDfltList);
       pTab->nNVCol = pTab->nCol = pNew->nCol;
@@ -146415,15 +146413,15 @@
 */
 SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){
   int rc = SQLITE_OK;
-  Table *pTab = NULL;
+  Table *pTab;
 
   pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
   if( ALWAYS(pTab!=0)
    && ALWAYS(IsVirtual(pTab))
    && ALWAYS(pTab->u.vtab.p!=0)
   ){
-    VTable *p = NULL;
-    int (*xDestroy = 0)(sqlite3_vtab *);
+    VTable *p;
+    int (*xDestroy)(sqlite3_vtab *);
     for(p=pTab->u.vtab.p; p; p=p->pNext){
       assert( p->pVtab );
       if( p->pVtab->nRef>0 ){
@@ -146458,7 +146456,7 @@
 ** The array is cleared after invoking the callbacks.
 */
 static void callFinaliser(sqlite3 *db, int offset){
-  int i = 0;
+  int i;
   if( db->aVTrans ){
     VTable **aVTrans = db->aVTrans;
     db->aVTrans = 0;
@@ -146466,7 +146464,7 @@
       VTable *pVTab = aVTrans[i];
       sqlite3_vtab *p = pVTab->pVtab;
       if( p ){
-        int (*x = 0)(sqlite3_vtab *);
+        int (*x)(sqlite3_vtab *);
         x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);
         if( x ) x(p);
       }
@@ -146486,13 +146484,13 @@
 ** If an error message is available, leave it in p->zErrMsg.
 */
 SQLITE_PRIVATE int sqlite3VtabSync(sqlite3 *db, Vdbe *p){
-  int i = 0;
+  int i;
   int rc = SQLITE_OK;
   VTable **aVTrans = db->aVTrans;
 
   db->aVTrans = 0;
   for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){
-    int (*x = 0)(sqlite3_vtab *);
+    int (*x)(sqlite3_vtab *);
     sqlite3_vtab *pVtab = aVTrans[i]->pVtab;
     if( pVtab && (x = pVtab->pModule->xSync)!=0 ){
       rc = x(pVtab);
@@ -146531,7 +146529,7 @@
 */
 SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){
   int rc = SQLITE_OK;
-  const sqlite3_module *pModule = NULL;
+  const sqlite3_module *pModule;
 
   /* Special case: If db->aVTrans is NULL and db->nVTrans is greater
   ** than zero, then this function is being called from within a
@@ -146547,7 +146545,7 @@
   pModule = pVTab->pVtab->pModule;
 
   if( pModule->xBegin ){
-    int i = 0;
+    int i;
 
     /* If pVtab is already in the aVTrans array, return early */
     for(i=0; i<db->nVTrans; i++){
@@ -146595,12 +146593,12 @@
   assert( op==SAVEPOINT_RELEASE||op==SAVEPOINT_ROLLBACK||op==SAVEPOINT_BEGIN );
   assert( iSavepoint>=-1 );
   if( db->aVTrans ){
-    int i = 0;
+    int i;
     for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){
       VTable *pVTab = db->aVTrans[i];
       const sqlite3_module *pMod = pVTab->pMod->pModule;
       if( pVTab->pVtab && pMod->iVersion>=2 ){
-        int (*xMethod = 0)(sqlite3_vtab *, int);
+        int (*xMethod)(sqlite3_vtab *, int);
         sqlite3VtabLock(pVTab);
         switch( op ){
           case SAVEPOINT_BEGIN:
@@ -146643,12 +146641,12 @@
   int nArg,       /* Number of arguments to the function */
   Expr *pExpr     /* First argument to the function */
 ){
-  Table *pTab = NULL;
-  sqlite3_vtab *pVtab = NULL;
-  sqlite3_module *pMod = NULL;
+  Table *pTab;
+  sqlite3_vtab *pVtab;
+  sqlite3_module *pMod;
   void (*xSFunc)(sqlite3_context*,int,sqlite3_value**) = 0;
   void *pArg = 0;
-  FuncDef *pNew = NULL;
+  FuncDef *pNew;
   int rc = 0;
 
   /* Check to see the left operand is a column in a virtual table */
@@ -146709,8 +146707,8 @@
 */
 SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){
   Parse *pToplevel = sqlite3ParseToplevel(pParse);
-  int i = 0, n = 0;
-  Table **apVtabLock = NULL;
+  int i, n;
+  Table **apVtabLock;
 
   assert( IsVirtual(pTab) );
   for(i=0; i<pToplevel->nVtabLock; i++){
@@ -146743,9 +146741,9 @@
 */
 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){
   const sqlite3_module *pModule = pMod->pModule;
-  Table *pTab = NULL;
+  Table *pTab;
   char *zErr = 0;
-  int rc = 0;
+  int rc;
   sqlite3 *db = pParse->db;
   if( pMod->pEpoTab ) return 1;
   if( pModule->xCreate!=0 && pModule->xCreate!=pModule->xConnect ) return 0;
@@ -146819,7 +146817,7 @@
 SQLITE_API int sqlite3_vtab_config(sqlite3 *db, int op, ...){
   va_list ap;
   int rc = SQLITE_OK;
-  VtabCtx *p = NULL;
+  VtabCtx *p;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
@@ -147535,7 +147533,7 @@
   int bAnd,                   /* Non-zero to append " AND " */
   const char *zOp             /* Name of the operator */
 ){
-  int i = 0;
+  int i;
 
   assert( nTerm>=1 );
   if( bAnd ) sqlite3_str_append(pStr, " AND ", 5);
@@ -147575,7 +147573,7 @@
   Index *pIndex = pLoop->u.btree.pIndex;
   u16 nEq = pLoop->u.btree.nEq;
   u16 nSkip = pLoop->nSkip;
-  int i = 0, j = 0;
+  int i, j;
 
   if( nEq==0 && (pLoop->wsFlags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))==0 ) return;
   sqlite3_str_append(pStr, " (", 2);
@@ -147619,10 +147617,10 @@
     SrcItem *pItem = &pTabList->a[pLevel->iFrom];
     Vdbe *v = pParse->pVdbe;      /* VM being constructed */
     sqlite3 *db = pParse->db;     /* Database handle */
-    int isSearch = 0;                 /* True for a SEARCH. False for SCAN. */
-    WhereLoop *pLoop = NULL;             /* The controlling WhereLoop object */
-    u32 flags = 0;                    /* Flags that describe this loop */
-    char *zMsg = NULL;                   /* Text to add to EQP output */
+    int isSearch;                 /* True for a SEARCH. False for SCAN. */
+    WhereLoop *pLoop;             /* The controlling WhereLoop object */
+    u32 flags;                    /* Flags that describe this loop */
+    char *zMsg;                   /* Text to add to EQP output */
     StrAccum str;                 /* EQP output string */
     char zBuf[100];               /* Initial space for EQP output string */
 
@@ -147639,7 +147637,7 @@
     sqlite3_str_appendf(&str, "%s %S", isSearch ? "SEARCH" : "SCAN", pItem);
     if( (flags & (WHERE_IPK|WHERE_VIRTUALTABLE))==0 ){
       const char *zFmt = 0;
-      Index *pIdx = NULL;
+      Index *pIdx;
 
       assert( pLoop->u.btree.pIndex!=0 );
       pIdx = pLoop->u.btree.pIndex;
@@ -147663,7 +147661,7 @@
         explainIndexRange(&str, pLoop);
       }
     }else if( (flags & WHERE_IPK)!=0 && (flags & WHERE_CONSTRAINT)!=0 ){
-      char cRangeOp = 0;
+      char cRangeOp;
 #if 0  /* Better output, but breaks many tests */
       const Table *pTab = pItem->pTab;
       const char *zRowid = pTab->iPKey>=0 ? pTab->aCol[pTab->iPKey].zCnName:
@@ -147726,9 +147724,9 @@
   SrcItem *pItem = &pWInfo->pTabList->a[pLevel->iFrom];
   Vdbe *v = pParse->pVdbe;      /* VM being constructed */
   sqlite3 *db = pParse->db;     /* Database handle */
-  char *zMsg = NULL;                   /* Text to add to EQP output */
-  int i = 0;                        /* Loop counter */
-  WhereLoop *pLoop = NULL;             /* The where loop */
+  char *zMsg;                   /* Text to add to EQP output */
+  int i;                        /* Loop counter */
+  WhereLoop *pLoop;             /* The where loop */
   StrAccum str;                 /* EQP output string */
   char zBuf[100];               /* Initial space for EQP output string */
 
@@ -147910,7 +147908,7 @@
   int n,                          /* Number of vector elements in comparison */
   char *zAff                      /* Affinity string to modify */
 ){
-  int i = 0;
+  int i;
   for(i=0; i<n; i++){
     Expr *p = sqlite3VectorFieldSubexpr(pRight, i);
     if( sqlite3CompareAffinity(p, zAff[i])==SQLITE_AFF_BLOB
@@ -147958,15 +147956,15 @@
   Expr *pX              /* The IN expression to be reduced */
 ){
   sqlite3 *db = pParse->db;
-  Expr *pNew = NULL;
+  Expr *pNew;
   pNew = sqlite3ExprDup(db, pX, 0);
   if( db->mallocFailed==0 ){
-    ExprList *pOrigRhs = NULL;         /* Original unmodified RHS */
-    ExprList *pOrigLhs = NULL;         /* Original unmodified LHS */
+    ExprList *pOrigRhs;         /* Original unmodified RHS */
+    ExprList *pOrigLhs;         /* Original unmodified LHS */
     ExprList *pRhs = 0;         /* New RHS after modifications */
     ExprList *pLhs = 0;         /* New LHS after mods */
-    int i = 0;                      /* Loop counter */
-    Select *pSelect = NULL;            /* Pointer to the SELECT on the RHS */
+    int i;                      /* Loop counter */
+    Select *pSelect;            /* Pointer to the SELECT on the RHS */
 
     assert( ExprUseXSelect(pNew) );
     pOrigRhs = pNew->x.pSelect->pEList;
@@ -147975,7 +147973,7 @@
     pOrigLhs = pNew->pLeft->x.pList;
     for(i=iEq; i<pLoop->nLTerm; i++){
       if( pLoop->aLTerm[i]->pExpr==pX ){
-        int iField = 0;
+        int iField;
         assert( (pLoop->aLTerm[i]->eOperator & (WO_OR|WO_AND))==0 );
         iField = pLoop->aLTerm[i]->u.x.iField - 1;
         if( pOrigRhs->a[iField].pExpr==0 ) continue; /* Duplicate PK column */
@@ -148050,7 +148048,7 @@
 ){
   Expr *pX = pTerm->pExpr;
   Vdbe *v = pParse->pVdbe;
-  int iReg = 0;                  /* Register holding results */
+  int iReg;                  /* Register holding results */
 
   assert( pLevel->pWLoop->aLTerm[iEq]==pTerm );
   assert( iTarget>0 );
@@ -148062,10 +148060,10 @@
 #ifndef SQLITE_OMIT_SUBQUERY
   }else{
     int eType = IN_INDEX_NOOP;
-    int iTab = 0;
-    struct InLoop *pIn = NULL;
+    int iTab;
+    struct InLoop *pIn;
     WhereLoop *pLoop = pLevel->pWLoop;
-    int i = 0;
+    int i;
     int nEq = 0;
     int *aiMap = 0;
 
@@ -148243,16 +148241,16 @@
   int nExtraReg,        /* Number of extra registers to allocate */
   char **pzAff          /* OUT: Set to point to affinity string */
 ){
-  u16 nEq = 0;                      /* The number of == or IN constraints to code */
-  u16 nSkip = 0;                    /* Number of left-most columns to skip */
+  u16 nEq;                      /* The number of == or IN constraints to code */
+  u16 nSkip;                    /* Number of left-most columns to skip */
   Vdbe *v = pParse->pVdbe;      /* The vm under construction */
-  Index *pIdx = NULL;                  /* The index being used for this loop */
-  WhereTerm *pTerm = NULL;             /* A single constraint term */
-  WhereLoop *pLoop = NULL;             /* The WhereLoop object */
-  int j = 0;                        /* Loop counter */
-  int regBase = 0;                  /* Base register */
-  int nReg = 0;                     /* Number of registers to allocate */
-  char *zAff = NULL;                   /* Affinity string to return */
+  Index *pIdx;                  /* The index being used for this loop */
+  WhereTerm *pTerm;             /* A single constraint term */
+  WhereLoop *pLoop;             /* The WhereLoop object */
+  int j;                        /* Loop counter */
+  int regBase;                  /* Base register */
+  int nReg;                     /* Number of registers to allocate */
+  char *zAff;                   /* Affinity string to return */
 
   /* This module is only called on query plans that use an index. */
   pLoop = pLevel->pWLoop;
@@ -148296,7 +148294,7 @@
   */
   assert( zAff==0 || (int)strlen(zAff)>=nEq );
   for(j=nSkip; j<nEq; j++){
-    int r1 = 0;
+    int r1;
     pTerm = pLoop->aLTerm[j];
     assert( pTerm!=0 );
     /* The following testcase is true for indices with redundant columns.
@@ -148368,7 +148366,7 @@
   WhereTerm *pTerm        /* The upper or lower bound just coded */
 ){
   if( pTerm->wtFlags & TERM_LIKEOPT ){
-    VdbeOp *pOp = NULL;
+    VdbeOp *pOp;
     assert( pLevel->iLikeRepCntr>0 );
     pOp = sqlite3VdbeGetOp(v, -1);
     assert( pOp!=0 );
@@ -148631,13 +148629,13 @@
   if( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)
    && DbMaskAllZero(sqlite3ParseToplevel(pParse)->writeMask)
   ){
-    int i = 0;
+    int i;
     Table *pTab = pIdx->pTable;
     u32 *ai = (u32*)sqlite3DbMallocZero(pParse->db, sizeof(u32)*(pTab->nCol+1));
     if( ai ){
       ai[0] = pTab->nCol;
       for(i=0; i<pIdx->nColumn-1; i++){
-        int x1 = 0, x2 = 0;
+        int x1, x2;
         assert( pIdx->aiColumn[i]<pTab->nCol );
         x1 = pIdx->aiColumn[i];
         x2 = sqlite3TableColumnToStorage(pTab, x1);
@@ -148664,15 +148662,15 @@
 #ifndef SQLITE_OMIT_SUBQUERY
     if( ExprUseXSelect(p) ){
       Vdbe *v = pParse->pVdbe;
-      int iSelect = 0;
+      int iSelect;
       assert( p->op==TK_SELECT );
       iSelect = sqlite3CodeSubselect(pParse, p);
       sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);
     }else
 #endif
     {
-      int i = 0;
-      const ExprList *pList = NULL;
+      int i;
+      const ExprList *pList;
       assert( ExprUseXList(p) );
       pList = p->x.pList;
       assert( nReg<=pList->nExpr );
@@ -148704,7 +148702,7 @@
 ** Preserve pExpr on the WhereETrans list of the WhereInfo.
 */
 static void preserveExpr(IdxExprTrans *pTrans, Expr *pExpr){
-  WhereExprMod *pNew = NULL;
+  WhereExprMod *pNew;
   pNew = sqlite3DbMallocRaw(pTrans->db, sizeof(*pNew));
   if( pNew==0 ) return;
   pNew->pNext = pTrans->pWInfo->pExprMods;
@@ -148773,9 +148771,9 @@
   int iIdxCur,      /* Cursor of the index itself */
   WhereInfo *pWInfo /* Transform expressions in this WHERE clause */
 ){
-  int iIdxCol = 0;               /* Column number of the index */
-  ExprList *aColExpr = NULL;        /* Expressions that are indexed */
-  Table *pTab = NULL;
+  int iIdxCol;               /* Column number of the index */
+  ExprList *aColExpr;        /* Expressions that are indexed */
+  Table *pTab;
   Walker w;
   IdxExprTrans x;
   aColExpr = pIdx->aColExpr;
@@ -148836,14 +148834,14 @@
   int iTabCur,
   WhereClause *pWC
 ){
-  int i = 0;
-  WhereTerm *pTerm = NULL;
+  int i;
+  WhereTerm *pTerm;
   while( pTruth->op==TK_AND ){
     whereApplyPartialIndexConstraints(pTruth->pLeft, iTabCur, pWC);
     pTruth = pTruth->pRight;
   }
   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
-    Expr *pExpr = NULL;
+    Expr *pExpr;
     if( pTerm->wtFlags & TERM_CODED ) continue;
     pExpr = pTerm->pExpr;
     if( sqlite3ExprCompare(0, pExpr, pTruth, iTabCur)==0 ){
@@ -148886,7 +148884,7 @@
     pLevel->addrBrk = addrNxt;
     if( pLoop->wsFlags & WHERE_IPK ){
       WhereTerm *pTerm = pLoop->aLTerm[0];
-      int regRowid = 0;
+      int regRowid;
       assert( pTerm!=0 );
       assert( pTerm->pExpr!=0 );
       testcase( pTerm->wtFlags & TERM_VIRTUAL );
@@ -148897,8 +148895,8 @@
       VdbeCoverage(pParse->pVdbe);
     }else{
       u16 nEq = pLoop->u.btree.nEq;
-      int r1 = 0;
-      char *zStartAff = NULL;
+      int r1;
+      char *zStartAff;
 
       assert( pLoop->wsFlags & WHERE_INDEXED );
       assert( (pLoop->wsFlags & WHERE_COLUMN_IN)==0 );
@@ -148926,22 +148924,22 @@
   WhereLevel *pLevel,  /* The current level pointer */
   Bitmask notReady     /* Which tables are currently available */
 ){
-  int j = 0, k = 0;            /* Loop counters */
-  int iCur = 0;            /* The VDBE cursor for the table */
-  int addrNxt = 0;         /* Where to jump to continue with the next IN case */
-  int bRev = 0;            /* True if we need to scan in reverse order */
-  WhereLoop *pLoop = NULL;    /* The WhereLoop object being coded */
-  WhereClause *pWC = NULL;    /* Decomposition of the entire WHERE clause */
-  WhereTerm *pTerm = NULL;               /* A WHERE clause term */
-  sqlite3 *db = NULL;                    /* Database connection */
-  SrcItem *pTabItem = NULL;              /* FROM clause term being coded */
-  int addrBrk = 0;                    /* Jump here to break out of the loop */
-  int addrHalt = 0;                   /* addrBrk for the outermost loop */
-  int addrCont = 0;                   /* Jump here to continue with next cycle */
+  int j, k;            /* Loop counters */
+  int iCur;            /* The VDBE cursor for the table */
+  int addrNxt;         /* Where to jump to continue with the next IN case */
+  int bRev;            /* True if we need to scan in reverse order */
+  WhereLoop *pLoop;    /* The WhereLoop object being coded */
+  WhereClause *pWC;    /* Decomposition of the entire WHERE clause */
+  WhereTerm *pTerm;               /* A WHERE clause term */
+  sqlite3 *db;                    /* Database connection */
+  SrcItem *pTabItem;              /* FROM clause term being coded */
+  int addrBrk;                    /* Jump here to break out of the loop */
+  int addrHalt;                   /* addrBrk for the outermost loop */
+  int addrCont;                   /* Jump here to continue with next cycle */
   int iRowidReg = 0;        /* Rowid is stored in this register, if not zero */
   int iReleaseReg = 0;      /* Temp register to free before returning */
   Index *pIdx = 0;          /* Index used by loop (if any) */
-  int iLoop = 0;                /* Iteration of constraint generator loop */
+  int iLoop;                /* Iteration of constraint generator loop */
 
   pWC = &pWInfo->sWC;
   db = pParse->db;
@@ -149013,8 +149011,8 @@
     /* Case 1:  The table is a virtual-table.  Use the VFilter and VNext
     **          to access the data.
     */
-    int iReg = 0;   /* P3 Value for OP_VFilter */
-    int addrNotFound = 0;
+    int iReg;   /* P3 Value for OP_VFilter */
+    int addrNotFound;
     int nConstraint = pLoop->nLTerm;
 
     iReg = sqlite3GetTempRange(pParse, nConstraint+2);
@@ -149072,10 +149070,10 @@
        && (SMASKBIT32(j) & pLoop->u.vtab.mHandleIn)==0
        && !db->mallocFailed
       ){
-        Expr *pCompare = NULL;  /* The comparison operator */
-        Expr *pRight = NULL;    /* RHS of the comparison */
-        VdbeOp *pOp = NULL;     /* Opcode to access the value of the IN constraint */
-        int iIn = 0;         /* IN loop corresponding to the j-th constraint */
+        Expr *pCompare;  /* The comparison operator */
+        Expr *pRight;    /* RHS of the comparison */
+        VdbeOp *pOp;     /* Opcode to access the value of the IN constraint */
+        int iIn;         /* IN loop corresponding to the j-th constraint */
 
         /* Reload the constraint value into reg[iReg+j+2].  The same value
         ** was loaded into the same register prior to the OP_VFilter, but
@@ -149164,9 +149162,9 @@
     /* Case 3:  We have an inequality comparison against the ROWID field.
     */
     int testOp = OP_Noop;
-    int start = 0;
+    int start;
     int memEndValue = 0;
-    WhereTerm *pStart = NULL, *pEnd = NULL;
+    WhereTerm *pStart, *pEnd;
 
     j = 0;
     pStart = pEnd = 0;
@@ -149180,9 +149178,9 @@
     }
     codeCursorHint(pTabItem, pWInfo, pLevel, pEnd);
     if( pStart ){
-      Expr *pX = NULL;             /* The expression that defines the start bound */
-      int r1 = 0, rTemp = 0;        /* Registers for holding the start boundary */
-      int op = 0;               /* Cursor seek operation */
+      Expr *pX;             /* The expression that defines the start bound */
+      int r1, rTemp;        /* Registers for holding the start boundary */
+      int op;               /* Cursor seek operation */
 
       /* The following constant maps TK_xx codes into corresponding
       ** seek opcodes.  It depends on a particular ordering of TK_xx
@@ -149232,7 +149230,7 @@
       VdbeCoverageIf(v, bRev!=0);
     }
     if( pEnd ){
-      Expr *pX = NULL;
+      Expr *pX;
       pX = pEnd->pExpr;
       assert( pX!=0 );
       assert( (pEnd->wtFlags & TERM_VNULL)==0 );
@@ -149317,21 +149315,21 @@
     u16 nEq = pLoop->u.btree.nEq;     /* Number of == or IN terms */
     u16 nBtm = pLoop->u.btree.nBtm;   /* Length of BTM vector */
     u16 nTop = pLoop->u.btree.nTop;   /* Length of TOP vector */
-    int regBase = 0;                 /* Base register holding constraint values */
+    int regBase;                 /* Base register holding constraint values */
     WhereTerm *pRangeStart = 0;  /* Inequality constraint at range start */
     WhereTerm *pRangeEnd = 0;    /* Inequality constraint at range end */
-    int startEq = 0;                 /* True if range start uses ==, >= or <= */
-    int endEq = 0;                   /* True if range end uses ==, >= or <= */
-    int start_constraints = 0;       /* Start of range is constrained */
-    int nConstraint = 0;             /* Number of constraint terms */
-    int iIdxCur = 0;                 /* The VDBE cursor for the index */
+    int startEq;                 /* True if range start uses ==, >= or <= */
+    int endEq;                   /* True if range end uses ==, >= or <= */
+    int start_constraints;       /* Start of range is constrained */
+    int nConstraint;             /* Number of constraint terms */
+    int iIdxCur;                 /* The VDBE cursor for the index */
     int nExtraReg = 0;           /* Number of extra registers needed */
-    int op = 0;                      /* Instruction opcode */
-    char *zStartAff = NULL;             /* Affinity for start of range constraint */
+    int op;                      /* Instruction opcode */
+    char *zStartAff;             /* Affinity for start of range constraint */
     char *zEndAff = 0;           /* Affinity for end of range constraint */
     u8 bSeekPastNull = 0;        /* True to seek past initial nulls */
     u8 bStopAtNull = 0;          /* Add condition to terminate at NULLs */
-    int omitTable = 0;               /* True if we use the index only */
+    int omitTable;               /* True if we use the index only */
     int regBignull = 0;          /* big-null flag register */
     int addrSeekScan = 0;        /* Opcode of the OP_SeekScan, if any */
 
@@ -149741,8 +149739,8 @@
     ** keys of the rows we have already seen.
     **
     */
-    WhereClause *pOrWc = NULL;    /* The OR-clause broken out into subterms */
-    SrcList *pOrTab = NULL;       /* Shortened table list or OR-clause generation */
+    WhereClause *pOrWc;    /* The OR-clause broken out into subterms */
+    SrcList *pOrTab;       /* Shortened table list or OR-clause generation */
     Index *pCov = 0;             /* Potential covering index (or NULL) */
     int iCovCur = pParse->nTab++;  /* Cursor used for index scans (if any) */
 
@@ -149750,9 +149748,9 @@
     int regRowset = 0;                        /* Register for RowSet object */
     int regRowid = 0;                         /* Register holding rowid */
     int iLoopBody = sqlite3VdbeMakeLabel(pParse);/* Start of loop body */
-    int iRetInit = 0;                             /* Address of regReturn init */
+    int iRetInit;                             /* Address of regReturn init */
     int untestedTerms = 0;             /* Some terms not completely tested */
-    int ii = 0;                            /* Loop counter */
+    int ii;                            /* Loop counter */
     Expr *pAndExpr = 0;                /* An ".. AND (...)" expression */
     Table *pTab = pTabItem->pTab;
 
@@ -149769,8 +149767,8 @@
     ** This becomes the SrcList in the recursive call to sqlite3WhereBegin().
     */
     if( pWInfo->nLevel>1 ){
-      int nNotReady = 0;                 /* The number of notReady tables */
-      SrcItem *origSrc = NULL;              /* Original list of tables */
+      int nNotReady;                 /* The number of notReady tables */
+      SrcItem *origSrc;              /* Original list of tables */
       nNotReady = pWInfo->nLevel - iLevel - 1;
       pOrTab = sqlite3StackAllocRaw(db,
                             sizeof(*pOrTab)+ nNotReady*sizeof(pOrTab->a[0]));
@@ -149841,7 +149839,7 @@
     ** https://sqlite.org/forum/forumpost/36937b197273d403
     */
     if( pWC->nTerm>1 ){
-      int iTerm = 0;
+      int iTerm;
       for(iTerm=0; iTerm<pWC->nTerm; iTerm++){
         Expr *pExpr = pWC->a[iTerm].pExpr;
         if( &pWC->a[iTerm] == pTerm ) continue;
@@ -149874,9 +149872,9 @@
     for(ii=0; ii<pOrWc->nTerm; ii++){
       WhereTerm *pOrTerm = &pOrWc->a[ii];
       if( pOrTerm->leftCursor==iCur || (pOrTerm->eOperator & WO_AND)!=0 ){
-        WhereInfo *pSubWInfo = NULL;           /* Info for single OR-term scan */
+        WhereInfo *pSubWInfo;           /* Info for single OR-term scan */
         Expr *pOrExpr = pOrTerm->pExpr; /* Current OR clause term */
-        Expr *pDelete = NULL;                  /* Local copy of OR clause term */
+        Expr *pDelete;                  /* Local copy of OR clause term */
         int jmp1 = 0;                   /* Address of jump operation */
         testcase( (pTabItem[0].fg.jointype & JT_LEFT)!=0
                && !ExprHasProperty(pOrExpr, EP_FromJoin)
@@ -149897,7 +149895,7 @@
                                       WHERE_OR_SUBCLAUSE, iCovCur);
         assert( pSubWInfo || pParse->nErr );
         if( pSubWInfo ){
-          WhereLoop *pSubLoop = NULL;
+          WhereLoop *pSubLoop;
           int addrExplain = sqlite3WhereExplainOneScan(
               pParse, pOrTab, &pSubWInfo->a[0], 0
           );
@@ -149918,8 +149916,8 @@
             }else{
               Index *pPk = sqlite3PrimaryKeyIndex(pTab);
               int nPk = pPk->nKeyCol;
-              int iPk = 0;
-              int r = 0;
+              int iPk;
+              int r;
 
               /* Read the PK into an array of temp registers. */
               r = sqlite3GetTempRange(pParse, nPk);
@@ -150066,7 +150064,7 @@
   do{
     int iNext = 0;                /* Next value for iLoop */
     for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
-      Expr *pE = NULL;
+      Expr *pE;
       int skipLikeAddr = 0;
       testcase( pTerm->wtFlags & TERM_VIRTUAL );
       testcase( pTerm->wtFlags & TERM_CODED );
@@ -150135,8 +150133,8 @@
   ** the implied "t1.a=123" constraint.
   */
   for(pTerm=pWC->a, j=pWC->nBase; j>0; j--, pTerm++){
-    Expr *pE = NULL, sEAlt;
-    WhereTerm *pAlt = NULL;
+    Expr *pE, sEAlt;
+    WhereTerm *pAlt;
     if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;
     if( (pTerm->eOperator & (WO_EQ|WO_IS))==0 ) continue;
     if( (pTerm->eOperator & WO_EQUIV)==0 ) continue;
@@ -150269,8 +150267,8 @@
 ** the pWC->a[] array.
 */
 static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){
-  WhereTerm *pTerm = NULL;
-  int idx = 0;
+  WhereTerm *pTerm;
+  int idx;
   testcase( wtFlags & TERM_VIRTUAL );
   if( pWC->nTerm>=pWC->nSlot ){
     WhereTerm *pOld = pWC->a;
@@ -150346,7 +150344,7 @@
 ** Translate from TK_xx operator to WO_xx bitmask.
 */
 static u16 operatorMask(int op){
-  u16 c = 0;
+  u16 c;
   assert( allowedOp(op) );
   if( op==TK_IN ){
     c = WO_IN;
@@ -150391,15 +150389,15 @@
   int *pnoCase      /* True if uppercase is equivalent to lowercase */
 ){
   const u8 *z = 0;           /* String on RHS of LIKE operator */
-  Expr *pRight = NULL, *pLeft = NULL;      /* Right and left size of LIKE operator */
-  ExprList *pList = NULL;           /* List of operands to the LIKE operator */
-  u8 c = 0;                      /* One character in z[] */
-  int cnt = 0;                   /* Number of non-wildcard prefix characters */
+  Expr *pRight, *pLeft;      /* Right and left size of LIKE operator */
+  ExprList *pList;           /* List of operands to the LIKE operator */
+  u8 c;                      /* One character in z[] */
+  int cnt;                   /* Number of non-wildcard prefix characters */
   u8 wc[4];                  /* Wildcard characters */
   sqlite3 *db = pParse->db;  /* Database connection */
   sqlite3_value *pVal = 0;
-  int op = 0;                    /* Opcode of pRight */
-  int rc = 0;                    /* Result code to return */
+  int op;                    /* Opcode of pRight */
+  int rc;                    /* Result code to return */
 
   if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, (char*)wc) ){
     return 0;
@@ -150444,7 +150442,7 @@
     ** consists of at least one character after all escapes have been
     ** removed.  */
     if( cnt!=0 && 255!=(u8)z[cnt-1] && (cnt>1 || z[0]!=wc[3]) ){
-      Expr *pPrefix = NULL;
+      Expr *pPrefix;
 
       /* A "complete" match if the pattern ends with "*" or "%" */
       *pisComplete = c==wc[0] && z[cnt+1]==0;
@@ -150452,8 +150450,8 @@
       /* Get the pattern prefix.  Remove all escapes from the prefix. */
       pPrefix = sqlite3Expr(db, TK_STRING, (char*)z);
       if( pPrefix ){
-        int iFrom = 0, iTo = 0;
-        char *zNew = NULL;
+        int iFrom, iTo;
+        char *zNew;
         assert( !ExprHasProperty(pPrefix, EP_IntValue) );
         zNew = pPrefix->u.zToken;
         zNew[cnt] = 0;
@@ -150483,8 +150481,8 @@
              && pLeft->y.pTab
              && IsVirtual(pLeft->y.pTab))  /* Might be numeric */
         ){
-          int isNum = 0;
-          double rDummy = 0;
+          int isNum;
+          double rDummy;
           isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);
           if( isNum<=0 ){
             if( iTo==1 && zNew[0]=='-' ){
@@ -150579,9 +150577,9 @@
       { "like",   SQLITE_INDEX_CONSTRAINT_LIKE },
       { "regexp", SQLITE_INDEX_CONSTRAINT_REGEXP }
     };
-    ExprList *pList = NULL;
-    Expr *pCol = NULL;                     /* Column reference */
-    int i = 0;
+    ExprList *pList;
+    Expr *pCol;                     /* Column reference */
+    int i;
 
     assert( ExprUseXList(pExpr) );
     pList = pExpr->x.pList;
@@ -150625,10 +150623,10 @@
     assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );
     testcase( pCol->op==TK_COLUMN && pCol->y.pTab==0 );
     if( ExprIsVtab(pCol) ){
-      sqlite3_vtab *pVtab = NULL;
-      sqlite3_module *pMod = NULL;
-      void (*xNotUsed = 0)(sqlite3_context*,int,sqlite3_value**);
-      void *pNotUsed = NULL;
+      sqlite3_vtab *pVtab;
+      sqlite3_module *pMod;
+      void (*xNotUsed)(sqlite3_context*,int,sqlite3_value**);
+      void *pNotUsed;
       pVtab = sqlite3GetVTable(db, pCol->y.pTab)->pVtab;
       assert( pVtab!=0 );
       assert( pVtab->pModule!=0 );
@@ -150732,10 +150730,10 @@
   WhereTerm *pTwo        /* Second disjunct */
 ){
   u16 eOp = pOne->eOperator | pTwo->eOperator;
-  sqlite3 *db = NULL;           /* Database connection (for malloc) */
-  Expr *pNew = NULL;            /* New virtual expression */
-  int op = 0;                /* Operator for the combined expression */
-  int idxNew = 0;            /* Index in pWC of the next virtual term */
+  sqlite3 *db;           /* Database connection (for malloc) */
+  Expr *pNew;            /* New virtual expression */
+  int op;                /* Operator for the combined expression */
+  int idxNew;            /* Index in pWC of the next virtual term */
 
   if( (pOne->wtFlags | pTwo->wtFlags) & TERM_VNULL ) return;
   if( (pOne->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;
@@ -150862,12 +150860,12 @@
   sqlite3 *db = pParse->db;               /* Database connection */
   WhereTerm *pTerm = &pWC->a[idxTerm];    /* The term to be analyzed */
   Expr *pExpr = pTerm->pExpr;             /* The expression of the term */
-  int i = 0;                                  /* Loop counters */
-  WhereClause *pOrWc = NULL;       /* Breakup of pTerm into subterms */
-  WhereTerm *pOrTerm = NULL;       /* A Sub-term within the pOrWc */
-  WhereOrInfo *pOrInfo = NULL;     /* Additional information associated with pTerm */
-  Bitmask chngToIN = 0;         /* Tables that might satisfy case 1 */
-  Bitmask indexable = 0;        /* Tables that are indexable, satisfying case 2 */
+  int i;                                  /* Loop counters */
+  WhereClause *pOrWc;       /* Breakup of pTerm into subterms */
+  WhereTerm *pOrTerm;       /* A Sub-term within the pOrWc */
+  WhereOrInfo *pOrInfo;     /* Additional information associated with pTerm */
+  Bitmask chngToIN;         /* Tables that might satisfy case 1 */
+  Bitmask indexable;        /* Tables that are indexable, satisfying case 2 */
 
   /*
   ** Break the OR clause into its separate subterms.  The subterms are
@@ -150894,14 +150892,14 @@
   chngToIN = ~(Bitmask)0;
   for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){
     if( (pOrTerm->eOperator & WO_SINGLE)==0 ){
-      WhereAndInfo *pAndInfo = NULL;
+      WhereAndInfo *pAndInfo;
       assert( (pOrTerm->wtFlags & (TERM_ANDINFO|TERM_ORINFO))==0 );
       chngToIN = 0;
       pAndInfo = sqlite3DbMallocRawNN(db, sizeof(*pAndInfo));
       if( pAndInfo ){
-        WhereClause *pAndWC = NULL;
-        WhereTerm *pAndTerm = NULL;
-        int j = 0;
+        WhereClause *pAndWC;
+        WhereTerm *pAndTerm;
+        int j;
         Bitmask b = 0;
         pOrTerm->u.pAndInfo = pAndInfo;
         pOrTerm->wtFlags |= TERM_ANDINFO;
@@ -150929,7 +150927,7 @@
       /* Skip this term for now.  We revisit it when we process the
       ** corresponding TERM_VIRTUAL term */
     }else{
-      Bitmask b = 0;
+      Bitmask b;
       b = sqlite3WhereGetMask(&pWInfo->sMaskSet, pOrTerm->leftCursor);
       if( pOrTerm->wtFlags & TERM_VIRTUAL ){
         WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];
@@ -150959,10 +150957,10 @@
   */
   if( indexable && pOrWc->nTerm==2 ){
     int iOne = 0;
-    WhereTerm *pOne = NULL;
+    WhereTerm *pOne;
     while( (pOne = whereNthSubterm(&pOrWc->a[0],iOne++))!=0 ){
       int iTwo = 0;
-      WhereTerm *pTwo = NULL;
+      WhereTerm *pTwo;
       while( (pTwo = whereNthSubterm(&pOrWc->a[1],iTwo++))!=0 ){
         whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
       }
@@ -151054,7 +151052,7 @@
         )){
           okToChngToIN = 0;
         }else{
-          int affLeft = 0, affRight = 0;
+          int affLeft, affRight;
           /* If the right-hand side is also a column, then the affinities
           ** of both right and left sides must be such that no type
           ** conversions are required on the right.  (Ticket #2249)
@@ -151075,10 +151073,10 @@
     ** pTerm converted into an IN operator.
     */
     if( okToChngToIN ){
-      Expr *pDup = NULL;            /* A transient duplicate expression */
+      Expr *pDup;            /* A transient duplicate expression */
       ExprList *pList = 0;   /* The RHS of the IN operator */
       Expr *pLeft = 0;       /* The LHS of the IN operator */
-      Expr *pNew = NULL;            /* The complete IN operator */
+      Expr *pNew;            /* The complete IN operator */
 
       for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){
         if( (pOrTerm->wtFlags & TERM_OK)==0 ) continue;
@@ -151094,7 +151092,7 @@
       pDup = sqlite3ExprDup(db, pLeft, 0);
       pNew = sqlite3PExpr(pParse, TK_IN, pDup, 0);
       if( pNew ){
-        int idxNew = 0;
+        int idxNew;
         transferJoinMarkings(pNew, pExpr);
         assert( ExprUseXList(pNew) );
         pNew->x.pList = pList;
@@ -151127,8 +151125,8 @@
 ** returned when it should not be, then incorrect answers might result.
 */
 static int termIsEquivalence(Parse *pParse, Expr *pExpr){
-  char aff1 = 0, aff2 = 0;
-  CollSeq *pColl = NULL;
+  char aff1, aff2;
+  CollSeq *pColl;
   if( !OptimizationEnabled(pParse->db, SQLITE_Transitive) ) return 0;
   if( pExpr->op!=TK_EQ && pExpr->op!=TK_IS ) return 0;
   if( ExprHasProperty(pExpr, EP_FromJoin) ) return 0;
@@ -151159,7 +151157,7 @@
     mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);
     mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);
     if( ALWAYS(pSrc!=0) ){
-      int i = 0;
+      int i;
       for(i=0; i<pSrc->nSrc; i++){
         mask |= exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);
         mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].pOn);
@@ -151192,9 +151190,9 @@
   int *aiCurCol,         /* Write the referenced table cursor and column here */
   Expr *pExpr            /* An operand of a comparison operator */
 ){
-  Index *pIdx = NULL;
-  int i = 0;
-  int iCur = 0;
+  Index *pIdx;
+  int i;
+  int iCur;
   for(i=0; mPrereq>1; i++, mPrereq>>=1){}
   iCur = pFrom->a[i].iCursor;
   for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){
@@ -151264,20 +151262,20 @@
   int idxTerm               /* Index of the term to be analyzed */
 ){
   WhereInfo *pWInfo = pWC->pWInfo; /* WHERE clause processing context */
-  WhereTerm *pTerm = NULL;                /* The term to be analyzed */
-  WhereMaskSet *pMaskSet = NULL;          /* Set of table index masks */
-  Expr *pExpr = NULL;                     /* The expression to be analyzed */
-  Bitmask prereqLeft = 0;              /* Prerequesites of the pExpr->pLeft */
-  Bitmask prereqAll = 0;               /* Prerequesites of pExpr */
+  WhereTerm *pTerm;                /* The term to be analyzed */
+  WhereMaskSet *pMaskSet;          /* Set of table index masks */
+  Expr *pExpr;                     /* The expression to be analyzed */
+  Bitmask prereqLeft;              /* Prerequesites of the pExpr->pLeft */
+  Bitmask prereqAll;               /* Prerequesites of pExpr */
   Bitmask extraRight = 0;          /* Extra dependencies on LEFT JOIN */
   Expr *pStr1 = 0;                 /* RHS of LIKE/GLOB operator */
   int isComplete = 0;              /* RHS of LIKE/GLOB ends with wildcard */
   int noCase = 0;                  /* uppercase equivalent to lowercase */
-  int op = 0;                          /* Top-level operator.  pExpr->op */
+  int op;                          /* Top-level operator.  pExpr->op */
   Parse *pParse = pWInfo->pParse;  /* Parsing context */
   sqlite3 *db = pParse->db;        /* Database connection */
   unsigned char eOp2 = 0;          /* op2 value for LIKE/REGEXP/GLOB */
-  int nLeft = 0;                       /* Number of elements on left side vector */
+  int nLeft;                       /* Number of elements on left side vector */
 
   if( db->mallocFailed ){
     return;
@@ -151359,12 +151357,12 @@
      && exprMightBeIndexed(pSrc, pTerm->prereqRight, aiCurCol, pRight, op)
      && !ExprHasProperty(pRight, EP_FixedCol)
     ){
-      WhereTerm *pNew = NULL;
-      Expr *pDup = NULL;
+      WhereTerm *pNew;
+      Expr *pDup;
       u16 eExtraOp = 0;        /* Extra bits for pNew->eOperator */
       assert( pTerm->u.x.iField==0 );
       if( pTerm->leftCursor>=0 ){
-        int idxNew = 0;
+        int idxNew;
         pDup = sqlite3ExprDup(db, pExpr, 0);
         if( db->mallocFailed ){
           sqlite3ExprDelete(db, pDup);
@@ -151425,16 +151423,16 @@
   ** BETWEEN term is skipped.
   */
   else if( pExpr->op==TK_BETWEEN && pWC->op==TK_AND ){
-    ExprList *pList = NULL;
-    int i = 0;
+    ExprList *pList;
+    int i;
     static const u8 ops[] = {TK_GE, TK_LE};
     assert( ExprUseXList(pExpr) );
     pList = pExpr->x.pList;
     assert( pList!=0 );
     assert( pList->nExpr==2 );
     for(i=0; i<2; i++){
-      Expr *pNewExpr = NULL;
-      int idxNew = 0;
+      Expr *pNewExpr;
+      int idxNew;
       pNewExpr = sqlite3PExpr(pParse, ops[i],
                              sqlite3ExprDup(db, pExpr->pLeft, 0),
                              sqlite3ExprDup(db, pList->a[i].pExpr, 0));
@@ -151469,10 +151467,10 @@
      && pExpr->pLeft->iColumn>=0
      && !ExprHasProperty(pExpr, EP_FromJoin)
     ){
-      Expr *pNewExpr = NULL;
+      Expr *pNewExpr;
       Expr *pLeft = pExpr->pLeft;
-      int idxNew = 0;
-      WhereTerm *pNewTerm = NULL;
+      int idxNew;
+      WhereTerm *pNewTerm;
 
       pNewExpr = sqlite3PExpr(pParse, TK_GT,
                               sqlite3ExprDup(db, pLeft, 0),
@@ -151513,13 +151511,13 @@
    && pWC->op==TK_AND
    && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)
   ){
-    Expr *pLeft = NULL;       /* LHS of LIKE/GLOB operator */
-    Expr *pStr2 = NULL;       /* Copy of pStr1 - RHS of LIKE/GLOB operator */
-    Expr *pNewExpr1 = NULL;
-    Expr *pNewExpr2 = NULL;
-    int idxNew1 = 0;
-    int idxNew2 = 0;
-    const char *zCollSeqName = NULL;     /* Name of collating sequence */
+    Expr *pLeft;       /* LHS of LIKE/GLOB operator */
+    Expr *pStr2;       /* Copy of pStr1 - RHS of LIKE/GLOB operator */
+    Expr *pNewExpr1;
+    Expr *pNewExpr2;
+    int idxNew1;
+    int idxNew2;
+    const char *zCollSeqName;     /* Name of collating sequence */
     const u16 wtFlags = TERM_LIKEOPT | TERM_VIRTUAL | TERM_DYNAMIC;
 
     assert( ExprUseXList(pExpr) );
@@ -151534,8 +151532,8 @@
     ** the range constraints also work for BLOBs
     */
     if( noCase && !pParse->db->mallocFailed ){
-      int i = 0;
-      char c = 0;
+      int i;
+      char c;
       pTerm->wtFlags |= TERM_LIKE;
       for(i=0; (c = pStr1->u.zToken[i])!=0; i++){
         pStr1->u.zToken[i] = sqlite3Toupper(c);
@@ -151544,7 +151542,7 @@
     }
 
     if( !db->mallocFailed ){
-      u8 c = 0, *pC = NULL;       /* Last character before the first wildcard */
+      u8 c, *pC;       /* Last character before the first wildcard */
       pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];
       c = *pC;
       if( noCase ){
@@ -151601,10 +151599,10 @@
      || (pExpr->pRight->flags & EP_xIsSelect)==0)
    && pWC->op==TK_AND
   ){
-    int i = 0;
+    int i;
     for(i=0; i<nLeft; i++){
-      int idxNew = 0;
-      Expr *pNew = NULL;
+      int idxNew;
+      Expr *pNew;
       Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i, nLeft);
       Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i, nLeft);
 
@@ -151637,9 +151635,9 @@
 #endif
    && pWC->op==TK_AND
   ){
-    int i = 0;
+    int i;
     for(i=0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++){
-      int idxNew = 0;
+      int idxNew;
       idxNew = whereClauseInsert(pWC, pExpr, TERM_VIRTUAL|TERM_SLICE);
       pWC->a[idxNew].u.x.iField = i+1;
       exprAnalyze(pSrc, pWC, idxNew);
@@ -151661,14 +151659,14 @@
     Expr *pRight = 0, *pLeft = 0;
     int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);
     while( res-- > 0 ){
-      int idxNew = 0;
-      WhereTerm *pNewTerm = NULL;
-      Bitmask prereqColumn = 0, prereqExpr = 0;
+      int idxNew;
+      WhereTerm *pNewTerm;
+      Bitmask prereqColumn, prereqExpr;
 
       prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);
       prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);
       if( (prereqExpr & prereqColumn)==0 ){
-        Expr *pNewExpr = NULL;
+        Expr *pNewExpr;
         pNewExpr = sqlite3PExpr(pParse, TK_MATCH,
             0, sqlite3ExprDup(db, pRight, 0));
         if( ExprHasProperty(pExpr, EP_FromJoin) && pNewExpr ){
@@ -151756,7 +151754,7 @@
 ){
   Parse *pParse = pWC->pWInfo->pParse;
   sqlite3 *db = pParse->db;
-  Expr *pNew = NULL;
+  Expr *pNew;
   int iVal = 0;
 
   if( sqlite3ExprIsInteger(pExpr, &iVal) && iVal>=0 ){
@@ -151772,8 +151770,8 @@
     pNew = sqlite3PExpr(pParse, TK_MATCH, 0, pVal);
   }
   if( pNew ){
-    WhereTerm *pTerm = NULL;
-    int idx = 0;
+    WhereTerm *pTerm;
+    int idx;
     idx = whereClauseInsert(pWC, pNew, TERM_DYNAMIC|TERM_VIRTUAL);
     pTerm = &pWC->a[idx];
     pTerm->leftCursor = iCsr;
@@ -151808,7 +151806,7 @@
   ){
     ExprList *pOrderBy = p->pOrderBy;
     int iCsr = p->pSrc->a[0].iCursor;
-    int ii = 0;
+    int ii;
 
     /* Check condition (4). Return early if it is not met. */
     for(ii=0; ii<pWC->nTerm; ii++){
@@ -151936,7 +151934,7 @@
   WhereMaskSet *pMaskSet,
   Expr *p
 ){
-  Bitmask mask = 0;
+  Bitmask mask;
   mask = (p->op==TK_IF_NULL_ROW) ? sqlite3WhereGetMask(pMaskSet, p->iTable) : 0;
   if( p->pLeft ) mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pLeft);
   if( p->pRight ){
@@ -151971,7 +151969,7 @@
   return p ? sqlite3WhereExprUsageNN(pMaskSet,p) : 0;
 }
 SQLITE_PRIVATE Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet, ExprList *pList){
-  int i = 0;
+  int i;
   Bitmask mask = 0;
   if( pList ){
     for(i=0; i<pList->nExpr; i++){
@@ -151994,7 +151992,7 @@
   SrcList *pTabList,       /* the FROM clause */
   WhereClause *pWC         /* the WHERE clause to be analyzed */
 ){
-  int i = 0;
+  int i;
   for(i=pWC->nTerm-1; i>=0; i--){
     exprAnalyze(pTabList, pWC, i);
   }
@@ -152012,18 +152010,18 @@
   SrcItem *pItem,                   /* The FROM clause term to process */
   WhereClause *pWC                  /* Xfer function arguments to here */
 ){
-  Table *pTab = NULL;
-  int j = 0, k = 0;
-  ExprList *pArgs = NULL;
-  Expr *pColRef = NULL;
-  Expr *pTerm = NULL;
+  Table *pTab;
+  int j, k;
+  ExprList *pArgs;
+  Expr *pColRef;
+  Expr *pTerm;
   if( pItem->fg.isTabFunc==0 ) return;
   pTab = pItem->pTab;
   assert( pTab!=0 );
   pArgs = pItem->u1.pFuncArg;
   if( pArgs==0 ) return;
   for(j=k=0; j<pArgs->nExpr; j++){
-    Expr *pRhs = NULL;
+    Expr *pRhs;
     while( k<pTab->nCol && (pTab->aCol[k].colFlags & COLFLAG_HIDDEN)==0 ){k++;}
     if( k>=pTab->nCol ){
       sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d",
@@ -152145,7 +152143,7 @@
 ** the final answer.
 */
 SQLITE_PRIVATE int sqlite3WhereOrderByLimitOptLabel(WhereInfo *pWInfo){
-  WhereLevel *pInner = NULL;
+  WhereLevel *pInner;
   if( !pWInfo->bOrderedInnerLoop ){
     /* The ORDER BY LIMIT optimization does not apply.  Jump to the
     ** continuation of the inner-most loop. */
@@ -152168,8 +152166,8 @@
 ** makes the answer appear faster.
 */
 SQLITE_PRIVATE void sqlite3WhereMinMaxOptEarlyOut(Vdbe *v, WhereInfo *pWInfo){
-  WhereLevel *pInner = NULL;
-  int i = 0;
+  WhereLevel *pInner;
+  int i;
   if( !pWInfo->bOrderedInnerLoop ) return;
   if( pWInfo->nOBSat==0 ) return;
   for(i=pWInfo->nLevel-1; i>=0; i--){
@@ -152257,8 +152255,8 @@
   LogEst rRun,           /* Run-cost of the new entry */
   LogEst nOut            /* Number of outputs for the new entry */
 ){
-  u16 i = 0;
-  WhereOrCost *p = NULL;
+  u16 i;
+  WhereOrCost *p;
   for(i=pSet->n, p=pSet->a; i>0; i--, p++){
     if( rRun<=p->rRun && (prereq & p->prereq)==prereq ){
       goto whereOrInsert_done;
@@ -152289,7 +152287,7 @@
 ** iCursor is not in the set.
 */
 SQLITE_PRIVATE Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet, int iCursor){
-  int i = 0;
+  int i;
   assert( pMaskSet->n<=(int)sizeof(Bitmask)*8 );
   assert( pMaskSet->n>0 || pMaskSet->ix[0]<0 );
   assert( iCursor>=-1 );
@@ -152335,11 +152333,11 @@
 ** Return NULL if there are no more matching WhereTerms.
 */
 static WhereTerm *whereScanNext(WhereScan *pScan){
-  int iCur = 0;            /* The cursor on the LHS of the term */
-  i16 iColumn = 0;         /* The column on the LHS of the term.  -1 for IPK */
-  Expr *pX = NULL;            /* An expression being tested */
-  WhereClause *pWC = NULL;    /* Shorthand for pScan->pWC */
-  WhereTerm *pTerm = NULL;    /* The term being tested */
+  int iCur;            /* The cursor on the LHS of the term */
+  i16 iColumn;         /* The column on the LHS of the term.  -1 for IPK */
+  Expr *pX;            /* An expression being tested */
+  WhereClause *pWC;    /* Shorthand for pScan->pWC */
+  WhereTerm *pTerm;    /* The term being tested */
   int k = pScan->k;    /* Where to start scanning */
 
   assert( pScan->iEquiv<=pScan->nEquiv );
@@ -152363,7 +152361,7 @@
            && pScan->nEquiv<ArraySize(pScan->aiCur)
            && (pX = whereRightSubexprIsColumn(pTerm->pExpr))!=0
           ){
-            int j = 0;
+            int j;
             for(j=0; j<pScan->nEquiv; j++){
               if( pScan->aiCur[j]==pX->iTable
                && pScan->aiColumn[j]==pX->iColumn ){
@@ -152379,7 +152377,7 @@
           if( (pTerm->eOperator & pScan->opMask)!=0 ){
             /* Verify the affinity and collating sequence match */
             if( pScan->zCollName && (pTerm->eOperator & WO_ISNULL)==0 ){
-              CollSeq *pColl = NULL;
+              CollSeq *pColl;
               Parse *pParse = pWC->pWInfo->pParse;
               pX = pTerm->pExpr;
               if( !sqlite3IndexAffinityOk(pX, pScan->idxaff) ){
@@ -152533,7 +152531,7 @@
   Index *pIdx           /* Must be compatible with this index, if not NULL */
 ){
   WhereTerm *pResult = 0;
-  WhereTerm *p = NULL;
+  WhereTerm *p;
   WhereScan scan;
 
   p = whereScanInit(&scan, pWC, iCur, iColumn, op, pIdx);
@@ -152565,7 +152563,7 @@
   Index *pIdx,                    /* Index to match column of */
   int iCol                        /* Column of index to match */
 ){
-  int i = 0;
+  int i;
   const char *zColl = pIdx->azColl[iCol];
 
   for(i=0; i<pList->nExpr; i++){
@@ -152589,7 +152587,7 @@
 ** Return TRUE if the iCol-th column of index pIdx is NOT NULL
 */
 static int indexColumnNotNull(Index *pIdx, int iCol){
-  int j = 0;
+  int j;
   assert( pIdx!=0 );
   assert( iCol>=0 && iCol<pIdx->nColumn );
   j = pIdx->aiColumn[iCol];
@@ -152617,10 +152615,10 @@
   WhereClause *pWC,         /* The WHERE clause */
   ExprList *pDistinct       /* The result set that needs to be DISTINCT */
 ){
-  Table *pTab = NULL;
-  Index *pIdx = NULL;
-  int i = 0;
-  int iBase = 0;
+  Table *pTab;
+  Index *pIdx;
+  int i;
+  int iBase;
 
   /* If there is more than one table or sub-select in the FROM clause of
   ** this query, then it will not be possible to show that the DISTINCT
@@ -152780,7 +152778,7 @@
   const SrcItem *pSrc,           /* Table we are trying to access */
   const Bitmask notReady         /* Tables in outer loops of the join */
 ){
-  char aff = 0;
+  char aff;
   if( pTerm->leftCursor!=pSrc->iCursor ) return 0;
   if( (pTerm->eOperator & (WO_EQ|WO_IS))==0 ) return 0;
   if( (pSrc->fg.jointype & JT_LEFT)
@@ -152816,29 +152814,29 @@
   const Bitmask notReady,     /* Mask of cursors that are not available */
   WhereLevel *pLevel          /* Write new index here */
 ){
-  int nKeyCol = 0;                /* Number of columns in the constructed index */
-  WhereTerm *pTerm = NULL;           /* A single term of the WHERE clause */
-  WhereTerm *pWCEnd = NULL;          /* End of pWC->a[] */
-  Index *pIdx = NULL;                /* Object describing the transient index */
-  Vdbe *v = NULL;                    /* Prepared statement under construction */
-  int addrInit = 0;               /* Address of the initialization bypass jump */
-  Table *pTable = NULL;              /* The table being indexed */
-  int addrTop = 0;                /* Top of the index fill loop */
-  int regRecord = 0;              /* Register holding an index record */
-  int n = 0;                      /* Column counter */
-  int i = 0;                      /* Loop counter */
-  int mxBitCol = 0;               /* Maximum column in pSrc->colUsed */
-  CollSeq *pColl = NULL;             /* Collating sequence to on a column */
-  WhereLoop *pLoop = NULL;           /* The Loop object */
-  char *zNotUsed = NULL;             /* Extra space on the end of pIdx */
-  Bitmask idxCols = 0;            /* Bitmap of columns used for indexing */
-  Bitmask extraCols = 0;          /* Bitmap of additional columns */
+  int nKeyCol;                /* Number of columns in the constructed index */
+  WhereTerm *pTerm;           /* A single term of the WHERE clause */
+  WhereTerm *pWCEnd;          /* End of pWC->a[] */
+  Index *pIdx;                /* Object describing the transient index */
+  Vdbe *v;                    /* Prepared statement under construction */
+  int addrInit;               /* Address of the initialization bypass jump */
+  Table *pTable;              /* The table being indexed */
+  int addrTop;                /* Top of the index fill loop */
+  int regRecord;              /* Register holding an index record */
+  int n;                      /* Column counter */
+  int i;                      /* Loop counter */
+  int mxBitCol;               /* Maximum column in pSrc->colUsed */
+  CollSeq *pColl;             /* Collating sequence to on a column */
+  WhereLoop *pLoop;           /* The Loop object */
+  char *zNotUsed;             /* Extra space on the end of pIdx */
+  Bitmask idxCols;            /* Bitmap of columns used for indexing */
+  Bitmask extraCols;          /* Bitmap of additional columns */
   u8 sentWarning = 0;         /* True if a warnning has been issued */
   Expr *pPartial = 0;         /* Partial Index Expression */
   int iContinue = 0;          /* Jump here to skip excluded rows */
-  SrcItem *pTabItem = NULL;          /* FROM clause term being indexed */
+  SrcItem *pTabItem;          /* FROM clause term being indexed */
   int addrCounter = 0;        /* Address where integer counter is initialized */
-  int regBase = 0;                /* Array of registers where record is assembled */
+  int regBase;                /* Array of registers where record is assembled */
 
   /* Generate code to skip over the creation and initialization of the
   ** transient index on 2nd and subsequent iterations of the loop. */
@@ -152865,8 +152863,8 @@
                                 sqlite3ExprDup(pParse->db, pExpr, 0));
     }
     if( termCanDriveIndex(pTerm, pSrc, notReady) ){
-      int iCol = 0;
-      Bitmask cMask = 0;
+      int iCol;
+      Bitmask cMask;
       assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );
       iCol = pTerm->u.x.leftColumn;
       cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);
@@ -152921,8 +152919,8 @@
   idxCols = 0;
   for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
     if( termCanDriveIndex(pTerm, pSrc, notReady) ){
-      int iCol = 0;
-      Bitmask cMask = 0;
+      int iCol;
+      Bitmask cMask;
       assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );
       iCol = pTerm->u.x.leftColumn;
       cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);
@@ -153049,15 +153047,15 @@
   WhereLevel *pLevel,   /* Make a Bloom filter for this FROM term */
   Bitmask notReady      /* Loops that are not ready */
 ){
-  int addrOnce = 0;                        /* Address of opening OP_Once */
-  int addrTop = 0;                         /* Address of OP_Rewind */
-  int addrCont = 0;                        /* Jump here to skip a row */
-  const WhereTerm *pTerm = NULL;              /* For looping over WHERE clause terms */
-  const WhereTerm *pWCEnd = NULL;             /* Last WHERE clause term */
+  int addrOnce;                        /* Address of opening OP_Once */
+  int addrTop;                         /* Address of OP_Rewind */
+  int addrCont;                        /* Jump here to skip a row */
+  const WhereTerm *pTerm;              /* For looping over WHERE clause terms */
+  const WhereTerm *pWCEnd;             /* Last WHERE clause term */
   Parse *pParse = pWInfo->pParse;      /* Parsing context */
   Vdbe *v = pParse->pVdbe;             /* VDBE under construction */
   WhereLoop *pLoop = pLevel->pWLoop;   /* The loop being coded */
-  int iCur = 0;                            /* Cursor for table getting the filter */
+  int iCur;                            /* Cursor for table getting the filter */
 
   assert( pLoop!=0 );
   assert( v!=0 );
@@ -153065,9 +153063,9 @@
 
   addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
   do{
-    const SrcItem *pItem = NULL;
-    const Table *pTab = NULL;
-    u64 sz = 0;
+    const SrcItem *pItem;
+    const Table *pTab;
+    u64 sz;
     sqlite3WhereExplainBloomFilter(pParse, pWInfo, pLevel);
     addrCont = sqlite3VdbeMakeLabel(pParse);
     iCur = pLevel->iTabCur;
@@ -153112,7 +153110,7 @@
       Index *pIdx = pLoop->u.btree.pIndex;
       int n = pLoop->u.btree.nEq;
       int r1 = sqlite3GetTempRange(pParse, n);
-      int jj = 0;
+      int jj;
       for(jj=0; jj<n; jj++){
         int iCol = pIdx->aiColumn[jj];
         assert( pIdx->pTable==pItem->pTab );
@@ -153128,7 +153126,7 @@
     pLoop->wsFlags &= ~WHERE_BLOOMFILTER;
     if( OptimizationDisabled(pParse->db, SQLITE_BloomPulldown) ) break;
     while( ++iLevel < pWInfo->nLevel ){
-      const SrcItem *pTabItem = NULL;
+      const SrcItem *pTabItem;
       pLevel = &pWInfo->a[iLevel];
       pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
       if( pTabItem->fg.jointype & JT_LEFT ) continue;
@@ -153163,18 +153161,18 @@
   SrcItem *pSrc,                  /* The FROM clause term that is the vtab */
   u16 *pmNoOmit                   /* Mask of terms not to omit */
 ){
-  int i = 0, j = 0;
-  int nTerm = 0;
+  int i, j;
+  int nTerm;
   Parse *pParse = pWInfo->pParse;
-  struct sqlite3_index_constraint *pIdxCons = NULL;
-  struct sqlite3_index_orderby *pIdxOrderBy = NULL;
-  struct sqlite3_index_constraint_usage *pUsage = NULL;
-  struct HiddenIndexInfo *pHidden = NULL;
-  WhereTerm *pTerm = NULL;
-  int nOrderBy = 0;
-  sqlite3_index_info *pIdxInfo = NULL;
+  struct sqlite3_index_constraint *pIdxCons;
+  struct sqlite3_index_orderby *pIdxOrderBy;
+  struct sqlite3_index_constraint_usage *pUsage;
+  struct HiddenIndexInfo *pHidden;
+  WhereTerm *pTerm;
+  int nOrderBy;
+  sqlite3_index_info *pIdxInfo;
   u16 mNoOmit = 0;
-  const Table *pTab = NULL;
+  const Table *pTab;
   int eDistinct = 0;
   ExprList *pOrderBy = pWInfo->pOrderBy;
 
@@ -153224,7 +153222,7 @@
     int n = pOrderBy->nExpr;
     for(i=0; i<n; i++){
       Expr *pExpr = pOrderBy->a[i].pExpr;
-      Expr *pE2 = NULL;
+      Expr *pE2;
 
       /* Skip over constant terms in the ORDER BY clause */
       if( sqlite3ExprIsConstant(pExpr) ){
@@ -153246,7 +153244,7 @@
        && (pE2 = pExpr->pLeft)->op==TK_COLUMN
        && pE2->iTable==pSrc->iCursor
       ){
-        const char *zColl = NULL;  /* The collating sequence name */
+        const char *zColl;  /* The collating sequence name */
         assert( !ExprHasProperty(pExpr, EP_IntValue) );
         assert( pExpr->u.zToken!=0 );
         assert( pE2->iColumn>=XN_ROWID && pE2->iColumn<pTab->nCol );
@@ -153290,7 +153288,7 @@
   pHidden->eDistinct = eDistinct;
   pHidden->mIn = 0;
   for(i=j=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
-    u16 op = 0;
+    u16 op;
     if( (pTerm->wtFlags & TERM_OK)==0 ) continue;
     pIdxCons[j].iColumn = pTerm->u.x.leftColumn;
     pIdxCons[j].iTermOffset = i;
@@ -153356,8 +153354,8 @@
 ** and possibly modified by xBestIndex methods.
 */
 static void freeIndexInfo(sqlite3 *db, sqlite3_index_info *pIdxInfo){
-  HiddenIndexInfo *pHidden = NULL;
-  int i = 0;
+  HiddenIndexInfo *pHidden;
+  int i;
   assert( pIdxInfo!=0 );
   pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
   assert( pHidden->pParse!=0 );
@@ -153387,7 +153385,7 @@
 */
 static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){
   sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;
-  int rc = 0;
+  int rc;
 
   whereTraceIndexInfoInputs(p);
   pParse->db->nSchemaLock++;
@@ -153801,7 +153799,7 @@
 ){
   int rc = SQLITE_OK;
   int nOut = pLoop->nOut;
-  LogEst nNew = 0;
+  LogEst nNew;
 
 #ifdef SQLITE_ENABLE_STAT4
   Index *p = pLoop->u.btree.pIndex;
@@ -154221,7 +154219,7 @@
 ** Increase the memory allocation for pLoop->aLTerm[] to be at least n.
 */
 static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n){
-  WhereTerm **paNew = NULL;
+  WhereTerm **paNew;
   if( p->nLSlot>=n ) return SQLITE_OK;
   n = (n+7)&~7;
   paNew = sqlite3DbMallocRawNN(db, sizeof(p->aLTerm[0])*n);
@@ -154264,7 +154262,7 @@
 ** Free a WhereInfo structure
 */
 static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){
-  int i = 0;
+  int i;
   assert( pWInfo!=0 );
   for(i=0; i<pWInfo->nLevel; i++){
     WhereLevel *pLevel = &pWInfo->a[i];
@@ -154317,7 +154315,7 @@
   const WhereLoop *pX,       /* First WhereLoop to compare */
   const WhereLoop *pY        /* Compare against this WhereLoop */
 ){
-  int i = 0, j = 0;
+  int i, j;
   if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){
     return 0; /* X is not a subset of Y */
   }
@@ -154396,7 +154394,7 @@
   WhereLoop **ppPrev,
   const WhereLoop *pTemplate
 ){
-  WhereLoop *p = NULL;
+  WhereLoop *p;
   for(p=(*ppPrev); p; ppPrev=&p->pNextLoop, p=*ppPrev){
     if( p->iTab!=pTemplate->iTab || p->iSortIdx!=pTemplate->iSortIdx ){
       /* If either the iTab or iSortIdx values for two WhereLoop are different
@@ -154481,10 +154479,10 @@
 **    (4)  The template has the same or lower cost than the current loop
 */
 static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){
-  WhereLoop **ppPrev = NULL, *p = NULL;
+  WhereLoop **ppPrev, *p;
   WhereInfo *pWInfo = pBuilder->pWInfo;
   sqlite3 *db = pWInfo->pParse->db;
-  int rc = 0;
+  int rc;
 
   /* Stop the search once we hit the query planner search limit */
   if( pBuilder->iPlanLimit==0 ){
@@ -154562,7 +154560,7 @@
     ** go through the rest of the list and delete any other entries besides
     ** p[] that are also supplated by pTemplate */
     WhereLoop **ppTail = &p->pNextLoop;
-    WhereLoop *pToDel = NULL;
+    WhereLoop *pToDel;
     while( *ppTail ){
       ppTail = whereLoopFindLesser(ppTail, pTemplate);
       if( ppTail==0 ) break;
@@ -154622,9 +154620,9 @@
   WhereLoop *pLoop,      /* The loop to adjust downward */
   LogEst nRow            /* Number of rows in the entire table */
 ){
-  WhereTerm *pTerm = NULL, *pX = NULL;
+  WhereTerm *pTerm, *pX;
   Bitmask notAllowed = ~(pLoop->prereq|pLoop->maskSelf);
-  int i = 0, j = 0;
+  int i, j;
   LogEst iReduce = 0;    /* pLoop->nOut should not exceed nRow-iReduce */
 
   assert( (pLoop->wsFlags & WHERE_AUTO_INDEX)==0 );
@@ -154713,16 +154711,16 @@
   WhereTerm *pTerm     /* The vector inequality constraint */
 ){
   int nCmp = sqlite3ExprVectorSize(pTerm->pExpr->pLeft);
-  int i = 0;
+  int i;
 
   nCmp = MIN(nCmp, (pIdx->nColumn - nEq));
   for(i=1; i<nCmp; i++){
     /* Test if comparison i of pTerm is compatible with column (i+nEq)
     ** of the index. If not, exit the loop.  */
-    char aff = 0;                     /* Comparison affinity */
+    char aff;                     /* Comparison affinity */
     char idxaff = 0;              /* Indexed columns affinity */
-    CollSeq *pColl = NULL;               /* Comparison collation sequence */
-    Expr *pLhs = NULL, *pRhs = NULL;
+    CollSeq *pColl;               /* Comparison collation sequence */
+    Expr *pLhs, *pRhs;
 
     assert( ExprUseXList(pTerm->pExpr->pLeft) );
     pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;
@@ -154788,21 +154786,21 @@
   WhereInfo *pWInfo = pBuilder->pWInfo;  /* WHERE analyse context */
   Parse *pParse = pWInfo->pParse;        /* Parsing context */
   sqlite3 *db = pParse->db;       /* Database connection malloc context */
-  WhereLoop *pNew = NULL;                /* Template WhereLoop under construction */
-  WhereTerm *pTerm = NULL;               /* A WhereTerm under consideration */
-  int opMask = 0;                     /* Valid operators for constraints */
+  WhereLoop *pNew;                /* Template WhereLoop under construction */
+  WhereTerm *pTerm;               /* A WhereTerm under consideration */
+  int opMask;                     /* Valid operators for constraints */
   WhereScan scan;                 /* Iterator for WHERE terms */
-  Bitmask saved_prereq = 0;           /* Original value of pNew->prereq */
-  u16 saved_nLTerm = 0;               /* Original value of pNew->nLTerm */
-  u16 saved_nEq = 0;                  /* Original value of pNew->u.btree.nEq */
-  u16 saved_nBtm = 0;                 /* Original value of pNew->u.btree.nBtm */
-  u16 saved_nTop = 0;                 /* Original value of pNew->u.btree.nTop */
-  u16 saved_nSkip = 0;                /* Original value of pNew->nSkip */
-  u32 saved_wsFlags = 0;              /* Original value of pNew->wsFlags */
-  LogEst saved_nOut = 0;              /* Original value of pNew->nOut */
+  Bitmask saved_prereq;           /* Original value of pNew->prereq */
+  u16 saved_nLTerm;               /* Original value of pNew->nLTerm */
+  u16 saved_nEq;                  /* Original value of pNew->u.btree.nEq */
+  u16 saved_nBtm;                 /* Original value of pNew->u.btree.nBtm */
+  u16 saved_nTop;                 /* Original value of pNew->u.btree.nTop */
+  u16 saved_nSkip;                /* Original value of pNew->nSkip */
+  u32 saved_wsFlags;              /* Original value of pNew->wsFlags */
+  LogEst saved_nOut;              /* Original value of pNew->nOut */
   int rc = SQLITE_OK;             /* Return code */
-  LogEst rSize = 0;                   /* Number of rows in the table */
-  LogEst rLogSize = 0;                /* Logarithm of table size */
+  LogEst rSize;                   /* Number of rows in the table */
+  LogEst rLogSize;                /* Logarithm of table size */
   WhereTerm *pTop = 0, *pBtm = 0; /* Top and bottom range constraints */
 
   pNew = pBuilder->pNew;
@@ -154840,8 +154838,8 @@
   rLogSize = estLog(rSize);
   for(; rc==SQLITE_OK && pTerm!=0; pTerm = whereScanNext(&scan)){
     u16 eOp = pTerm->eOperator;   /* Shorthand for pTerm->eOperator */
-    LogEst rCostIdx = 0;
-    LogEst nOutUnadjusted = 0;        /* nOut before IN() and WHERE adjustments */
+    LogEst rCostIdx;
+    LogEst nOutUnadjusted;        /* nOut before IN() and WHERE adjustments */
     int nIn = 0;
 #ifdef SQLITE_ENABLE_STAT4
     int nRecValid = pBuilder->nRecValid;
@@ -154890,7 +154888,7 @@
       Expr *pExpr = pTerm->pExpr;
       if( ExprUseXSelect(pExpr) ){
         /* "x IN (SELECT ...)":  TUNING: the SELECT returns 25 rows */
-        int i = 0;
+        int i;
         nIn = 46;  assert( 46==sqlite3LogEst(25) );
 
         /* The expression may actually be of the form (x, y) IN (SELECT...).
@@ -154906,7 +154904,7 @@
         nIn = sqlite3LogEst(pExpr->x.pList->nExpr);
       }
       if( pProbe->hasStat1 && rLogSize>=10 ){
-        LogEst M = 0, logK = 0, x = 0;
+        LogEst M, logK, x;
         /* Let:
         **   N = the total number of rows in the table
         **   K = the number of entries on the RHS of the IN operator
@@ -155149,7 +155147,7 @@
    && pProbe->aiRowLogEst[saved_nEq+1]>=42  /* TUNING: Minimum for skip-scan */
    && (rc = whereLoopResize(db, pNew, pNew->nLTerm+1))==SQLITE_OK
   ){
-    LogEst nIter = 0;
+    LogEst nIter;
     pNew->u.btree.nEq++;
     pNew->nSkip++;
     pNew->aLTerm[pNew->nLTerm++] = 0;
@@ -155184,9 +155182,9 @@
   Index *pIndex,
   int iCursor
 ){
-  ExprList *pOB = NULL;
-  ExprList *aColExpr = NULL;
-  int ii = 0, jj = 0;
+  ExprList *pOB;
+  ExprList *aColExpr;
+  int ii, jj;
 
   if( pIndex->bUnordered ) return 0;
   if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;
@@ -155219,8 +155217,8 @@
   WhereClause *pWC,     /* The WHERE clause of the query */
   Expr *pWhere          /* The WHERE clause from the partial index */
 ){
-  int i = 0;
-  WhereTerm *pTerm = NULL;
+  int i;
+  WhereTerm *pTerm;
   Parse *pParse = pWC->pWInfo->pParse;
   while( pWhere->op==TK_AND ){
     if( !whereUsablePartialIndex(iTab,isLeft,pWC,pWhere->pLeft) ) return 0;
@@ -155228,7 +155226,7 @@
   }
   if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;
   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
-    Expr *pExpr = NULL;
+    Expr *pExpr;
     pExpr = pTerm->pExpr;
     if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->w.iRightJoinTable==iTab)
      && (isLeft==0 || ExprHasProperty(pExpr, EP_FromJoin))
@@ -155281,20 +155279,20 @@
   WhereLoopBuilder *pBuilder, /* WHERE clause information */
   Bitmask mPrereq             /* Extra prerequesites for using this table */
 ){
-  WhereInfo *pWInfo = NULL;          /* WHERE analysis context */
-  Index *pProbe = NULL;              /* An index we are evaluating */
+  WhereInfo *pWInfo;          /* WHERE analysis context */
+  Index *pProbe;              /* An index we are evaluating */
   Index sPk;                  /* A fake index object for the primary key */
   LogEst aiRowEstPk[2];       /* The aiRowLogEst[] value for the sPk index */
   i16 aiColumnPk = -1;        /* The aColumn[] value for the sPk index */
-  SrcList *pTabList = NULL;          /* The FROM clause */
-  SrcItem *pSrc = NULL;              /* The FROM clause btree term to add */
-  WhereLoop *pNew = NULL;            /* Template WhereLoop object */
+  SrcList *pTabList;          /* The FROM clause */
+  SrcItem *pSrc;              /* The FROM clause btree term to add */
+  WhereLoop *pNew;            /* Template WhereLoop object */
   int rc = SQLITE_OK;         /* Return code */
   int iSortIdx = 1;           /* Index number */
-  int b = 0;                      /* A boolean value */
-  LogEst rSize = 0;               /* number of rows in the table */
-  WhereClause *pWC = NULL;           /* The parsed WHERE clause */
-  Table *pTab = NULL;                /* Table being queried */
+  int b;                      /* A boolean value */
+  LogEst rSize;               /* number of rows in the table */
+  WhereClause *pWC;           /* The parsed WHERE clause */
+  Table *pTab;                /* Table being queried */
 
   pNew = pBuilder->pNew;
   pWInfo = pBuilder->pWInfo;
@@ -155315,7 +155313,7 @@
     ** variable sPk to represent the rowid primary key index.  Make this
     ** fake index the first in a chain of Index objects with all of the real
     ** indices to follow */
-    Index *pFirst = NULL;                  /* First of real indices on the table */
+    Index *pFirst;                  /* First of real indices on the table */
     memset(&sPk, 0, sizeof(Index));
     sPk.nKeyCol = 1;
     sPk.nColumn = 1;
@@ -155349,8 +155347,8 @@
    && !pSrc->fg.isRecursive  /* Not a recursive common table expression. */
   ){
     /* Generate auto-index WhereLoops */
-    LogEst rLogSize = 0;         /* Logarithm of the number of rows in the table */
-    WhereTerm *pTerm = NULL;
+    LogEst rLogSize;         /* Logarithm of the number of rows in the table */
+    WhereTerm *pTerm;
     WhereTerm *pWCEnd = pWC->a + pWC->nTerm;
     rLogSize = estLog(rSize);
     for(pTerm=pWC->a; rc==SQLITE_OK && pTerm<pWCEnd; pTerm++){
@@ -155449,7 +155447,7 @@
       pNew->nOut = rSize;
       if( rc ) break;
     }else{
-      Bitmask m = 0;
+      Bitmask m;
       if( pProbe->isCovering ){
         pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;
         m = 0;
@@ -155484,7 +155482,7 @@
           ** satisfied using just the index, and that do not require a
           ** table lookup. */
           LogEst nLookup = rSize + 16;  /* Base cost:  N*3 */
-          int ii = 0;
+          int ii;
           int iCur = pSrc->iCursor;
           WhereClause *pWC2 = &pWInfo->sWC;
           for(ii=0; ii<pWC2->nTerm; ii++){
@@ -155573,10 +155571,10 @@
 ){
   WhereClause *pWC = pBuilder->pWC;
   HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
-  struct sqlite3_index_constraint *pIdxCons = NULL;
+  struct sqlite3_index_constraint *pIdxCons;
   struct sqlite3_index_constraint_usage *pUsage = pIdxInfo->aConstraintUsage;
-  int i = 0;
-  int mxTerm = 0;
+  int i;
+  int mxTerm;
   int rc = SQLITE_OK;
   WhereLoop *pNew = pBuilder->pNew;
   Parse *pParse = pBuilder->pWInfo->pParse;
@@ -155633,9 +155631,9 @@
   memset(&pNew->u.vtab, 0, sizeof(pNew->u.vtab));
   pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
   for(i=0; i<nConstraint; i++, pIdxCons++){
-    int iTerm = 0;
+    int iTerm;
     if( (iTerm = pUsage[i].argvIndex - 1)>=0 ){
-      WhereTerm *pTerm = NULL;
+      WhereTerm *pTerm;
       int j = pIdxCons->iTermOffset;
       if( iTerm>=nConstraint
        || j<0
@@ -155881,16 +155879,16 @@
   Bitmask mUnusable            /* Tables that must be scanned after this one */
 ){
   int rc = SQLITE_OK;          /* Return code */
-  WhereInfo *pWInfo = NULL;           /* WHERE analysis context */
-  Parse *pParse = NULL;               /* The parsing context */
-  WhereClause *pWC = NULL;            /* The WHERE clause */
-  SrcItem *pSrc = NULL;               /* The FROM clause term to search */
-  sqlite3_index_info *p = NULL;       /* Object to pass to xBestIndex() */
-  int nConstraint = 0;             /* Number of constraints in p */
-  int bIn = 0;                     /* True if plan uses IN(...) operator */
-  WhereLoop *pNew = NULL;
-  Bitmask mBest = 0;               /* Tables used by best possible plan */
-  u16 mNoOmit = 0;
+  WhereInfo *pWInfo;           /* WHERE analysis context */
+  Parse *pParse;               /* The parsing context */
+  WhereClause *pWC;            /* The WHERE clause */
+  SrcItem *pSrc;               /* The FROM clause term to search */
+  sqlite3_index_info *p;       /* Object to pass to xBestIndex() */
+  int nConstraint;             /* Number of constraints in p */
+  int bIn;                     /* True if plan uses IN(...) operator */
+  WhereLoop *pNew;
+  Bitmask mBest;               /* Tables used by best possible plan */
+  u16 mNoOmit;
   int bRetry = 0;              /* True to retry with LIMIT/OFFSET disabled */
 
   assert( (mPrereq & mUnusable)==0 );
@@ -155953,7 +155951,7 @@
     /* Call xBestIndex once for each distinct value of (prereqRight & ~mPrereq)
     ** in the set of terms that apply to the current virtual table.  */
     while( rc==SQLITE_OK ){
-      int i = 0;
+      int i;
       Bitmask mNext = ALLBITS;
       assert( mNext>0 );
       for(i=0; i<nConstraint; i++){
@@ -156012,15 +156010,15 @@
   Bitmask mUnusable
 ){
   WhereInfo *pWInfo = pBuilder->pWInfo;
-  WhereClause *pWC = NULL;
-  WhereLoop *pNew = NULL;
-  WhereTerm *pTerm = NULL, *pWCEnd = NULL;
+  WhereClause *pWC;
+  WhereLoop *pNew;
+  WhereTerm *pTerm, *pWCEnd;
   int rc = SQLITE_OK;
-  int iCur = 0;
+  int iCur;
   WhereClause tempWC;
   WhereLoopBuilder sSubBuild;
   WhereOrSet sSum, sCur;
-  SrcItem *pItem = NULL;
+  SrcItem *pItem;
 
   pWC = pBuilder->pWC;
   pWCEnd = pWC->a + pWC->nTerm;
@@ -156035,9 +156033,9 @@
     ){
       WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;
       WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];
-      WhereTerm *pOrTerm = NULL;
+      WhereTerm *pOrTerm;
       int once = 1;
-      int i = 0, j = 0;
+      int i, j;
 
       sSubBuild = *pBuilder;
       sSubBuild.pOrSet = &sCur;
@@ -156136,13 +156134,13 @@
   WhereInfo *pWInfo = pBuilder->pWInfo;
   Bitmask mPrereq = 0;
   Bitmask mPrior = 0;
-  int iTab = 0;
+  int iTab;
   SrcList *pTabList = pWInfo->pTabList;
-  SrcItem *pItem = NULL;
+  SrcItem *pItem;
   SrcItem *pEnd = &pTabList->a[pWInfo->nLevel];
   sqlite3 *db = pWInfo->pParse->db;
   int rc = SQLITE_OK;
-  WhereLoop *pNew = NULL;
+  WhereLoop *pNew;
 
   /* Loop over the tables in the join, from left to right */
   pNew = pBuilder->pNew;
@@ -156162,7 +156160,7 @@
     }
 #ifndef SQLITE_OMIT_VIRTUALTABLE
     if( IsVirtual(pItem->pTab) ){
-      SrcItem *p = NULL;
+      SrcItem *p;
       for(p=&pItem[1]; p<pEnd; p++){
         if( mUnusable || (p->fg.jointype & (JT_LEFT|JT_CROSS)) ){
           mUnusable |= sqlite3WhereGetMask(&pWInfo->sMaskSet, p->iCursor);
@@ -156219,30 +156217,30 @@
   WhereLoop *pLast,     /* Add this WhereLoop to the end of pPath->aLoop[] */
   Bitmask *pRevMask     /* OUT: Mask of WhereLoops to run in reverse order */
 ){
-  u8 revSet = 0;            /* True if rev is known */
-  u8 rev = 0;               /* Composite sort order */
-  u8 revIdx = 0;            /* Index sort order */
-  u8 isOrderDistinct = 0;   /* All prior WhereLoops are order-distinct */
-  u8 distinctColumns = 0;   /* True if the loop has UNIQUE NOT NULL columns */
-  u8 isMatch = 0;           /* iColumn matches a term of the ORDER BY clause */
-  u16 eqOpMask = 0;         /* Allowed equality operators */
-  u16 nKeyCol = 0;          /* Number of key columns in pIndex */
-  u16 nColumn = 0;          /* Total number of ordered columns in the index */
-  u16 nOrderBy = 0;         /* Number terms in the ORDER BY clause */
-  int iLoop = 0;            /* Index of WhereLoop in pPath being processed */
-  int i = 0, j = 0;             /* Loop counters */
-  int iCur = 0;             /* Cursor number for current WhereLoop */
-  int iColumn = 0;          /* A column number within table iCur */
+  u8 revSet;            /* True if rev is known */
+  u8 rev;               /* Composite sort order */
+  u8 revIdx;            /* Index sort order */
+  u8 isOrderDistinct;   /* All prior WhereLoops are order-distinct */
+  u8 distinctColumns;   /* True if the loop has UNIQUE NOT NULL columns */
+  u8 isMatch;           /* iColumn matches a term of the ORDER BY clause */
+  u16 eqOpMask;         /* Allowed equality operators */
+  u16 nKeyCol;          /* Number of key columns in pIndex */
+  u16 nColumn;          /* Total number of ordered columns in the index */
+  u16 nOrderBy;         /* Number terms in the ORDER BY clause */
+  int iLoop;            /* Index of WhereLoop in pPath being processed */
+  int i, j;             /* Loop counters */
+  int iCur;             /* Cursor number for current WhereLoop */
+  int iColumn;          /* A column number within table iCur */
   WhereLoop *pLoop = 0; /* Current WhereLoop being processed. */
-  WhereTerm *pTerm = NULL;     /* A single term of the WHERE clause */
-  Expr *pOBExpr = NULL;        /* An expression from the ORDER BY clause */
-  CollSeq *pColl = NULL;       /* COLLATE function from an ORDER BY clause term */
-  Index *pIndex = NULL;        /* The index associated with pLoop */
+  WhereTerm *pTerm;     /* A single term of the WHERE clause */
+  Expr *pOBExpr;        /* An expression from the ORDER BY clause */
+  CollSeq *pColl;       /* COLLATE function from an ORDER BY clause term */
+  Index *pIndex;        /* The index associated with pLoop */
   sqlite3 *db = pWInfo->pParse->db;  /* Database connection */
   Bitmask obSat = 0;    /* Mask of ORDER BY terms satisfied so far */
-  Bitmask obDone = 0;       /* Mask of all ORDER BY terms */
-  Bitmask orderDistinctMask = 0;  /* Mask of all well-ordered loops */
-  Bitmask ready = 0;              /* Mask of inner loops */
+  Bitmask obDone;       /* Mask of all ORDER BY terms */
+  Bitmask orderDistinctMask;  /* Mask of all well-ordered loops */
+  Bitmask ready;              /* Mask of inner loops */
 
   /*
   ** We say the WhereLoop is "one-row" if it generates no more than one
@@ -156508,8 +156506,8 @@
     if( isOrderDistinct ){
       orderDistinctMask |= pLoop->maskSelf;
       for(i=0; i<nOrderBy; i++){
-        Expr *p = NULL;
-        Bitmask mTerm = 0;
+        Expr *p;
+        Bitmask mTerm;
         if( MASKBIT(i) & obSat ) continue;
         p = pOrderBy->a[i].pExpr;
         mTerm = sqlite3WhereExprUsage(&pWInfo->sMaskSet,p);
@@ -156598,7 +156596,7 @@
   ** The (Y/X) term is implemented using stack variable rScale
   ** below.
   */
-  LogEst rScale = 0, rSortCost = 0;
+  LogEst rScale, rSortCost;
   assert( nOrderBy>0 && 66==sqlite3LogEst(100) );
   rScale = sqlite3LogEst((nOrderBy-nSorted)*100/nOrderBy) - 66;
   rSortCost = nRow + rScale + 16;
@@ -156632,26 +156630,26 @@
 ** error occurs.
 */
 static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
-  int mxChoice = 0;             /* Maximum number of simultaneous paths tracked */
-  int nLoop = 0;                /* Number of terms in the join */
-  Parse *pParse = NULL;            /* Parsing context */
-  sqlite3 *db = NULL;              /* The database connection */
-  int iLoop = 0;                /* Loop counter over the terms of the join */
-  int ii = 0, jj = 0;               /* Loop counters */
+  int mxChoice;             /* Maximum number of simultaneous paths tracked */
+  int nLoop;                /* Number of terms in the join */
+  Parse *pParse;            /* Parsing context */
+  sqlite3 *db;              /* The database connection */
+  int iLoop;                /* Loop counter over the terms of the join */
+  int ii, jj;               /* Loop counters */
   int mxI = 0;              /* Index of next entry to replace */
-  int nOrderBy = 0;             /* Number of ORDER BY clause terms */
+  int nOrderBy;             /* Number of ORDER BY clause terms */
   LogEst mxCost = 0;        /* Maximum cost of a set of paths */
   LogEst mxUnsorted = 0;    /* Maximum unsorted cost of a set of path */
-  int nTo = 0, nFrom = 0;           /* Number of valid entries in aTo[] and aFrom[] */
-  WherePath *aFrom = NULL;         /* All nFrom paths at the previous level */
-  WherePath *aTo = NULL;           /* The nTo best paths at the current level */
-  WherePath *pFrom = NULL;         /* An element of aFrom[] that we are working on */
-  WherePath *pTo = NULL;           /* An element of aTo[] that we are working on */
-  WhereLoop *pWLoop = NULL;        /* One of the WhereLoop objects */
-  WhereLoop **pX = NULL;           /* Used to divy up the pSpace memory */
+  int nTo, nFrom;           /* Number of valid entries in aTo[] and aFrom[] */
+  WherePath *aFrom;         /* All nFrom paths at the previous level */
+  WherePath *aTo;           /* The nTo best paths at the current level */
+  WherePath *pFrom;         /* An element of aFrom[] that we are working on */
+  WherePath *pTo;           /* An element of aTo[] that we are working on */
+  WhereLoop *pWLoop;        /* One of the WhereLoop objects */
+  WhereLoop **pX;           /* Used to divy up the pSpace memory */
   LogEst *aSortCost = 0;    /* Sorting and partial sorting costs */
-  char *pSpace = NULL;             /* Temporary memory used by this routine */
-  int nSpace = 0;               /* Bytes of space allocated at pSpace */
+  char *pSpace;             /* Temporary memory used by this routine */
+  int nSpace;               /* Bytes of space allocated at pSpace */
 
   pParse = pWInfo->pParse;
   db = pParse->db;
@@ -156724,11 +156722,11 @@
     nTo = 0;
     for(ii=0, pFrom=aFrom; ii<nFrom; ii++, pFrom++){
       for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){
-        LogEst nOut = 0;                      /* Rows visited by (pFrom+pWLoop) */
-        LogEst rCost = 0;                     /* Cost of path (pFrom+pWLoop) */
-        LogEst rUnsorted = 0;                 /* Unsorted cost of (pFrom+pWLoop) */
+        LogEst nOut;                      /* Rows visited by (pFrom+pWLoop) */
+        LogEst rCost;                     /* Cost of path (pFrom+pWLoop) */
+        LogEst rUnsorted;                 /* Unsorted cost of (pFrom+pWLoop) */
         i8 isOrdered = pFrom->isOrdered;  /* isOrdered for (pFrom+pWLoop) */
-        Bitmask maskNew = 0;                  /* Mask of src visited by (..) */
+        Bitmask maskNew;                  /* Mask of src visited by (..) */
         Bitmask revMask = 0;              /* Mask of rev-order loops for (..) */
 
         if( (pWLoop->prereq & ~pFrom->maskLoop)!=0 ) continue;
@@ -156948,7 +156946,7 @@
    && pWInfo->eDistinct==WHERE_DISTINCT_NOOP
    && nRowEst
   ){
-    Bitmask notUsed = 0;
+    Bitmask notUsed;
     int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pResultSet, pFrom,
                  WHERE_DISTINCTBY, nLoop-1, pFrom->aLoop[nLoop-1], &notUsed);
     if( rc==pWInfo->pResultSet->nExpr ){
@@ -157024,15 +157022,15 @@
 ** general-purpose query planner.
 */
 static int whereShortCut(WhereLoopBuilder *pBuilder){
-  WhereInfo *pWInfo = NULL;
-  SrcItem *pItem = NULL;
-  WhereClause *pWC = NULL;
-  WhereTerm *pTerm = NULL;
-  WhereLoop *pLoop = NULL;
-  int iCur = 0;
-  int j = 0;
-  Table *pTab = NULL;
-  Index *pIdx = NULL;
+  WhereInfo *pWInfo;
+  SrcItem *pItem;
+  WhereClause *pWC;
+  WhereTerm *pTerm;
+  WhereLoop *pLoop;
+  int iCur;
+  int j;
+  Table *pTab;
+  Index *pIdx;
   WhereScan scan;
 
   pWInfo = pBuilder->pWInfo;
@@ -157059,7 +157057,7 @@
     pLoop->rRun = 33;  /* 33==sqlite3LogEst(10) */
   }else{
     for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-      int opMask = 0;
+      int opMask;
       assert( pLoop->aLTermSpace==pLoop->aLTerm );
       if( !IsUniqueIndex(pIdx)
        || pIdx->pPartIdxWhere!=0
@@ -157192,8 +157190,8 @@
   WhereInfo *pWInfo,
   Bitmask notReady
 ){
-  int i = 0;
-  Bitmask tabUsed = 0;
+  int i;
+  Bitmask tabUsed;
 
   /* Preconditions checked by the caller */
   assert( pWInfo->nLevel>=2 );
@@ -157209,9 +157207,9 @@
     tabUsed |= sqlite3WhereExprListUsage(&pWInfo->sMaskSet, pWInfo->pOrderBy);
   }
   for(i=pWInfo->nLevel-1; i>=1; i--){
-    WhereTerm *pTerm = NULL, *pEnd = NULL;
-    SrcItem *pItem = NULL;
-    WhereLoop *pLoop = NULL;
+    WhereTerm *pTerm, *pEnd;
+    SrcItem *pItem;
+    WhereLoop *pLoop;
     pLoop = pWInfo->a[i].pWLoop;
     pItem = &pWInfo->pTabList->a[pLoop->iTab];
     if( (pItem->fg.jointype & JT_LEFT)==0 ) continue;
@@ -157270,8 +157268,8 @@
 static SQLITE_NOINLINE void whereCheckIfBloomFilterIsUseful(
   const WhereInfo *pWInfo
 ){
-  int i = 0;
-  LogEst nSearch = 0;
+  int i;
+  LogEst nSearch;
 
   assert( pWInfo->nLevel>=2 );
   assert( OptimizationEnabled(pWInfo->pParse->db, SQLITE_BloomFilter) );
@@ -157402,18 +157400,18 @@
   int iAuxArg             /* If WHERE_OR_SUBCLAUSE is set, index cursor number
                           ** If WHERE_USE_LIMIT, then the limit amount */
 ){
-  int nByteWInfo = 0;            /* Num. bytes allocated for WhereInfo struct */
-  int nTabList = 0;              /* Number of elements in pTabList */
-  WhereInfo *pWInfo = NULL;         /* Will become the return value of this function */
+  int nByteWInfo;            /* Num. bytes allocated for WhereInfo struct */
+  int nTabList;              /* Number of elements in pTabList */
+  WhereInfo *pWInfo;         /* Will become the return value of this function */
   Vdbe *v = pParse->pVdbe;   /* The virtual database engine */
-  Bitmask notReady = 0;          /* Cursors that are not yet positioned */
+  Bitmask notReady;          /* Cursors that are not yet positioned */
   WhereLoopBuilder sWLB;     /* The WhereLoop builder */
-  WhereMaskSet *pMaskSet = NULL;    /* The expression mask set */
-  WhereLevel *pLevel = NULL;        /* A single level in pWInfo->a[] */
-  WhereLoop *pLoop = NULL;          /* Pointer to a single WhereLoop object */
-  int ii = 0;                    /* Loop counter */
-  sqlite3 *db = NULL;               /* Database connection */
-  int rc = 0;                    /* Return code */
+  WhereMaskSet *pMaskSet;    /* The expression mask set */
+  WhereLevel *pLevel;        /* A single level in pWInfo->a[] */
+  WhereLoop *pLoop;          /* Pointer to a single WhereLoop object */
+  int ii;                    /* Loop counter */
+  sqlite3 *db;               /* Database connection */
+  int rc;                    /* Return code */
   u8 bFordelete = 0;         /* OPFLAG_FORDELETE or zero, as appropriate */
 
   assert( (wctrlFlags & WHERE_ONEPASS_MULTIROW)==0 || (
@@ -157758,9 +157756,9 @@
   ** searching those tables.
   */
   for(ii=0, pLevel=pWInfo->a; ii<nTabList; ii++, pLevel++){
-    Table *pTab = NULL;     /* Table to open */
-    int iDb = 0;         /* Index of database containing table/index */
-    SrcItem *pTabItem = NULL;
+    Table *pTab;     /* Table to open */
+    int iDb;         /* Index of database containing table/index */
+    SrcItem *pTabItem;
 
     pTabItem = &pTabList->a[pLevel->iFrom];
     pTab = pTabItem->pTab;
@@ -157820,7 +157818,7 @@
     }
     if( pLoop->wsFlags & WHERE_INDEXED ){
       Index *pIx = pLoop->u.btree.pIndex;
-      int iIndexCur = 0;
+      int iIndexCur;
       int op = OP_OpenRead;
       /* iAuxArg is always set to a positive value if ONEPASS is possible */
       assert( iAuxArg!=0 || (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED)==0 );
@@ -157890,8 +157888,8 @@
   ** program.
   */
   for(ii=0; ii<nTabList; ii++){
-    int addrExplain = 0;
-    int wsFlags = 0;
+    int addrExplain;
+    int wsFlags;
     if( pParse->nErr ) goto whereBeginError;
     pLevel = &pWInfo->a[ii];
     wsFlags = pLevel->pWLoop->wsFlags;
@@ -157980,9 +157978,9 @@
 SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
   Parse *pParse = pWInfo->pParse;
   Vdbe *v = pParse->pVdbe;
-  int i = 0;
-  WhereLevel *pLevel = NULL;
-  WhereLoop *pLoop = NULL;
+  int i;
+  WhereLevel *pLevel;
+  WhereLoop *pLoop;
   SrcList *pTabList = pWInfo->pTabList;
   sqlite3 *db = pParse->db;
   int iEnd = sqlite3VdbeCurrentAddr(v);
@@ -157991,14 +157989,14 @@
   */
   VdbeModuleComment((v, "End WHERE-core"));
   for(i=pWInfo->nLevel-1; i>=0; i--){
-    int addr = 0;
+    int addr;
     pLevel = &pWInfo->a[i];
     pLoop = pLevel->pWLoop;
     if( pLevel->op!=OP_Noop ){
 #ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT
       int addrSeek = 0;
-      Index *pIdx = NULL;
-      int n = 0;
+      Index *pIdx;
+      int n;
       if( pWInfo->eDistinct==WHERE_DISTINCT_ORDERED
        && i==pWInfo->nLevel-1  /* Ticket [ef9318757b152e3] 2017-10-21 */
        && (pLoop->wsFlags & WHERE_INDEXED)!=0
@@ -158007,7 +158005,7 @@
        && pIdx->aiRowLogEst[n]>=36
       ){
         int r1 = pParse->nMem+1;
-        int j = 0, op = 0;
+        int j, op;
         for(j=0; j<n; j++){
           sqlite3VdbeAddOp3(v, OP_Column, pLevel->iIdxCur, j, r1+j);
         }
@@ -158039,8 +158037,8 @@
       sqlite3VdbeResolveLabel(v, pLevel->addrCont);
     }
     if( (pLoop->wsFlags & WHERE_IN_ABLE)!=0 && pLevel->u.in.nIn>0 ){
-      struct InLoop *pIn = NULL;
-      int j = 0;
+      struct InLoop *pIn;
+      int j;
       sqlite3VdbeResolveLabel(v, pLevel->addrNxt);
       for(j=pLevel->u.in.nIn, pIn=&pLevel->u.in.aInLoop[j-1]; j>0; j--, pIn--){
         assert( sqlite3VdbeGetOp(v, pIn->addrInTop+1)->opcode==OP_IsNull
@@ -158135,8 +158133,8 @@
 
   assert( pWInfo->nLevel<=pTabList->nSrc );
   for(i=0, pLevel=pWInfo->a; i<pWInfo->nLevel; i++, pLevel++){
-    int k = 0, last = 0;
-    VdbeOp *pOp = NULL, *pLastOp = NULL;
+    int k, last;
+    VdbeOp *pOp, *pLastOp;
     Index *pIdx = 0;
     SrcItem *pTabItem = &pTabList->a[pLevel->iFrom];
     Table *pTab = pTabItem->pTab;
@@ -158469,14 +158467,14 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ) p->nStep = 1;
   UNUSED_PARAMETER(nArg);
   UNUSED_PARAMETER(apArg);
 }
 static void dense_rankValueFunc(sqlite3_context *pCtx){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ){
     if( p->nStep ){
@@ -158501,10 +158499,10 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct NthValueCtx *p = NULL;
+  struct NthValueCtx *p;
   p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ){
-    i64 iVal = 0;
+    i64 iVal;
     switch( sqlite3_value_numeric_type(apArg[1]) ){
       case SQLITE_INTEGER:
         iVal = sqlite3_value_int64(apArg[1]);
@@ -158538,7 +158536,7 @@
   );
 }
 static void nth_valueFinalizeFunc(sqlite3_context *pCtx){
-  struct NthValueCtx *p = NULL;
+  struct NthValueCtx *p;
   p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);
   if( p && p->pValue ){
     sqlite3_result_value(pCtx, p->pValue);
@@ -158554,7 +158552,7 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct NthValueCtx *p = NULL;
+  struct NthValueCtx *p;
   p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p && p->pValue==0 ){
     p->pValue = sqlite3_value_dup(apArg[0]);
@@ -158566,7 +158564,7 @@
   UNUSED_PARAMETER(apArg);
 }
 static void first_valueFinalizeFunc(sqlite3_context *pCtx){
-  struct NthValueCtx *p = NULL;
+  struct NthValueCtx *p;
   p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p && p->pValue ){
     sqlite3_result_value(pCtx, p->pValue);
@@ -158588,7 +158586,7 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ){
     p->nStep++;
@@ -158600,7 +158598,7 @@
   UNUSED_PARAMETER(apArg);
 }
 static void rankValueFunc(sqlite3_context *pCtx){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ){
     sqlite3_result_int64(pCtx, p->nValue);
@@ -158619,7 +158617,7 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   UNUSED_PARAMETER(nArg); assert( nArg==0 );
   UNUSED_PARAMETER(apArg);
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
@@ -158632,14 +158630,14 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   UNUSED_PARAMETER(nArg); assert( nArg==0 );
   UNUSED_PARAMETER(apArg);
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   p->nStep++;
 }
 static void percent_rankValueFunc(sqlite3_context *pCtx){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ){
     p->nValue = p->nStep;
@@ -158664,7 +158662,7 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   UNUSED_PARAMETER(nArg); assert( nArg==0 );
   UNUSED_PARAMETER(apArg);
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
@@ -158677,14 +158675,14 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   UNUSED_PARAMETER(nArg); assert( nArg==0 );
   UNUSED_PARAMETER(apArg);
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   p->nStep++;
 }
 static void cume_distValueFunc(sqlite3_context *pCtx){
-  struct CallCount *p = NULL;
+  struct CallCount *p;
   p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);
   if( p ){
     double r = (double)(p->nStep) / (double)(p->nTotal);
@@ -158713,7 +158711,7 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct NtileCtx *p = NULL;
+  struct NtileCtx *p;
   assert( nArg==1 ); UNUSED_PARAMETER(nArg);
   p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ){
@@ -158733,14 +158731,14 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct NtileCtx *p = NULL;
+  struct NtileCtx *p;
   assert( nArg==1 ); UNUSED_PARAMETER(nArg);
   UNUSED_PARAMETER(apArg);
   p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   p->iRow++;
 }
 static void ntileValueFunc(sqlite3_context *pCtx){
-  struct NtileCtx *p = NULL;
+  struct NtileCtx *p;
   p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p && p->nParam>0 ){
     int nSize = (p->nTotal / p->nParam);
@@ -158779,7 +158777,7 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct LastValueCtx *p = NULL;
+  struct LastValueCtx *p;
   UNUSED_PARAMETER(nArg);
   p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p ){
@@ -158797,7 +158795,7 @@
   int nArg,
   sqlite3_value **apArg
 ){
-  struct LastValueCtx *p = NULL;
+  struct LastValueCtx *p;
   UNUSED_PARAMETER(nArg);
   UNUSED_PARAMETER(apArg);
   p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
@@ -158810,14 +158808,14 @@
   }
 }
 static void last_valueValueFunc(sqlite3_context *pCtx){
-  struct LastValueCtx *p = NULL;
+  struct LastValueCtx *p;
   p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);
   if( p && p->pVal ){
     sqlite3_result_value(pCtx, p->pVal);
   }
 }
 static void last_valueFinalizeFunc(sqlite3_context *pCtx){
-  struct LastValueCtx *p = NULL;
+  struct LastValueCtx *p;
   p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
   if( p && p->pVal ){
     sqlite3_result_value(pCtx, p->pVal);
@@ -158918,7 +158916,7 @@
 }
 
 static Window *windowFind(Parse *pParse, Window *pList, const char *zName){
-  Window *p = NULL;
+  Window *p;
   for(p=pList; p; p=p->pNextWin){
     if( sqlite3StrICmp(p->zName, zName)==0 ) break;
   }
@@ -158995,7 +158993,7 @@
         { leadName,         TK_ROWS,   TK_UNBOUNDED, TK_UNBOUNDED },
         { lagName,          TK_ROWS,   TK_UNBOUNDED, TK_CURRENT },
       };
-      int i = 0;
+      int i;
       for(i=0; i<ArraySize(aUp); i++){
         if( pFunc->zName==aUp[i].zFunc ){
           sqlite3ExprDelete(db, pWin->pStart);
@@ -159050,7 +159048,7 @@
       return WRC_Continue;
     }else{
       int nSrc = p->pSrc->nSrc;
-      int i = 0;
+      int i;
       for(i=0; i<nSrc; i++){
         if( pExpr->iTable==p->pSrc->a[i].iCursor ) break;
       }
@@ -159064,7 +159062,7 @@
       if( !ExprHasProperty(pExpr, EP_WinFunc) ){
         break;
       }else{
-        Window *pWin = NULL;
+        Window *pWin;
         for(pWin=p->pWin; pWin; pWin=pWin->pNextWin){
           if( pExpr->y.pWin==pWin ){
             assert( pWin->pOwner==pExpr );
@@ -159079,7 +159077,7 @@
       int iCol = -1;
       if( pParse->db->mallocFailed ) return WRC_Abort;
       if( p->pSub ){
-        int i = 0;
+        int i;
         for(i=0; i<p->pSub->nExpr; i++){
           if( 0==sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1) ){
             iCol = i;
@@ -159184,7 +159182,7 @@
   int bIntToNull
 ){
   if( pAppend ){
-    int i = 0;
+    int i;
     int nInit = pList ? pList->nExpr : 0;
     for(i=0; i<pAppend->nExpr; i++){
       sqlite3 *db = pParse->db;
@@ -159195,8 +159193,8 @@
         break;
       }
       if( bIntToNull ){
-        int iDummy = 0;
-        Expr *pSub = NULL;
+        int iDummy;
+        Expr *pSub;
         pSub = sqlite3ExprSkipCollateAndLikely(pDup);
         if( sqlite3ExprIsInteger(pSub, &iDummy) ){
           pSub->op = TK_NULL;
@@ -159262,8 +159260,8 @@
 
     ExprList *pSublist = 0;       /* Expression list for sub-query */
     Window *pMWin = p->pWin;      /* Main window object */
-    Window *pWin = NULL;                 /* Window object iterator */
-    Table *pTab = NULL;
+    Window *pWin;                 /* Window object iterator */
+    Table *pTab;
     Walker w;
 
     u32 selFlags = p->selFlags;
@@ -159323,7 +159321,7 @@
     ** window function - one for the accumulator, another for interim
     ** results.  */
     for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
-      ExprList *pArgs = NULL;
+      ExprList *pArgs;
       assert( ExprUseXList(pWin->pOwner) );
       assert( pWin->pFunc!=0 );
       pArgs = pWin->pOwner->x.pList;
@@ -159367,7 +159365,7 @@
                                      ** of sqlite3DbMallocRawNN() called from
                                      ** sqlite3SrcListAppend() */
     if( p->pSrc ){
-      Table *pTab2 = NULL;
+      Table *pTab2;
       p->pSrc->a[0].pSelect = pSub;
       sqlite3SrcListAssignCursors(pParse, p->pSrc);
       pSub->selFlags |= SF_Expanded|SF_OrderByReqd;
@@ -159647,7 +159645,7 @@
   const Window *p2,
   int bFilter
 ){
-  int res = 0;
+  int res;
   if( NEVER(p1==0) || NEVER(p2==0) ) return 1;
   if( p1->eFrmType!=p2->eFrmType ) return 1;
   if( p1->eStart!=p2->eStart ) return 1;
@@ -159678,7 +159676,7 @@
 SQLITE_PRIVATE void sqlite3WindowCodeInit(Parse *pParse, Select *pSelect){
   int nEphExpr = pSelect->pSrc->a[0].pSelect->pEList->nExpr;
   Window *pMWin = pSelect->pWin;
-  Window *pWin = NULL;
+  Window *pWin;
   Vdbe *v = sqlite3GetVdbe(pParse);
 
   sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, nEphExpr);
@@ -159718,8 +159716,8 @@
       **   regApp+1: integer value used to ensure keys are unique
       **   regApp+2: output of MakeRecord
       */
-      ExprList *pList = NULL;
-      KeyInfo *pKeyInfo = NULL;
+      ExprList *pList;
+      KeyInfo *pKeyInfo;
       assert( ExprUseXList(pWin->pOwner) );
       pList = pWin->pOwner->x.pList;
       pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);
@@ -159810,7 +159808,7 @@
 ** with the object passed as the only argument to this function.
 */
 static int windowArgCount(Window *pWin){
-  const ExprList *pList = NULL;
+  const ExprList *pList;
   assert( ExprUseXList(pWin->pOwner) );
   pList = pWin->pOwner->x.pList;
   return (pList ? pList->nExpr : 0);
@@ -159912,7 +159910,7 @@
     Vdbe *v = sqlite3GetVdbe(p->pParse);
     ExprList *pPart = pMWin->pPartition;
     int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);
-    int i = 0;
+    int i;
     for(i=0; i<pOrderBy->nExpr; i++){
       sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);
     }
@@ -159947,12 +159945,12 @@
 ){
   Parse *pParse = p->pParse;
   Vdbe *v = sqlite3GetVdbe(pParse);
-  Window *pWin = NULL;
+  Window *pWin;
   for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
     FuncDef *pFunc = pWin->pFunc;
-    int regArg = 0;
+    int regArg;
     int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);
-    int i = 0;
+    int i;
 
     assert( bInverse==0 || pWin->eStart!=TK_UNBOUNDED );
 
@@ -159996,7 +159994,7 @@
     }else if( pFunc->xSFunc!=noopStepFunc ){
       int addrIf = 0;
       if( pWin->pFilter ){
-        int regTmp = 0;
+        int regTmp;
         assert( ExprUseXList(pWin->pOwner) );
         assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );
         assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );
@@ -160009,7 +160007,7 @@
 
       if( pWin->bExprArgs ){
         int iOp = sqlite3VdbeCurrentAddr(v);
-        int iEnd = 0;
+        int iEnd;
 
         assert( ExprUseXList(pWin->pOwner) );
         nArg = pWin->pOwner->x.pList->nExpr;
@@ -160024,7 +160022,7 @@
         }
       }
       if( pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){
-        CollSeq *pColl = NULL;
+        CollSeq *pColl;
         assert( nArg>0 );
         assert( ExprUseXList(pWin->pOwner) );
         pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);
@@ -160059,7 +160057,7 @@
   Parse *pParse = p->pParse;
   Window *pMWin = p->pMWin;
   Vdbe *v = sqlite3GetVdbe(pParse);
-  Window *pWin = NULL;
+  Window *pWin;
 
   for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
     if( pMWin->regStartRowid==0
@@ -160095,7 +160093,7 @@
 ** layer.
 */
 static void windowFullScan(WindowCodeArg *p){
-  Window *pWin = NULL;
+  Window *pWin;
   Parse *pParse = p->pParse;
   Window *pMWin = p->pMWin;
   Vdbe *v = p->pVdbe;
@@ -160105,11 +160103,11 @@
   int regRowid = 0;               /* AggStep rowid value */
   int regPeer = 0;                /* AggStep peer values */
 
-  int nPeer = 0;
-  int lblNext = 0;
-  int lblBrk = 0;
-  int addrNext = 0;
-  int csr = 0;
+  int nPeer;
+  int lblNext;
+  int lblBrk;
+  int addrNext;
+  int csr;
 
   VdbeModuleComment((v, "windowFullScan begin"));
 
@@ -160145,7 +160143,7 @@
     sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, lblNext, regRowid);
     VdbeCoverageNeverNull(v);
   }else if( pMWin->eExclude!=TK_NO ){
-    int addr = 0;
+    int addr;
     int addrEq = 0;
     KeyInfo *pKeyInfo = 0;
 
@@ -160208,7 +160206,7 @@
     windowFullScan(p);
   }else{
     Parse *pParse = p->pParse;
-    Window *pWin = NULL;
+    Window *pWin;
 
     for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
       FuncDef *pFunc = pWin->pFunc;
@@ -160279,9 +160277,9 @@
 */
 static int windowInitAccum(Parse *pParse, Window *pMWin){
   Vdbe *v = sqlite3GetVdbe(pParse);
-  int regArg = 0;
+  int regArg;
   int nArg = 0;
-  Window *pWin = NULL;
+  Window *pWin;
   for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
     FuncDef *pFunc = pWin->pFunc;
     assert( pWin->regAccum );
@@ -160310,7 +160308,7 @@
 ** even if there are no xInverse() calls required.
 */
 static int windowCacheFrame(Window *pMWin){
-  Window *pWin = NULL;
+  Window *pWin;
   if( pMWin->regStartRowid ) return 1;
   for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
     FuncDef *pFunc = pWin->pFunc;
@@ -160396,9 +160394,9 @@
   int reg2 = sqlite3GetTempReg(pParse);     /* Reg. for csr2.peerVal */
   int regString = ++pParse->nMem;           /* Reg. for constant value '' */
   int arith = OP_Add;                       /* OP_Add or OP_Subtract */
-  int addrGe = 0;                               /* Jump destination */
+  int addrGe;                               /* Jump destination */
   int addrDone = sqlite3VdbeMakeLabel(pParse);   /* Address past OP_Ge */
-  CollSeq *pColl = NULL;
+  CollSeq *pColl;
 
   /* Read the peer-value from each cursor into a register */
   windowReadPeerValues(p, csr1, reg1);
@@ -160520,7 +160518,7 @@
  int regCountdown,                /* Register for OP_IfPos countdown */
  int jumpOnEof                    /* Jump here if stepped cursor reaches EOF */
 ){
-  int csr = 0, reg = 0;
+  int csr, reg;
   Parse *pParse = p->pParse;
   Window *pMWin = p->pMWin;
   int ret = 0;
@@ -160697,7 +160695,7 @@
 ** second argument.
 */
 SQLITE_PRIVATE Window *sqlite3WindowListDup(sqlite3 *db, Window *p){
-  Window *pWin = NULL;
+  Window *pWin;
   Window *pRet = 0;
   Window **pp = &pRet;
 
@@ -161075,21 +161073,21 @@
   Window *pMWin = p->pWin;
   ExprList *pOrderBy = pMWin->pOrderBy;
   Vdbe *v = sqlite3GetVdbe(pParse);
-  int csrWrite = 0;                   /* Cursor used to write to eph. table */
+  int csrWrite;                   /* Cursor used to write to eph. table */
   int csrInput = p->pSrc->a[0].iCursor;     /* Cursor of sub-select */
   int nInput = p->pSrc->a[0].pTab->nCol;    /* Number of cols returned by sub */
-  int iInput = 0;                               /* To iterate through sub cols */
-  int addrNe = 0;                     /* Address of OP_Ne */
+  int iInput;                               /* To iterate through sub cols */
+  int addrNe;                     /* Address of OP_Ne */
   int addrGosubFlush = 0;         /* Address of OP_Gosub to flush: */
   int addrInteger = 0;            /* Address of OP_Integer */
-  int addrEmpty = 0;                  /* Address of OP_Rewind in flush: */
-  int regNew = 0;                     /* Array of registers holding new input row */
-  int regRecord = 0;                  /* regNew array in record form */
+  int addrEmpty;                  /* Address of OP_Rewind in flush: */
+  int regNew;                     /* Array of registers holding new input row */
+  int regRecord;                  /* regNew array in record form */
   int regNewPeer = 0;             /* Peer values for new row (part of regNew) */
   int regPeer = 0;                /* Peer values for current row */
   int regFlushPart = 0;           /* Register for "Gosub flush_partition" */
   WindowCodeArg s;                /* Context object for sub-routines */
-  int lblWhereEnd = 0;                /* Label just before sqlite3WhereEnd() code */
+  int lblWhereEnd;                /* Label just before sqlite3WhereEnd() code */
   int regStart = 0;               /* Value of <expr> PRECEDING */
   int regEnd = 0;                 /* Value of <expr> FOLLOWING */
 
@@ -161195,7 +161193,7 @@
   ** If so, it does an OP_Gosub to an address to be filled in later. The
   ** address of the OP_Gosub is stored in local variable addrGosubFlush. */
   if( pMWin->pPartition ){
-    int addr = 0;
+    int addr;
     ExprList *pPart = pMWin->pPartition;
     int nPart = pPart->nExpr;
     int regNewPart = regNew + pMWin->nBufferCol;
@@ -161341,10 +161339,10 @@
     if( bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
     windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
   }else if( pMWin->eStart==TK_FOLLOWING ){
-    int addrStart = 0;
-    int addrBreak1 = 0;
-    int addrBreak2 = 0;
-    int addrBreak3 = 0;
+    int addrStart;
+    int addrBreak1;
+    int addrBreak2;
+    int addrBreak3;
     windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
     if( pMWin->eFrmType==TK_RANGE ){
       addrStart = sqlite3VdbeCurrentAddr(v);
@@ -161369,8 +161367,8 @@
     sqlite3VdbeJumpHere(v, addrBreak1);
     sqlite3VdbeJumpHere(v, addrBreak3);
   }else{
-    int addrBreak = 0;
-    int addrStart = 0;
+    int addrBreak;
+    int addrStart;
     windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
     addrStart = sqlite3VdbeCurrentAddr(v);
     addrBreak = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);
@@ -161510,7 +161508,7 @@
     assert( p!=0 );
     if( p->pPrior ){
       Select *pNext = 0, *pLoop = p;
-      int mxSelect = 0, cnt = 1;
+      int mxSelect, cnt = 1;
       while(1){
         pLoop->pNext = pNext;
         pLoop->selFlags |= SF_Compound;
@@ -163842,7 +163840,7 @@
 ** is popped from the stack, then call it.
 */
 static void yy_pop_parser_stack(yyParser *pParser){
-  yyStackEntry *yytos = NULL;
+  yyStackEntry *yytos;
   assert( pParser->yytos!=0 );
   assert( pParser->yytos > pParser->yystack );
   yytos = pParser->yytos--;
@@ -163943,7 +163941,7 @@
   YYCODETYPE iLookAhead,    /* The look-ahead token */
   YYACTIONTYPE stateno      /* Current state number */
 ){
-  int i = 0;
+  int i;
 
   if( stateno>YY_MAX_SHIFT ) return stateno;
   assert( stateno <= YY_SHIFT_COUNT );
@@ -164008,7 +164006,7 @@
   YYACTIONTYPE stateno,     /* Current state number */
   YYCODETYPE iLookAhead     /* The look-ahead token */
 ){
-  int i = 0;
+  int i;
 #ifdef YYERRORSYMBOL
   if( stateno>YY_REDUCE_COUNT ){
     return yy_default[stateno];
@@ -164082,7 +164080,7 @@
   YYCODETYPE yyMajor,           /* The major token to shift in */
   sqlite3ParserTOKENTYPE yyMinor        /* The minor token to shift in */
 ){
-  yyStackEntry *yytos = NULL;
+  yyStackEntry *yytos;
   yypParser->yytos++;
 #ifdef YYTRACKMAXSTACKDEPTH
   if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
@@ -164948,10 +164946,10 @@
   sqlite3ParserTOKENTYPE yyLookaheadToken  /* Value of the lookahead token */
   sqlite3ParserCTX_PDECL                   /* %extra_context */
 ){
-  int yygoto = 0;                     /* The next state */
+  int yygoto;                     /* The next state */
   YYACTIONTYPE yyact;             /* The next action */
-  yyStackEntry *yymsp = NULL;            /* The top of the parser's stack */
-  int yysize = 0;                     /* Amount to pop the stack */
+  yyStackEntry *yymsp;            /* The top of the parser's stack */
+  int yysize;                     /* Amount to pop the stack */
   sqlite3ParserARG_FETCH
   (void)yyLookahead;
   (void)yyLookaheadToken;
@@ -165290,7 +165288,7 @@
   Select *pRhs = yymsp[0].minor.yy47;
   Select *pLhs = yymsp[-2].minor.yy47;
   if( pRhs && pRhs->pPrior ){
-    SrcList *pFrom = NULL;
+    SrcList *pFrom;
     Token x;
     x.n = 0;
     parserDoubleLinkSelect(pParse, pRhs);
@@ -165338,7 +165336,7 @@
         break;
       case 95: /* values ::= values COMMA LP nexprlist RP */
 {
-  Select *pRight = NULL, *pLeft = yymsp[-4].minor.yy47;
+  Select *pRight, *pLeft = yymsp[-4].minor.yy47;
   pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy322,0,0,0,0,0,SF_Values|SF_MultiValue,0);
   if( ALWAYS(pLeft) ) pLeft->selFlags &= ~SF_MultiValue;
   if( pRight ){
@@ -165446,7 +165444,7 @@
       }
       sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy131);
     }else{
-      Select *pSubquery = NULL;
+      Select *pSubquery;
       sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy131);
       pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy131,0,0,0,0,SF_NestedFrom,0);
       yymsp[-6].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy131,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy528,yymsp[0].minor.yy254);
@@ -165791,7 +165789,7 @@
         break;
       case 203: /* expr ::= expr likeop expr */
 {
-  ExprList *pList = NULL;
+  ExprList *pList;
   int bNot = yymsp[-1].minor.yy0.n & 0x80000000;
   yymsp[-1].minor.yy0.n &= 0x7fffffff;
   pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy528);
@@ -165803,7 +165801,7 @@
         break;
       case 204: /* expr ::= expr likeop expr ESCAPE expr */
 {
-  ExprList *pList = NULL;
+  ExprList *pList;
   int bNot = yymsp[-3].minor.yy0.n & 0x80000000;
   yymsp[-3].minor.yy0.n &= 0x7fffffff;
   pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy528);
@@ -165932,7 +165930,7 @@
         break;
       case 222: /* expr ::= EXISTS LP select RP */
 {
-    Expr *p = NULL;
+    Expr *p;
     p = yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);
     sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy47);
   }
@@ -167233,8 +167231,8 @@
 ** parser symbol code for that keyword into *pType.  Always
 ** return the integer n (the length of the token). */
 static int keywordCode(const char *z, int n, int *pType){
-  int i = 0, j = 0;
-  const char *zKW = NULL;
+  int i, j;
+  const char *zKW;
   if( n>=2 ){
     i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n*1) % 127;
     for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){
@@ -167475,7 +167473,7 @@
 */
 static int getToken(const unsigned char **pz){
   const unsigned char *z = *pz;
-  int t = 0;                          /* Token type to return */
+  int t;                          /* Token type to return */
   do {
     z += sqlite3GetToken(z, &t);
   }while( t==TK_SPACE );
@@ -167523,7 +167521,7 @@
 **   * the next token is TK_LP.
 */
 static int analyzeWindowKeyword(const unsigned char *z){
-  int t = 0;
+  int t;
   t = getToken(&z);
   if( t!=TK_ID ) return TK_ID;
   t = getToken(&z);
@@ -167550,7 +167548,7 @@
 ** Store the token type in *tokenType before returning.
 */
 SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *z, int *tokenType){
-  int i = 0, c = 0;
+  int i, c;
   switch( aiClass[*z] ){  /* Switch on the character-class of the first byte
                           ** of the token. See the comment on the CC_ defines
                           ** above. */
@@ -167845,12 +167843,12 @@
 */
 SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql){
   int nErr = 0;                   /* Number of errors encountered */
-  void *pEngine = NULL;                  /* The LEMON-generated LALR(1) parser */
+  void *pEngine;                  /* The LEMON-generated LALR(1) parser */
   int n = 0;                      /* Length of the next token token */
-  int tokenType = 0;                  /* type of the next token */
+  int tokenType;                  /* type of the next token */
   int lastTokenParsed = -1;       /* type of the previous token */
   sqlite3 *db = pParse->db;       /* The database connection */
-  int mxSqlLen = 0;                   /* Max length of an SQL string */
+  int mxSqlLen;                   /* Max length of an SQL string */
   Parse *pParentParse = 0;        /* Outer parse context, if any */
 #ifdef sqlite3Parser_ENGINEALWAYSONSTACK
   yyParser sEngine;    /* Space to hold the Lemon-generated Parser object */
@@ -168237,7 +168235,7 @@
 */
 SQLITE_API int sqlite3_complete(const char *zSql){
   u8 state = 0;   /* Current state, using numbers defined in header comment */
-  u8 token = 0;       /* Value of the next token */
+  u8 token;       /* Value of the next token */
 
 #ifndef SQLITE_OMIT_TRIGGER
   /* A complex statement machine used to detect the end of a CREATE TRIGGER
@@ -168334,7 +168332,7 @@
 #endif
         if( IdChar((u8)*zSql) ){
           /* Keywords and unquoted identifiers */
-          int nId = 0;
+          int nId;
           for(nId=1; IdChar(zSql[nId]); nId++){}
 #ifdef SQLITE_OMIT_TRIGGER
           token = tkOTHER;
@@ -168401,9 +168399,9 @@
 ** UTF-8.
 */
 SQLITE_API int sqlite3_complete16(const void *zSql){
-  sqlite3_value *pVal = NULL;
-  char const *zSql8 = NULL;
-  int rc = 0;
+  sqlite3_value *pVal;
+  char const *zSql8;
+  int rc;
 
 #ifndef SQLITE_OMIT_AUTOINIT
   rc = sqlite3_initialize();
@@ -168720,7 +168718,7 @@
 */
 SQLITE_API int sqlite3_initialize(void){
   MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )      /* The main static mutex */
-  int rc = 0;                                      /* Result code */
+  int rc;                                      /* Result code */
 #ifdef SQLITE_EXTRA_INIT
   int bRunExtraInit = 0;                       /* Extra initialization needed */
 #endif
@@ -169267,10 +169265,10 @@
 */
 static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){
 #ifndef SQLITE_OMIT_LOOKASIDE
-  void *pStart = NULL;
+  void *pStart;
   sqlite3_int64 szAlloc = sz*(sqlite3_int64)cnt;
-  int nBig = 0;   /* Number of full-size slots */
-  int nSm = 0;    /* Number smaller LOOKASIDE_SMALL-byte slots */
+  int nBig;   /* Number of full-size slots */
+  int nSm;    /* Number smaller LOOKASIDE_SMALL-byte slots */
 
   if( sqlite3LookasideUsed(db,0)>0 ){
     return SQLITE_BUSY;
@@ -169320,8 +169318,8 @@
   db->lookaside.sz = (u16)sz;
   db->lookaside.szTrue = (u16)sz;
   if( pStart ){
-    int i = 0;
-    LookasideSlot *p = NULL;
+    int i;
+    LookasideSlot *p;
     assert( sz > (int)sizeof(LookasideSlot*) );
     p = (LookasideSlot*)pStart;
     for(i=0; i<nBig; i++){
@@ -169380,7 +169378,7 @@
 ** connection.
 */
 SQLITE_API int sqlite3_db_release_memory(sqlite3 *db){
-  int i = 0;
+  int i;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
@@ -169404,7 +169402,7 @@
 ** to disk.
 */
 SQLITE_API int sqlite3_db_cacheflush(sqlite3 *db){
-  int i = 0;
+  int i;
   int rc = SQLITE_OK;
   int bSeenBusy = 0;
 
@@ -169434,7 +169432,7 @@
 */
 SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){
   va_list ap;
-  int rc = 0;
+  int rc;
   va_start(ap, op);
   switch( op ){
     case SQLITE_DBCONFIG_MAINDBNAME: {
@@ -169474,7 +169472,7 @@
         { SQLITE_DBCONFIG_LEGACY_FILE_FORMAT,    SQLITE_LegacyFileFmt  },
         { SQLITE_DBCONFIG_TRUSTED_SCHEMA,        SQLITE_TrustedSchema  },
       };
-      unsigned int i = 0;
+      unsigned int i;
       rc = SQLITE_ERROR; /* IMP: R-42790-23372 */
       for(i=0; i<ArraySize(aFlagOp); i++){
         if( aFlagOp[i].op==op ){
@@ -169512,7 +169510,7 @@
   int nKey1, const void *pKey1,
   int nKey2, const void *pKey2
 ){
-  int rc = 0, n = 0;
+  int rc, n;
   UNUSED_PARAMETER(NotUsed);
   n = nKey1<nKey2 ? nKey1 : nKey2;
   /* EVIDENCE-OF: R-65033-28449 The built-in BINARY collation compares
@@ -169656,7 +169654,7 @@
 ** with SQLITE_ANY as the encoding.
 */
 static void functionDestroy(sqlite3 *db, FuncDef *p){
-  FuncDestructor *pDestructor = NULL;
+  FuncDestructor *pDestructor;
   assert( (p->funcFlags & SQLITE_FUNC_BUILTIN)==0 );
   pDestructor = p->u.pDestructor;
   if( pDestructor ){
@@ -169674,8 +169672,8 @@
 */
 static void disconnectAllVtab(sqlite3 *db){
 #ifndef SQLITE_OMIT_VIRTUALTABLE
-  int i = 0;
-  HashElem *p = NULL;
+  int i;
+  HashElem *p;
   sqlite3BtreeEnterAll(db);
   for(i=0; i<db->nDb; i++){
     Schema *pSchema = db->aDb[i].pSchema;
@@ -169704,7 +169702,7 @@
 ** statements or unfinished sqlite3_backup objects.
 */
 static int connectionIsBusy(sqlite3 *db){
-  int j = 0;
+  int j;
   assert( sqlite3_mutex_held(db->mutex) );
   if( db->pVdbe ) return 1;
   for(j=0; j<db->nDb; j++){
@@ -169772,7 +169770,7 @@
 ** transaction state over all attached databases if zSchema is null.
 */
 SQLITE_API int sqlite3_txn_state(sqlite3 *db, const char *zSchema){
-  int iDb = 0, nDb = 0;
+  int iDb, nDb;
   int iTxn = -1;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -169819,8 +169817,8 @@
 ** finished, then free all resources.
 */
 SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db){
-  HashElem *i = NULL;                    /* Hash table iterator */
-  int j = 0;
+  HashElem *i;                    /* Hash table iterator */
+  int j;
 
   /* If there are outstanding sqlite3_stmt or sqlite3_backup objects
   ** or if the connection has not yet been closed by sqlite3_close_v2(),
@@ -169874,7 +169872,7 @@
   sqlite3ConnectionClosed(db);
 
   for(i=sqliteHashFirst(&db->aFunc); i; i=sqliteHashNext(i)){
-    FuncDef *pNext = NULL, *p = NULL;
+    FuncDef *pNext, *p;
     p = sqliteHashData(i);
     do{
       functionDestroy(db, p);
@@ -169942,9 +169940,9 @@
 ** but are "saved" in case the table pages are moved around.
 */
 SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3 *db, int tripCode){
-  int i = 0;
+  int i;
   int inTrans = 0;
-  int schemaChange = 0;
+  int schemaChange;
   assert( sqlite3_mutex_held(db->mutex) );
   sqlite3BeginBenignMalloc();
 
@@ -170225,7 +170223,7 @@
 ** returns 0, the operation aborts with an SQLITE_BUSY error.
 */
 SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){
-  int rc = 0;
+  int rc;
   if( p->xBusyHandler==0 || p->nBusy<0 ) return 0;
   rc = p->xBusyHandler(p->pBusyArg, p->nBusy);
   if( rc==0 ){
@@ -170341,8 +170339,8 @@
   void (*xInverse)(sqlite3_context*,int,sqlite3_value **),
   FuncDestructor *pDestructor
 ){
-  FuncDef *p = NULL;
-  int extraFlags = 0;
+  FuncDef *p;
+  int extraFlags;
 
   assert( sqlite3_mutex_held(db->mutex) );
   assert( xValue==0 || xSFunc==0 );
@@ -170381,7 +170379,7 @@
       enc = SQLITE_UTF16NATIVE;
       break;
     case SQLITE_ANY: {
-      int rc = 0;
+      int rc;
       rc = sqlite3CreateFunc(db, zFunctionName, nArg,
            (SQLITE_UTF8|extraFlags)^SQLITE_FUNC_UNSAFE,
            pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);
@@ -170567,8 +170565,8 @@
   void (*xStep)(sqlite3_context*,int,sqlite3_value**),
   void (*xFinal)(sqlite3_context*)
 ){
-  int rc = 0;
-  char *zFunc8 = NULL;
+  int rc;
+  char *zFunc8;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) || zFunctionName==0 ) return SQLITE_MISUSE_BKPT;
@@ -170599,7 +170597,7 @@
   sqlite3_value **NotUsed2   /* Value of each argument */
 ){
   const char *zName = (const char*)sqlite3_user_data(context);
-  char *zErr = NULL;
+  char *zErr;
   UNUSED_PARAMETER2(NotUsed, NotUsed2);
   zErr = sqlite3_mprintf(
       "unable to use function %s in the requested context", zName);
@@ -170624,8 +170622,8 @@
   const char *zName,
   int nArg
 ){
-  int rc = 0;
-  char *zCopy = NULL;
+  int rc;
+  char *zCopy;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) || zName==0 || nArg<-2 ){
@@ -170653,7 +170651,7 @@
 */
 #ifndef SQLITE_OMIT_DEPRECATED
 SQLITE_API void *sqlite3_trace(sqlite3 *db, void(*xTrace)(void*,const char*), void *pArg){
-  void *pOld = NULL;
+  void *pOld;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -170708,7 +170706,7 @@
   void (*xProfile)(void*,const char*,sqlite_uint64),
   void *pArg
 ){
-  void *pOld = NULL;
+  void *pOld;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -170738,7 +170736,7 @@
   int (*xCallback)(void*),  /* Function to invoke on each commit */
   void *pArg                /* Argument to the function */
 ){
-  void *pOld = NULL;
+  void *pOld;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -170763,7 +170761,7 @@
   void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),
   void *pArg                /* Argument to the function */
 ){
-  void *pRet = NULL;
+  void *pRet;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -170788,7 +170786,7 @@
   void (*xCallback)(void*), /* Callback function */
   void *pArg                /* Argument to the function */
 ){
-  void *pRet = NULL;
+  void *pRet;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -170913,7 +170911,7 @@
   void *pArg                      /* First argument passed to xCallback() */
 ){
 #ifndef SQLITE_OMIT_WAL
-  void *pRet = NULL;
+  void *pRet;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -170944,8 +170942,8 @@
 #ifdef SQLITE_OMIT_WAL
   return SQLITE_OK;
 #else
-  int rc = 0;                         /* Return code */
-  int iDb = 0;                        /* Schema to checkpoint */
+  int rc;                         /* Return code */
+  int iDb;                        /* Schema to checkpoint */
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
@@ -171027,7 +171025,7 @@
 */
 SQLITE_PRIVATE int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt){
   int rc = SQLITE_OK;             /* Return code */
-  int i = 0;                          /* Used to iterate through attached dbs */
+  int i;                          /* Used to iterate through attached dbs */
   int bBusy = 0;                  /* True if SQLITE_BUSY has been encountered */
 
   assert( sqlite3_mutex_held(db->mutex) );
@@ -171093,7 +171091,7 @@
 ** error.
 */
 SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){
-  const char *z = NULL;
+  const char *z;
   if( !db ){
     return sqlite3ErrStr(SQLITE_NOMEM_BKPT);
   }
@@ -171143,7 +171141,7 @@
     'm', 'i', 's', 'u', 's', 'e', 0
   };
 
-  const void *z = NULL;
+  const void *z;
   if( !db ){
     return (void *)outOfMem;
   }
@@ -171218,8 +171216,8 @@
   int(*xCompare)(void*,int,const void*,int,const void*),
   void(*xDel)(void*)
 ){
-  CollSeq *pColl = NULL;
-  int enc2 = 0;
+  CollSeq *pColl;
+  int enc2;
 
   assert( sqlite3_mutex_held(db->mutex) );
 
@@ -171258,7 +171256,7 @@
     */
     if( (pColl->enc & ~SQLITE_UTF16_ALIGNED)==enc2 ){
       CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName);
-      int j = 0;
+      int j;
       for(j=0; j<3; j++){
         CollSeq *p = &aColl[j];
         if( p->enc==pColl->enc ){
@@ -171351,7 +171349,7 @@
 ** from forming.
 */
 SQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){
-  int oldLimit = 0;
+  int oldLimit;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -171433,8 +171431,8 @@
   int rc = SQLITE_OK;
   unsigned int flags = *pFlags;
   const char *zVfs = zDefaultVfs;
-  char *zFile = NULL;
-  char c = 0;
+  char *zFile;
+  char c;
   int nUri = sqlite3Strlen30(zUri);
 
   assert( *pzErrMsg==0 );
@@ -171443,9 +171441,9 @@
             || sqlite3GlobalConfig.bOpenUri) /* IMP: R-51689-46548 */
    && nUri>=5 && memcmp(zUri, "file:", 5)==0 /* IMP: R-57884-37496 */
   ){
-    char *zOpt = NULL;
-    int eState = 0;                   /* Parser state when parsing URI */
-    int iIn = 0;                      /* Input character index */
+    char *zOpt;
+    int eState;                   /* Parser state when parsing URI */
+    int iIn;                      /* Input character index */
     int iOut = 0;                 /* Output character index */
     u64 nByte = nUri+8;           /* Bytes of space to allocate */
 
@@ -171601,7 +171599,7 @@
         }
 
         if( aMode ){
-          int i = 0;
+          int i;
           int mode = 0;
           for(i=0; aMode[i].z; i++){
             const char *z = aMode[i].z;
@@ -171683,12 +171681,12 @@
   unsigned int flags,    /* Operational flags */
   const char *zVfs       /* Name of the VFS to use */
 ){
-  sqlite3 *db = NULL;                    /* Store allocated handle here */
-  int rc = 0;                         /* Return code */
-  int isThreadsafe = 0;               /* True for threadsafe connections */
+  sqlite3 *db;                    /* Store allocated handle here */
+  int rc;                         /* Return code */
+  int isThreadsafe;               /* True for threadsafe connections */
   char *zOpen = 0;                /* Filename argument to pass to BtreeOpen() */
   char *zErrMsg = 0;              /* Error message from sqlite3ParseUri() */
-  int i = 0;                          /* Loop counter */
+  int i;                          /* Loop counter */
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( ppDb==0 ) return SQLITE_MISUSE_BKPT;
@@ -172036,9 +172034,9 @@
   const void *zFilename,
   sqlite3 **ppDb
 ){
-  char const *zFilename8 = NULL;   /* zFilename encoded in UTF-8 instead of UTF-16 */
-  sqlite3_value *pVal = NULL;
-  int rc = 0;
+  char const *zFilename8;   /* zFilename encoded in UTF-8 instead of UTF-16 */
+  sqlite3_value *pVal;
+  int rc;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( ppDb==0 ) return SQLITE_MISUSE_BKPT;
@@ -172092,7 +172090,7 @@
   int(*xCompare)(void*,int,const void*,int,const void*),
   void(*xDel)(void*)
 ){
-  int rc = 0;
+  int rc;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;
@@ -172117,7 +172115,7 @@
   int(*xCompare)(void*,int,const void*,int,const void*)
 ){
   int rc = SQLITE_OK;
-  char *zName8 = NULL;
+  char *zName8;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;
@@ -172277,7 +172275,7 @@
   int *pPrimaryKey,           /* OUTPUT: True if column part of PK */
   int *pAutoinc               /* OUTPUT: True if column is auto-increment */
 ){
-  int rc = 0;
+  int rc;
   char *zErrMsg = 0;
   Table *pTab = 0;
   Column *pCol = 0;
@@ -172385,8 +172383,8 @@
 ** Sleep for a little while.  Return the amount of time slept.
 */
 SQLITE_API int sqlite3_sleep(int ms){
-  sqlite3_vfs *pVfs = NULL;
-  int rc = 0;
+  sqlite3_vfs *pVfs;
+  int rc;
   pVfs = sqlite3_vfs_find(0);
   if( pVfs==0 ) return 0;
 
@@ -172415,7 +172413,7 @@
 */
 SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){
   int rc = SQLITE_ERROR;
-  Btree *pBtree = NULL;
+  Btree *pBtree;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
@@ -172423,8 +172421,8 @@
   sqlite3_mutex_enter(db->mutex);
   pBtree = sqlite3DbNameToBtree(db, zDbName);
   if( pBtree ){
-    Pager *pPager = NULL;
-    sqlite3_file *fd = NULL;
+    Pager *pPager;
+    sqlite3_file *fd;
     sqlite3BtreeEnter(pBtree);
     pPager = sqlite3BtreePager(pBtree);
     assert( pPager!=0 );
@@ -172513,7 +172511,7 @@
 #ifndef SQLITE_OMIT_WSD
     case SQLITE_TESTCTRL_PRNG_SEED: {
       int x = va_arg(ap, int);
-      int y = 0;
+      int y;
       sqlite3 *db = va_arg(ap, sqlite3*);
       assert( db==0 || db->aDb[0].pSchema!=0 );
       if( db && (y = db->aDb[0].pSchema->schema_cookie)!=0 ){ x = y; }
@@ -172572,8 +172570,8 @@
     */
     case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: {
       typedef void (*void_function)(void);
-      void_function xBenignBegin = 0;
-      void_function xBenignEnd = 0;
+      void_function xBenignBegin;
+      void_function xBenignEnd;
       xBenignBegin = va_arg(ap, void_function);
       xBenignEnd = va_arg(ap, void_function);
       sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
@@ -172811,7 +172809,7 @@
     */
     case SQLITE_TESTCTRL_IMPOSTER: {
       sqlite3 *db = va_arg(ap, sqlite3*);
-      int iDb = 0;
+      int iDb;
       sqlite3_mutex_enter(db->mutex);
       iDb = sqlite3FindDbName(db, va_arg(ap,const char*));
       if( iDb>=0 ){
@@ -172992,9 +172990,9 @@
   int nParam,
   const char **azParam
 ){
-  sqlite3_int64 nByte = 0;
-  int i = 0;
-  char *pResult = NULL, *p = NULL;
+  sqlite3_int64 nByte;
+  int i;
+  char *pResult, *p;
   nByte = strlen(zDatabase) + strlen(zJournal) + strlen(zWal) + 10;
   for(i=0; i<nParam*2; i++){
     nByte += strlen(azParam[i])+1;
@@ -173077,7 +173075,7 @@
   sqlite3_int64 bDflt       /* return if parameter is missing */
 ){
   const char *z = sqlite3_uri_parameter(zFilename, zParam);
-  sqlite3_int64 v = 0;
+  sqlite3_int64 v;
   if( z && sqlite3DecOrHexToI64(z, &v)==0 ){
     bDflt = v;
   }
@@ -173131,7 +173129,7 @@
 ** connection.
 */
 SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){
-  Btree *pBt = NULL;
+  Btree *pBt;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -173147,7 +173145,7 @@
 ** no such database exists.
 */
 SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName){
-  Btree *pBt = NULL;
+  Btree *pBt;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -173300,9 +173298,9 @@
 ** is not required for a match.
 */
 SQLITE_API int sqlite3_compileoption_used(const char *zOptName){
-  int i = 0, n = 0;
-  int nOpt = 0;
-  const char **azCompileOpt = NULL;
+  int i, n;
+  int nOpt;
+  const char **azCompileOpt;
 
 #if SQLITE_ENABLE_API_ARMOR
   if( zOptName==0 ){
@@ -173333,8 +173331,8 @@
 ** return a NULL pointer.
 */
 SQLITE_API const char *sqlite3_compileoption_get(int N){
-  int nOpt = 0;
-  const char **azCompileOpt = NULL;
+  int nOpt;
+  const char **azCompileOpt;
   azCompileOpt = sqlite3CompileOptions(&nOpt);
   if( N>=0 && N<nOpt ){
     return azCompileOpt[N];
@@ -193407,7 +193405,7 @@
 */
 static int jsonGrow(JsonString *p, u32 N){
   u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;
-  char *zNew = NULL;
+  char *zNew;
   if( p->bStatic ){
     if( p->bErr ) return 1;
     zNew = sqlite3_malloc64(nTotal);
@@ -193461,7 +193459,7 @@
 ** character is not '[' or '{'.
 */
 static void jsonAppendSeparator(JsonString *p){
-  char c = 0;
+  char c;
   if( p->nUsed==0 ) return;
   c = p->zBuf[p->nUsed-1];
   if( c!='[' && c!='{' ) jsonAppendChar(p, ',');
@@ -193473,7 +193471,7 @@
 ** string.
 */
 static void jsonAppendString(JsonString *p, const char *zIn, u32 N){
-  u32 i = 0;
+  u32 i;
   if( zIn==0 || ((N+p->nUsed+2 >= p->nAlloc) && jsonGrow(p,N+2)!=0) ) return;
   p->zBuf[p->nUsed++] = '"';
   for(i=0; i<N; i++){
@@ -193728,7 +193726,7 @@
 ** Convert a 4-byte hex string into an integer
 */
 static u32 jsonHexToInt4(const char *z){
-  u32 v = 0;
+  u32 v;
   assert( sqlite3Isxdigit(z[0]) );
   assert( sqlite3Isxdigit(z[1]) );
   assert( sqlite3Isxdigit(z[2]) );
@@ -193764,7 +193762,7 @@
     }
     case JSON_INT: {
       sqlite3_int64 i = 0;
-      const char *z = NULL;
+      const char *z;
       assert( pNode->eU==1 );
       z = pNode->u.zJContent;
       if( z[0]=='-' ){ z++; }
@@ -193792,9 +193790,9 @@
       int_as_real: ; /* no break */ deliberate_fall_through
     }
     case JSON_REAL: {
-      double r = 0;
+      double r;
 #ifdef SQLITE_AMALGAMATION
-      const char *z = NULL;
+      const char *z;
       assert( pNode->eU==1 );
       z = pNode->u.zJContent;
       sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);
@@ -193823,11 +193821,11 @@
                             SQLITE_TRANSIENT);
       }else{
         /* Translate JSON formatted string into raw text */
-        u32 i = 0;
+        u32 i;
         u32 n = pNode->n;
-        const char *z = NULL;
-        char *zOut = NULL;
-        u32 j = 0;
+        const char *z;
+        char *zOut;
+        u32 j;
         assert( pNode->eU==1 );
         z = pNode->u.zJContent;
         zOut = sqlite3_malloc( n+1 );
@@ -193851,7 +193849,7 @@
                 zOut[j++] = (char)(0xc0 | (v>>6));
                 zOut[j++] = 0x80 | (v&0x3f);
               }else{
-                u32 vlo = 0;
+                u32 vlo;
                 if( (v&0xfc00)==0xd800
                   && i<n-6
                   && z[i+1]=='\\'
@@ -193922,8 +193920,8 @@
   u32 n,                    /* Content size or sub-node count */
   const char *zContent      /* Content */
 ){
-  u32 nNew = 0;
-  JsonNode *pNew = NULL;
+  u32 nNew;
+  JsonNode *pNew;
   assert( pParse->nNode>=pParse->nAlloc );
   if( pParse->oom ) return -1;
   nNew = pParse->nAlloc*2 + 10;
@@ -193949,7 +193947,7 @@
   u32 n,                    /* Content size or sub-node count */
   const char *zContent      /* Content */
 ){
-  JsonNode *p = NULL;
+  JsonNode *p;
   if( pParse->aNode==0 || pParse->nNode>=pParse->nAlloc ){
     return jsonParseAddNodeExpand(pParse, eType, n, zContent);
   }
@@ -193966,7 +193964,7 @@
 ** Return true if z[] begins with 4 (or more) hexadecimal digits
 */
 static int jsonIs4Hex(const char *z){
-  int i = 0;
+  int i;
   for(i=0; i<4; i++) if( !sqlite3Isxdigit(z[i]) ) return 0;
   return 1;
 }
@@ -193980,11 +193978,11 @@
 ** non-whitespace character is ']'.
 */
 static int jsonParseValue(JsonParse *pParse, u32 i){
-  char c = 0;
-  u32 j = 0;
-  int iThis = 0;
-  int x = 0;
-  JsonNode *pNode = NULL;
+  char c;
+  u32 j;
+  int iThis;
+  int x;
+  JsonNode *pNode;
   const char *z = pParse->zJson;
   while( fast_isspace(z[i]) ){ i++; }
   if( (c = z[i])=='{' ){
@@ -194145,7 +194143,7 @@
   sqlite3_context *pCtx,       /* Report errors here */
   const char *zJson            /* Input JSON text to be parsed */
 ){
-  int i = 0;
+  int i;
   memset(pParse, 0, sizeof(*pParse));
   if( zJson==0 ) return 1;
   pParse->zJson = zJson;
@@ -194175,7 +194173,7 @@
 */
 static void jsonParseFillInParentage(JsonParse *pParse, u32 i, u32 iParent){
   JsonNode *pNode = &pParse->aNode[i];
-  u32 j = 0;
+  u32 j;
   pParse->aUp[i] = iParent;
   switch( pNode->eType ){
     case JSON_ARRAY: {
@@ -194201,7 +194199,7 @@
 ** Compute the parentage of all nodes in a completed parse.
 */
 static int jsonParseFindParents(JsonParse *pParse){
-  u32 *aUp = NULL;
+  u32 *aUp;
   assert( pParse->aUp==0 );
   aUp = pParse->aUp = sqlite3_malloc64( sizeof(u32)*pParse->nNode );
   if( aUp==0 ){
@@ -194233,9 +194231,9 @@
 ){
   const char *zJson = (const char*)sqlite3_value_text(argv[0]);
   int nJson = sqlite3_value_bytes(argv[0]);
-  JsonParse *p = NULL;
+  JsonParse *p;
   JsonParse *pMatch = 0;
-  int iKey = 0;
+  int iKey;
   int iMinKey = 0;
   u32 iMinHold = 0xffffffff;
   u32 iMaxHold = 0;
@@ -194318,8 +194316,8 @@
   int *pApnd,             /* Append nodes to complete path if not NULL */
   const char **pzErr      /* Make *pzErr point to any syntax error in zPath */
 ){
-  u32 i = 0, j = 0, nKey = 0;
-  const char *zKey = NULL;
+  u32 i, j, nKey;
+  const char *zKey;
   JsonNode *pRoot = &pParse->aNode[iRoot];
   if( zPath[0]==0 ) return pRoot;
   if( pRoot->jnFlags & JNODE_REPLACE ) return 0;
@@ -194362,8 +194360,8 @@
       j = 1;
     }
     if( pApnd ){
-      u32 iStart = 0, iLabel = 0;
-      JsonNode *pNode = NULL;
+      u32 iStart, iLabel;
+      JsonNode *pNode;
       iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);
       iLabel = jsonParseAddNode(pParse, JSON_STRING, nKey, zKey);
       zPath += i;
@@ -194440,8 +194438,8 @@
       return jsonLookupStep(pParse, iRoot+j, zPath, pApnd, pzErr);
     }
     if( i==0 && pApnd ){
-      u32 iStart = 0;
-      JsonNode *pNode = NULL;
+      u32 iStart;
+      JsonNode *pNode;
       iStart = jsonParseAddNode(pParse, JSON_ARRAY, 1, 0);
       pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
       if( pParse->oom ) return 0;
@@ -194512,7 +194510,7 @@
 ){
   const char *zErr = 0;
   JsonNode *pNode = 0;
-  char *zMsg = NULL;
+  char *zMsg;
 
   if( zPath==0 ) return 0;
   if( zPath[0]!='$' ){
@@ -194555,7 +194553,7 @@
 ** Mark all NULL entries in the Object passed in as JNODE_REMOVE.
 */
 static void jsonRemoveAllNulls(JsonNode *pNode){
-  int i = 0, n = 0;
+  int i, n;
   assert( pNode->eType==JSON_OBJECT );
   n = pNode->n;
   for(i=2; i<=n; i += jsonNodeSize(&pNode[i])+1){
@@ -194667,7 +194665,7 @@
   int argc,
   sqlite3_value **argv
 ){
-  int i = 0;
+  int i;
   JsonString jx;
 
   jsonInit(&jx, ctx);
@@ -194694,10 +194692,10 @@
   int argc,
   sqlite3_value **argv
 ){
-  JsonParse *p = NULL;          /* The parse */
+  JsonParse *p;          /* The parse */
   sqlite3_int64 n = 0;
-  u32 i = 0;
-  JsonNode *pNode = NULL;
+  u32 i;
+  JsonNode *pNode;
 
   p = jsonParseCached(ctx, argv, ctx);
   if( p==0 ) return;
@@ -194754,9 +194752,9 @@
   int argc,
   sqlite3_value **argv
 ){
-  JsonParse *p = NULL;          /* The parse */
-  JsonNode *pNode = NULL;
-  const char *zPath = NULL;
+  JsonParse *p;          /* The parse */
+  JsonNode *pNode;
+  const char *zPath;
   int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));
   JsonString jx;
 
@@ -194807,7 +194805,7 @@
   }else{
     /* Two or more PATH arguments results in a JSON array with each
     ** element of the array being the value selected by one of the PATHs */
-    int i = 0;
+    int i;
     jsonInit(&jx, ctx);
     jsonAppendChar(&jx, '[');
     for(i=1; i<argc; i++){
@@ -194837,9 +194835,9 @@
   u32 iTarget,         /* Node of the TARGET in pParse */
   JsonNode *pPatch     /* The PATCH */
 ){
-  u32 i = 0, j = 0;
-  u32 iRoot = 0;
-  JsonNode *pTarget = NULL;
+  u32 i, j;
+  u32 iRoot;
+  JsonNode *pTarget;
   if( pPatch->eType!=JSON_OBJECT ){
     return pPatch;
   }
@@ -194852,8 +194850,8 @@
   }
   iRoot = iTarget;
   for(i=1; i<pPatch->n; i += jsonNodeSize(&pPatch[i+1])+1){
-    u32 nKey = 0;
-    const char *zKey = NULL;
+    u32 nKey;
+    const char *zKey;
     assert( pPatch[i].eType==JSON_STRING );
     assert( pPatch[i].jnFlags & JNODE_LABEL );
     assert( pPatch[i].eU==1 );
@@ -194887,7 +194885,7 @@
       }
     }
     if( j>=pTarget->n && pPatch[i+1].eType!=JSON_NULL ){
-      int iStart = 0, iPatch = 0;
+      int iStart, iPatch;
       iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);
       jsonParseAddNode(pParse, JSON_STRING, nKey, zKey);
       iPatch = jsonParseAddNode(pParse, JSON_TRUE, 0, 0);
@@ -194921,7 +194919,7 @@
 ){
   JsonParse x;     /* The JSON that is being patched */
   JsonParse y;     /* The patch */
-  JsonNode *pResult = NULL;   /* The result of the merge */
+  JsonNode *pResult;   /* The result of the merge */
 
   UNUSED_PARAMETER(argc);
   if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
@@ -194951,10 +194949,10 @@
   int argc,
   sqlite3_value **argv
 ){
-  int i = 0;
+  int i;
   JsonString jx;
-  const char *z = NULL;
-  u32 n = 0;
+  const char *z;
+  u32 n;
 
   if( argc&1 ){
     sqlite3_result_error(ctx, "json_object() requires an even number "
@@ -194994,9 +194992,9 @@
   sqlite3_value **argv
 ){
   JsonParse x;          /* The parse */
-  JsonNode *pNode = NULL;
-  const char *zPath = NULL;
-  u32 i = 0;
+  JsonNode *pNode;
+  const char *zPath;
+  u32 i;
 
   if( argc<1 ) return;
   if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
@@ -195027,9 +195025,9 @@
   sqlite3_value **argv
 ){
   JsonParse x;          /* The parse */
-  JsonNode *pNode = NULL;
-  const char *zPath = NULL;
-  u32 i = 0;
+  JsonNode *pNode;
+  const char *zPath;
+  u32 i;
 
   if( argc<1 ) return;
   if( (argc&1)==0 ) {
@@ -195079,10 +195077,10 @@
   sqlite3_value **argv
 ){
   JsonParse x;          /* The parse */
-  JsonNode *pNode = NULL;
-  const char *zPath = NULL;
-  u32 i = 0;
-  int bApnd = 0;
+  JsonNode *pNode;
+  const char *zPath;
+  u32 i;
+  int bApnd;
   int bIsSet = sqlite3_user_data(ctx)!=0;
 
   if( argc<1 ) return;
@@ -195131,9 +195129,9 @@
   int argc,
   sqlite3_value **argv
 ){
-  JsonParse *p = NULL;          /* The parse */
-  const char *zPath = NULL;
-  JsonNode *pNode = NULL;
+  JsonParse *p;          /* The parse */
+  const char *zPath;
+  JsonNode *pNode;
 
   p = jsonParseCached(ctx, argv, ctx);
   if( p==0 ) return;
@@ -195159,7 +195157,7 @@
   int argc,
   sqlite3_value **argv
 ){
-  JsonParse *p = NULL;          /* The parse */
+  JsonParse *p;          /* The parse */
   UNUSED_PARAMETER(argc);
   p = jsonParseCached(ctx, argv, 0);
   sqlite3_result_int(ctx, p!=0);
@@ -195179,7 +195177,7 @@
   int argc,
   sqlite3_value **argv
 ){
-  JsonString *pStr = NULL;
+  JsonString *pStr;
   UNUSED_PARAMETER(argc);
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
   if( pStr ){
@@ -195194,7 +195192,7 @@
   }
 }
 static void jsonArrayCompute(sqlite3_context *ctx, int isFinal){
-  JsonString *pStr = NULL;
+  JsonString *pStr;
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
   if( pStr ){
     pStr->pCtx = ctx;
@@ -195234,12 +195232,12 @@
   int argc,
   sqlite3_value **argv
 ){
-  unsigned int i = 0;
+  unsigned int i;
   int inStr = 0;
   int nNest = 0;
-  char *z = NULL;
-  char c = 0;
-  JsonString *pStr = NULL;
+  char *z;
+  char c;
+  JsonString *pStr;
   UNUSED_PARAMETER(argc);
   UNUSED_PARAMETER(argv);
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
@@ -195282,9 +195280,9 @@
   int argc,
   sqlite3_value **argv
 ){
-  JsonString *pStr = NULL;
-  const char *z = NULL;
-  u32 n = 0;
+  JsonString *pStr;
+  const char *z;
+  u32 n;
   UNUSED_PARAMETER(argc);
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
   if( pStr ){
@@ -195303,7 +195301,7 @@
   }
 }
 static void jsonObjectCompute(sqlite3_context *ctx, int isFinal){
-  JsonString *pStr = NULL;
+  JsonString *pStr;
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
   if( pStr ){
     jsonAppendChar(pStr, '}');
@@ -195358,8 +195356,8 @@
   sqlite3_vtab **ppVtab,
   char **pzErr
 ){
-  sqlite3_vtab *pNew = NULL;
-  int rc = 0;
+  sqlite3_vtab *pNew;
+  int rc;
 
 /* Column numbers */
 #define JEACH_KEY     0
@@ -195400,7 +195398,7 @@
 
 /* constructor for a JsonEachCursor object for json_each(). */
 static int jsonEachOpenEach(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
-  JsonEachCursor *pCur = NULL;
+  JsonEachCursor *pCur;
 
   UNUSED_PARAMETER(p);
   pCur = sqlite3_malloc( sizeof(*pCur) );
@@ -195499,8 +195497,8 @@
   JsonString *pStr,
   JsonNode *pNode
 ){
-  int jj = 0, nn = 0;
-  const char *z = NULL;
+  int jj, nn;
+  const char *z;
   assert( pNode->eType==JSON_STRING );
   assert( pNode->jnFlags & JNODE_LABEL );
   assert( pNode->eU==1 );
@@ -195526,8 +195524,8 @@
   JsonString *pStr,        /* Write the path here */
   u32 i                    /* Path to this element */
 ){
-  JsonNode *pNode = NULL, *pUp = NULL;
-  u32 iUp = 0;
+  JsonNode *pNode, *pUp;
+  u32 iUp;
   if( i==0 ){
     jsonAppendChar(pStr, '$');
     return;
@@ -195561,7 +195559,7 @@
       if( p->eType==JSON_OBJECT ){
         jsonReturn(pThis, ctx, 0);
       }else if( p->eType==JSON_ARRAY ){
-        u32 iKey = 0;
+        u32 iKey;
         if( p->bRecursive ){
           if( p->iRowid==0 ) break;
           assert( p->sParse.aNode[p->sParse.aUp[p->i]].eU==3 );
@@ -195663,11 +195661,11 @@
   sqlite3_vtab *tab,
   sqlite3_index_info *pIdxInfo
 ){
-  int i = 0;                     /* Loop counter or computed array index */
+  int i;                     /* Loop counter or computed array index */
   int aIdx[2];               /* Index of constraints for JSON and ROOT */
   int unusableMask = 0;      /* Mask of unusable JSON and ROOT constraints */
   int idxMask = 0;           /* Mask of usable == constraints JSON and ROOT */
-  const struct sqlite3_index_constraint *pConstraint = NULL;
+  const struct sqlite3_index_constraint *pConstraint;
 
   /* This implementation assumes that JSON and ROOT are the last two
   ** columns in the table */
@@ -195676,8 +195674,8 @@
   aIdx[0] = aIdx[1] = -1;
   pConstraint = pIdxInfo->aConstraint;
   for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
-    int iCol = 0;
-    int iMask = 0;
+    int iCol;
+    int iMask;
     if( pConstraint->iColumn < JEACH_JSON ) continue;
     iCol = pConstraint->iColumn - JEACH_JSON;
     assert( iCol==0 || iCol==1 );
@@ -195724,9 +195722,9 @@
   int argc, sqlite3_value **argv
 ){
   JsonEachCursor *p = (JsonEachCursor*)cur;
-  const char *z = NULL;
+  const char *z;
   const char *zRoot = 0;
-  sqlite3_int64 n = 0;
+  sqlite3_int64 n;
 
   UNUSED_PARAMETER(idxStr);
   UNUSED_PARAMETER(argc);
@@ -195907,7 +195905,7 @@
     { "json_each",            &jsonEachModule               },
     { "json_tree",            &jsonTreeModule               },
   };
-  unsigned int i = 0;
+  unsigned int i;
   for(i=0; i<sizeof(aMod)/sizeof(aMod[0]) && rc==SQLITE_OK; i++){
     rc = sqlite3_create_module(db, aMod[i].zName, aMod[i].pModule, 0);
   }

# Alert Data Format

<legal>
'Redemption' Automated Code Repair Tool

Copyright 2023 Carnegie Mellon University.

NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
INSTITUTE MATERIAL IS FURNISHED ON AN 'AS-IS' BASIS. CARNEGIE MELLON
UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR
PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF
THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY
KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
INFRINGEMENT.

Licensed under a MIT (SEI)-style license, please see License.txt or
contact permission@sei.cmu.edu for full terms.

[DISTRIBUTION STATEMENT A] This material has been approved for public
release and unlimited distribution.  Please see Copyright notice for
non-US Government use and distribution.

This Software includes and/or makes use of Third-Party Software each
subject to its own license.

DM23-2165
</legal>

This document attempts to document the JSON structures that RFP uses
to describe and augment alert data.

## High-level structure

A JSON alert file consists of an array of dictionaries, wherein each
dictionary describes a single alert.  E.g.,

```json
[
  { ...alert1... },
  { ...alert2... },
  ...
  { ...alernN... }
]
```

An alert is represented as a dictionary of string key/value pairs,
hereafter referred to as *fields*.

## List of fields

* `alert_id` : integer

    Identifier for an alert with respect to the list the alert is in.
    This is assigned by the brain to alerts in the alert list passed
    to it in numerical order starting at 1 and is used internally as a
    unique identifier for that alert.

* `ast_id` : integer

    The AST node identifier that the alert has been associated with by
    the brain.
    
* `checker` : string

    The specific rule the `tool` used to generate the alert.

* `column` : string

    The column associated with the alert.
    
* `conflicting_repairs` : list

    A list of repairs that were unable to be used due to conflicts.
    Generated by `sup.py`.

* `edits` : list

    A user-generated list of repairs.  Identical to `patch`, but for
    user-generated edits rather than automatically generated edits.
    Used by the glove.

* `file` : string

    The file for which the alert was generated.  This is generally a
    relative path name.

* `issue` : string

    A JIRA issue or issues that are associated with this alert.

* `line` : string

    The line number of the `file` associated with the alert.

* `message` : string

    The message associated with the alert.  This is generally the
    human-readable text generated by the tool from which the alert was
    generated.  This is sometimes used by the brain for
    disambiguation.

* `overlapping_alerts` : list

    A list of repairs that were skipped due to their overlapping.
    Output by `sup.py`.

* `patch` : list

    A list of repairs (edits).

* `randomness` : string

    A (usually symbolic) reason this alert was chosen for manual
    analysis.

* `rationale` : string

    Manual analysis of the alert.

* `repair_algo` : list

    The algorithm, with attached information, that should be used for
    the repair.  This is a list of two elements.  The first element is
    a string which represents the algorithm.  The second element is
    any data that needs to be attached to the algorithm, and is
    specific to each algorithm.
 
* `repairable` : string

    A manual determination as to whether an alert is repairable.

* `rule` : string

    The CERT C Coding Standard rule, CWE, or other code flaw taxonomy
    condition associated with this alert.  Used in part by the brain
    to determine the appropriate remediation.

* `satisfactory` : string

    Whether the current automated process generates the desired repair
    (or lack of repair).

* `skipped_repair` : string

    A reason why a repair was skipped.  Generated by `sup.py`.

* `tool` : string

    The tool whose output was used to generate the alert, or `manual`
    if it was manually generated.
    
* `verdict` : string

    A manual determination as to whether the current alert actually
    violates the specified rule.
 
* `why_skipped` : string

    A reason why a repair was skipped.

## Table of field usage

| Field                 | Required | Created By | Used By          |
|:----------------------|----------|:-----------|:-----------------|
| `rule`                | yes      | author     | brain            |
| `file`                | yes      | author     | brain            |
| `line`                | yes      | author     | brain            |
| `column`              |          | author     | brain            |
| `tool`                |          | author     | brain            |
| `checker`             |          | author     | brain            |
| `message`             |          | author     | brain            |
| `satisfactory`        |          | author     |                  |
| `verdict`             |          | author     |                  |
| `repairable`          |          | author     |                  |
| `rationale`           |          | author     |                  |
| `randomness`          |          | author     |                  |
| `issue`               |          | author     |                  |
| `ast_id`              |          | brain      |                  |
| `repair_algo`         |          | brain      | brain, hand, sup |
| `alert_id`            |          | brain      | brain, sup       |
| `patch`               |          | hand, sup  | glove, sup       |
| `why_skipped`         |          | hand, sup  |                  |
| `edits`               |          | author     | glove            |
| `skipped_repair`      |          | sup        |                  |
| `overlapping_alerts`  |          | sup        |                  |
| `conflicting_repairs` |          | sup        |                  |
